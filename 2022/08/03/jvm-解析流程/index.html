<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>jvm-解析流程</title><meta name="description" content="Let's go"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="https://zincv.oss-cn-hangzhou.aliyuncs.com/IMG_1541.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="参考 java 虚拟机规范：5. Loading, Linking, and Initializing
java 编译器将 .java 源文件编译成 .class 文件时，并不会直接将类中的字段或方法等直接编译成内存中的地址，而是使用符号引用来暂时代替，并且符号引用是用类的全限定类型、方法名和字段名等形式存在，比如下面的代码片段中：
String str = &amp;quot;hi&amp;quot;;
System.out.println(str);

其中的 String 类和 println 方法会被编译成：java/lang/String 和 java/io/PrintStream.println；而类加载过程中的解析阶段会将这些符号引用替换为实际的内存地址
解析主要分为四种类型：类或接口解析、字段解析、方法解析.."><meta name="generator" content="Hexo 7.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Zhangdd's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">jvm-解析流程</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-text">1. 类或接口的解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90"><span class="toc-text">2. 字段解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">3. 方法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">4. 接口方法解析</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/jvm"><i class="tag post-item-tag">jvm</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">jvm-解析流程</h1><time class="has-text-grey" datetime="2022-08-03T14:46:49.000Z">2022-08-03</time><article class="mt-2 post-content"><p>参考 <code>java</code> 虚拟机规范：<code>5. Loading, Linking, and Initializing</code></p>
<p><code>java</code> 编译器将 <code>.java</code> 源文件编译成 <code>.class</code> 文件时，并不会直接将类中的字段或方法等直接编译成内存中的地址，而是使用符号引用来暂时代替，并且符号引用是用类的全限定类型、方法名和字段名等形式存在，比如下面的代码片段中：</p>
<pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span>;
System.out.println(str);</code></pre>

<p>其中的 <code>String</code> 类和 <code>println</code> 方法会被编译成：<code>java/lang/String</code> 和 <code>java/io/PrintStream.println</code>；而类加载过程中的解析阶段会将这些符号引用替换为实际的内存地址</p>
<p>解析主要分为四种类型：类或接口解析、字段解析、方法解析和接口方法解析。</p>
<h3 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1. 类或接口的解析"></a>1. 类或接口的解析</h3><p> <strong>符号引用</strong>：在字节码中，类和接口是通过符号引用来表示的（例如，通过类的全限定名，如<code>java/lang/String</code>）。</p>
<p> <strong>解析步骤</strong>：类加载器会使用符号引用去寻找相应的类或接口定义，并将其解析为具体的类对象。</p>
<p><strong>过程</strong>：<br>    1. 首先，<code>JVM</code> 会通过当前类的类加载器找到对应的符号引用（通常是类的全限定名）。<br>    2. <code>JVM</code> 会调用类加载器的<code>loadClass</code>方法来加载该类。<br>    3. 如果成功找到并加载该类或接口，则解析成功。<br>    4. 如果加载失败，则抛出<code>ClassNotFoundException</code>或<code>NoClassDefFoundError</code>异常。</p>
<h3 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2. 字段解析"></a>2. 字段解析</h3><p><strong>符号引用</strong>：在字节码中，类的字段也是通过符号引用来表示的（例如，<code>cn/wwinter/MyClass.myField</code>）。</p>
<p><strong>解析步骤</strong>：当解析字段时，首先需要解析它所在的类或接口。</p>
<p><strong>过程</strong>：<br>    1. 首先，<code>JVM</code> 解析字段所在的类或接口。如果类或接口的解析失败，则抛出异常。<br>    2. 如果类解析成功，<code>JVM</code> 会查找该字段是否在类或接口中定义。<br>    3. 如果字段在该类或其父类中找到，解析成功。<br>    4. 如果字段未找到，则抛出 <code>NoSuchFieldError</code> 异常。</p>
<h3 id="3-方法解析"><a href="#3-方法解析" class="headerlink" title="3. 方法解析"></a>3. 方法解析</h3><p><strong>符号引用</strong>：在字节码中，方法调用是通过符号引用来表示的（例如，<code>cn/wwinter/MyClass.myMethod()</code>）。</p>
<p><strong>解析步骤</strong>：解析方法的过程与解析字段类似，但要考虑方法的重载与继承。</p>
<p><strong>过程</strong>：<br>    1. 首先，解析方法所在的类或接口。<br>    2. 然后，查找该方法在类或接口中是否存在，并确保方法签名匹配。<br>    3. 如果找到匹配的方法，则解析成功。<br>    4. 如果方法未找到或签名不匹配，则抛出<code>NoSuchMethodError</code>异常。</p>
<h3 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4. 接口方法解析"></a>4. 接口方法解析</h3><p><strong>符号引用</strong>：接口方法的调用也是通过符号引用表示的，通常是指通过<code>invokeinterface</code>字节码指令来调用接口中的方法。</p>
<p><strong>解析步骤</strong>：与普通方法解析类似，但是接口方法解析更复杂一些，因为需要考虑多个实现类。</p>
<p><strong>过程</strong>：<br>    1. 首先解析接口。<br>    2. 然后，查找接口中声明的方法。如果接口解析成功并找到方法，则解析成功。<br>    3. 如果方法未找到，则抛出<code>AbstractMethodError</code>异常。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/08/07/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" title="jvm-类加载流程"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: jvm-类加载流程</span></a><a class="button is-default" href="/2022/08/01/oom%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8B/" title="oom异常实例"><span class="has-text-weight-semibold">下一页: oom异常实例</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Zhangdd/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/wwinter117"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Zhangdd 2021 - 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="site author" target="_blank" rel="noopener" href="//github.com/wwinter117">Hosted by Zhangdd&nbsp;</a></p><!--div(style="margin-top: 2px")--><!--  a(title="github-button" class="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true")--></div><div><span>浙备7837-534598</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>