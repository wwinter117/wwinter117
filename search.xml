<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自己实现一个简易的redis</title>
      <link href="/2023/07/12/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84redis/"/>
      <url>/2023/07/12/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84redis/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/redis-5fb76d3ec9fd434fe46a579d9c1c8a83.jpeg"></p><p>项目地址：<a href="https://github.com/wwinter117/mini-redis.git">https://github.com/wwinter117/mini-redis.git</a></p><p>不定期更新中…</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的xv6操作系统的lab实验解法</title>
      <link href="/2023/06/26/%E6%88%91%E7%9A%84xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84lab%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%B3%95/"/>
      <url>/2023/06/26/%E6%88%91%E7%9A%84xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84lab%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/xv6-Pasted%20image%2020241002142130.png"></p><ul><li>课程官网：<a href="https://pdos.csail.mit.edu/6.828/2020/xv6.html">6.S081 Fall 2020</a> 或者 <a href="https://pdos.csail.mit.edu/6.S081/2023/">6.S081 Fall 2023</a></li><li>课程视频：<a href="https://www.bilibili.com/video/BV19k4y1C7kA?from=search&seid=5542820295808098475">6.S081–bilibili</a></li></ul><ul><li>我的私人仓库：<a href="https://github.com/wwinter117/xv6-labs.git">https://github.com/wwinter117/xv6-labs.git</a></li></ul><h1 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1: Xv6 and Unix utilities"></a>Lab1: Xv6 and Unix utilities</h1><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="启动xv6-难度：Easy"><a href="#启动xv6-难度：Easy" class="headerlink" title="启动xv6(难度：Easy)"></a>启动xv6(难度：Easy)</h3><p>获取实验室的xv6源代码并切换到util分支</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span>Cloning into &#x27;xv6-labs-2020&#x27;......<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> xv6-labs-2020</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout util</span>Branch &#x27;util&#x27; set up to track remote branch &#x27;util&#x27; from &#x27;origin&#x27;.Switched to a new branch &#x27;util&#x27;</code></pre><p><code>xv6-labs-2020</code> 存储库与本书的 <code>xv6-riscv</code> 稍有不同;它主要添加一些文件。如果你好奇的话，可以执行 <code>git log</code>:</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span></code></pre><p>您将需要使用Git版本控制系统管理和提交文件以及后续的实验室作业。接下来，切换到一个分支(执行<code>git checkout util</code>)，其中包含针对该实验室定制的xv6版本。要了解关于Git的更多信息，请查看Git用户手册。Git允许您跟踪对代码所做的更改。例如，如果你完成了其中一个练习，并且想检查你的进度，你可以通过运行以下命令来提交你的变化:</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;my solution for util lab exercise 1&#x27;</span></span>Created commit 60d2135: my solution for util lab exercise 1 1 files changed, 1 insertions(+), 0 deletions(-)<span class="hljs-meta prompt_">$</span></code></pre><p>您可以使用<code>git diff</code>命令跟踪您的更改。运行<code>git diff</code>将显示自上次提交以来对代码的更改，<code>git diff origin/util</code>将显示相对于初始xv6-labs-2020代码的更改。这里，_<strong>origin&#x2F;xv6-labs-2020</strong>_ 是git分支的名称，它是包含您下载的初始代码分支。</p><ul><li><strong>构建并运行xv6</strong></li></ul><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.Sriscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c...  riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.oriscv64-unknown-elf-objdump -S user/_zombie &amp;gt; user/zombie.asmriscv64-unknown-elf-objdump -t user/_zombie | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27; &amp;gt; user/zombie.symmkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000balloc: first 591 blocks have been allocatedballoc: write bitmap block at sector 45qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0xv6 kernel is bootinghart 2 startinghart 1 startinginit: starting sh<span class="hljs-meta prompt_">$ </span></code></pre><p>如果你在提示符下输入 <code>ls</code>，你会看到类似如下的输出:</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span>.              1 1 1024..             1 1 1024README         2 2 2059xargstest.sh   2 3 93cat            2 4 24256echo           2 5 23080forktest       2 6 13272grep           2 7 27560init           2 8 23816kill           2 9 23024ln             2 10 22880ls             2 11 26448mkdir          2 12 23176rm             2 13 23160sh             2 14 41976stressfs       2 15 24016usertests      2 16 148456grind          2 17 38144wc             2 18 25344zombie         2 19 22408console        3 20 0</code></pre><p>这些是<code>mkfs</code>在初始文件系统中包含的文件；大多数是可以运行的程序。你刚刚跑了其中一个：<code>ls</code>。</p><p>xv6没有<code>ps</code>命令，但是如果您键入Ctrl-p，内核将打印每个进程的信息。如果现在尝试，您将看到两行：一行用于init，另一行用于sh。</p><p>退出 qemu : <code>Ctrl-a x</code>。</p><h3 id="sleep-难度：Easy"><a href="#sleep-难度：Easy" class="headerlink" title="sleep(难度：Easy)"></a>sleep(难度：Easy)</h3><blockquote><p>[!TIP|label:YOUR JOB] <strong>实现xv6的UNIX程序</strong><code>sleep</code><strong>：您的</strong><code>sleep</code><strong>应该暂停到用户指定的计时数。一个滴答(tick)是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间。您的解决方案应该在文件_user&#x2F;sleep.c_中</strong></p></blockquote><p><strong>提示：</strong></p><ul><li><p>在你开始编码之前，请阅读《book-riscv-rev1》的第一章</p></li><li><p>看看其他的一些程序（如***&#x2F;user&#x2F;echo.c, &#x2F;user&#x2F;grep.c, &#x2F;user&#x2F;rm.c***）查看如何获取传递给程序的命令行参数</p></li><li><p>如果用户忘记传递参数，<code>sleep</code>应该打印一条错误信息</p></li><li><p>命令行参数作为字符串传递; 您可以使用<code>atoi</code>将其转换为数字（详见***&#x2F;user&#x2F;ulib.c***）</p></li><li><p>使用系统调用<code>sleep</code></p></li><li><p>请参阅_<strong>kernel&#x2F;sysproc.c</strong><em>以获取实现<code>sleep</code>系统调用的xv6内核代码（查找<code>sys_sleep</code>），</em><strong>user&#x2F;user.h</strong><em>提供了<code>sleep</code>的声明以便其他程序调用，用汇编程序编写的</em><strong>user&#x2F;usys.S</strong>_可以帮助<code>sleep</code>从用户区跳转到内核区。</p></li><li><p>确保<code>main</code>函数调用<code>exit()</code>以退出程序。</p></li><li><p>将你的<code>sleep</code>程序添加到_<strong>Makefile</strong>_中的<code>UPROGS</code>中；完成之后，<code>make qemu</code>将编译您的程序，并且您可以从xv6的shell运行它。</p></li><li><p>看看Kernighan和Ritchie编著的《C程序设计语言》（第二版）来了解C语言。</p></li></ul><p>从xv6 shell运行程序：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>...init: starting sh<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sleep</span> 10</span>(nothing happens for a little while)<span class="hljs-meta prompt_">$</span></code></pre><p>如果程序在如上所示运行时暂停，则解决方案是正确的。运行<code>make grade</code>看看你是否真的通过了睡眠测试。</p><p>请注意，<code>make grade</code>运行所有测试，包括下面作业的测试。如果要对一项作业运行成绩测试，请键入（不要启动XV6，在外部终端下使用）：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./grade-lab-util <span class="hljs-built_in">sleep</span></span></code></pre><p>这将运行与<code>sleep</code>匹配的成绩测试。或者，您可以键入：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make GRADEFLAGS=<span class="hljs-built_in">sleep</span> grade</span></code></pre><p>效果是一样的。</p><h3 id="pingpong（难度：Easy）"><a href="#pingpong（难度：Easy）" class="headerlink" title="pingpong（难度：Easy）"></a>pingpong（难度：Easy）</h3><blockquote><p>[!TIP|label:YOUR JOB] <strong>编写一个使用UNIX系统调用的程序来在两个进程之间“ping-pong”一个字节，请使用两个管道，每个方向一个。父进程应该向子进程发送一个字节;子进程应该打印“<code>&lt;pid&gt;: received ping</code>”，其中<code>&lt;pid&gt;</code>是进程ID，并在管道中写入字节发送给父进程，然后退出;父级应该从读取从子进程而来的字节，打印“<code>&lt;pid&gt;: received pong</code>”，然后退出。您的解决方案应该在文件_user&#x2F;pingpong.c_中。</strong></p></blockquote><p><strong>提示：</strong></p><ul><li><p>使用<code>pipe</code>来创造管道</p></li><li><p>使用<code>fork</code>创建子进程</p></li><li><p>使用<code>read</code>从管道中读取数据，并且使用<code>write</code>向管道中写入数据</p></li><li><p>使用<code>getpid</code>获取调用进程的pid</p></li><li><p>将程序加入到_<strong>Makefile</strong>_的<code>UPROGS</code></p></li><li><p>xv6上的用户程序有一组有限的可用库函数。您可以在_<strong>user&#x2F;user.h</strong><em>中看到可调用的程序列表；源代码（系统调用除外）位于</em><strong>user&#x2F;ulib.c</strong><em>、</em><strong>user&#x2F;printf.c</strong><em>和</em><strong>user&#x2F;umalloc.c</strong>_中。</p></li></ul><p>运行程序应得到下面的输出</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>...init: starting sh<span class="hljs-meta prompt_">$ </span><span class="language-bash">pingpong</span>4: received ping3: received pong<span class="hljs-meta prompt_">$</span></code></pre><p>如果您的程序在两个进程之间交换一个字节并产生如上所示的输出，那么您的解决方案是正确的。</p><h3 id="Primes-素数，难度：Moderate-Hard"><a href="#Primes-素数，难度：Moderate-Hard" class="headerlink" title="Primes(素数，难度：Moderate&#x2F;Hard)"></a>Primes(素数，难度：Moderate&#x2F;Hard)</h3><blockquote><p>[!TIP|label:YOUR JOB] <strong>使用管道编写</strong><code>prime sieve</code><strong>(筛选素数)的并发版本。这个想法是由Unix管道的发明者Doug McIlroy提出的。请查看<a href="http://swtch.com/~rsc/thread/">这个网站</a>(翻译在下面)，该网页中间的图片和周围的文字解释了如何做到这一点。您的解决方案应该在_user&#x2F;primes.c_文件中。</strong></p></blockquote><p>您的目标是使用<code>pipe</code>和<code>fork</code>来设置管道。第一个进程将数字2到35输入管道。对于每个素数，您将安排创建一个进程，该进程通过一个管道从其左邻居读取数据，并通过另一个管道向其右邻居写入数据。由于xv6的文件描述符和进程数量有限，因此第一个进程可以在35处停止。</p><p><strong>提示：</strong></p><ul><li><p>请仔细关闭进程不需要的文件描述符，否则您的程序将在第一个进程达到35之前就会导致xv6系统资源不足。</p></li><li><p>一旦第一个进程达到35，它应该使用<code>wait</code>等待整个管道终止，包括所有子孙进程等等。因此，主<code>primes</code>进程应该只在打印完所有输出之后，并且在所有其他<code>primes</code>进程退出之后退出。</p></li><li><p>提示：当管道的<code>write</code>端关闭时，<code>read</code>返回零。</p></li><li><p>最简单的方法是直接将32位（4字节）int写入管道，而不是使用格式化的ASCII I&#x2F;O。</p></li><li><p>您应该仅在需要时在管线中创建进程。</p></li><li><p>将程序添加到_<strong>Makefile</strong>_中的<code>UPROGS</code></p></li></ul><p>如果您的解决方案实现了基于管道的筛选并产生以下输出，则是正确的：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>...init: starting sh<span class="hljs-meta prompt_">$ </span><span class="language-bash">primes</span>prime 2prime 3prime 5prime 7prime 11prime 13prime 17prime 19prime 23prime 29prime 31<span class="hljs-meta prompt_">$</span></code></pre><p><strong>参考资料翻译：</strong></p><blockquote><p>考虑所有小于1000的素数的生成。Eratosthenes的筛选法可以通过执行以下伪代码的进程管线来模拟：</p></blockquote><pre><code class="hljs c">p = get a number from left neighborprint ploop:    n = get a number from left neighbor    <span class="hljs-keyword">if</span> (p does not divide n)        send n to right neighborp = 从左邻居中获取一个数print ploop:    n = 从左邻居中获取一个数    <span class="hljs-keyword">if</span> (n不能被p整除)        将n发送给右邻居</code></pre><p><a href="https://github.com/duguosheng/6.S081-All-in-one/blob/main/labs/requirements/images/p1.png"><img src="https://github.com/duguosheng/6.S081-All-in-one/raw/main/labs/requirements/images/p1.png" alt="img"></a></p><blockquote><p>生成进程可以将数字2、3、4、…、1000输入管道的左端：行中的第一个进程消除2的倍数，第二个进程消除3的倍数，第三个进程消除5的倍数，依此类推。</p></blockquote><h3 id="find（难度：Moderate）"><a href="#find（难度：Moderate）" class="headerlink" title="find（难度：Moderate）"></a>find（难度：Moderate）</h3><blockquote><p>[!TIP|label:YOUR JOB] <strong>写一个简化版本的UNIX的<code>find</code>程序：查找目录树中具有特定名称的所有文件，你的解决方案应该放在_user&#x2F;find.c_</strong></p></blockquote><p>提示：</p><ul><li>查看_<strong>user&#x2F;ls.c</strong>_文件学习如何读取目录</li><li>使用递归允许<code>find</code>下降到子目录中</li><li>不要在“<code>.</code>”和“<code>..</code>”目录中递归</li><li>对文件系统的更改会在qemu的运行过程中一直保持；要获得一个干净的文件系统，请运行<code>make clean</code>，然后<code>make qemu</code></li><li>你将会使用到C语言的字符串，要学习它请看《C程序设计语言》（K&amp;R）,例如第5.5节</li><li>注意在C语言中不能像python一样使用“<code>==</code>”对字符串进行比较，而应当使用<code>strcmp()</code></li><li>将程序加入到Makefile的<code>UPROGS</code></li></ul><p>如果你的程序输出下面的内容，那么它是正确的（当文件系统中包含文件_<strong>b</strong><em>和</em><strong>a&#x2F;b</strong>_的时候）</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>...init: starting sh<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> &gt; b</span><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> a</span><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> &gt; a/b</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">find . b</span>./b./a/b<span class="hljs-meta prompt_">$ </span></code></pre><h3 id="xargs（难度：Moderate）"><a href="#xargs（难度：Moderate）" class="headerlink" title="xargs（难度：Moderate）"></a>xargs（难度：Moderate）</h3><blockquote><p>[!TIP|label:YOUR JOB] 编写一个简化版UNIX的<code>xargs</code>程序：它从标准输入中按行读取，并且为每一行执行一个命令，将行作为参数提供给命令。你的解决方案应该在_<strong>user&#x2F;xargs.c</strong>_</p></blockquote><p>下面的例子解释了<code>xargs</code>的行为</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span></span>bye hello too<span class="hljs-meta prompt_">$</span></code></pre><p>注意，这里的命令是<code>echo bye</code>，额外的参数是<code>hello too</code>，这样就组成了命令<code>echo bye hello too</code>，此命令输出<code>bye hello too</code></p><p>请注意，UNIX上的<code>xargs</code>进行了优化，一次可以向该命令提供更多的参数。 我们不需要您进行此优化。 要使UNIX上的<code>xargs</code>表现出本实验所实现的方式，请将<code>-n</code>选项设置为1。例如</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="hljs-built_in">echo</span> line</span>line 1line 2<span class="hljs-meta prompt_">$</span></code></pre><p><strong>提示：</strong></p><ul><li>使用<code>fork</code>和<code>exec</code>对每行输入调用命令，在父进程中使用<code>wait</code>等待子进程完成命令。</li><li>要读取单个输入行，请一次读取一个字符，直到出现换行符（’\n’）。</li><li>_<strong>kernel&#x2F;param.h</strong>_声明<code>MAXARG</code>，如果需要声明<code>argv</code>数组，这可能很有用。</li><li>将程序添加到_<strong>Makefile</strong>_中的<code>UPROGS</code>。</li><li>对文件系统的更改会在qemu的运行过程中保持不变；要获得一个干净的文件系统，请运行<code>make clean</code>，然后<code>make qemu</code></li></ul><p><code>xargs</code>、<code>find</code>和<code>grep</code>结合得很好</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">find . b | xargs grep hello</span></code></pre><p>将对“<code>.</code>”下面的目录中名为_<strong>b</strong>_的每个文件运行<code>grep hello</code>。</p><p>要测试您的<code>xargs</code>方案是否正确，请运行shell脚本_<strong>xargstest.sh</strong>_。如果您的解决方案产生以下输出，则是正确的：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>...init: starting sh<span class="hljs-meta prompt_">$ </span><span class="language-bash">sh &lt; xargstest.sh</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">$ $ $ $ $ hello</span>hellohello<span class="hljs-meta prompt_">$ </span><span class="language-bash">$</span></code></pre><p>你可能不得不回去修复你的<code>find</code>程序中的bug。输出有许多<code>$</code>，因为xv6 shell没有意识到它正在处理来自文件而不是控制台的命令，并为文件中的每个命令打印<code>$</code>。</p><h2 id="提交实验"><a href="#提交实验" class="headerlink" title="提交实验"></a>提交实验</h2><p><strong>这就完成了实验</strong>。确保你通过了所有的成绩测试。如果这个实验有问题，别忘了把你的答案写在_<strong>answers-lab-name.txt</strong><em>中***。</em><strong>提交你的更改（包括</strong>_answers-lab-name.txt***），然后在实验目录中键入<code>make handin</code>以提交实验。</p><p><strong>花费的时间</strong></p><p>创建一个命名为_<strong>time.txt</strong>_的新文件，并在其中输入一个整数，即您在实验室花费的小时数。不要忘记<code>git add</code>和<code>git commit</code>文件。</p><p><strong>提交</strong></p><p>你将使用 <strong><a href="https://6828.scripts.mit.edu/2020/handin.py/">提交网站</a></strong> 提交作业。您需要从提交网站请求一次API密钥，然后才能提交任何作业或实验。</p><p>将最终更改提交到实验后，键入<code>make handin</code>以提交实验。</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&quot;ready to submit my lab&quot;</span></span>[util c2e3c8b] ready to submit my lab 2 files changed, 18 insertions(+), 2 deletions(-)<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make handin</span>tar: Removing leading `/&#x27; from member namesGet an API key for yourself by visiting https://6828.scripts.mit.edu/2020/handin.py/Please enter your API key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<span class="hljs-meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span>                                 Dload  Upload   Total   Spent    Left  Speed100 79258  100   239  100 79019    853   275k --:--:-- --:--:-- --:--:--  276k<span class="hljs-meta prompt_">$</span></code></pre><p><code>make handin</code>将把你的API密钥存储在_<strong>myapi.key</strong><em>中。如果需要更改API密钥，只需删除此文件并让<code>make handin</code>再次生成它(</em><strong>myapi.key</strong>_不得包含换行符）。</p><p>如果你运行了<code>make handin</code>，并且你有未提交的更改或未跟踪的文件，则会看到类似于以下内容的输出：</p><pre><code class="hljs plaintext"> M hello.c?? bar.c?? foo.pycUntracked files will not be handed in.  Continue? [y/N]</code></pre><p>检查上述行，确保跟踪了您的实验解决方案所需的所有文件，即以??开头的行中所显示的文件。您可以使用<code>git add filename</code>命令使git追踪创建的新文件。</p><p>如果<code>make handin</code>无法正常工作，请尝试使用curl或Git命令修复该问题。或者你可以运行<code>make tarball</code>。这将为您制作一个tar文件，然后您可以通过我们的web界面上传。</p><ul><li>请运行“<code>make grade</code>”以确保您的代码通过所有测试</li><li>在运行“<code>make handin</code>”之前提交任何修改过的源代码&#96;</li><li>您可以检查提交的状态，并在以下位置下载提交的代码：<a href="https://6828.scripts.mit.edu/2020/handin.py/">https://6828.scripts.mit.edu/2020/handin.py/</a></li></ul><h2 id="可选的挑战练习"><a href="#可选的挑战练习" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><ul><li><p>编写一个<code>uptime</code>程序，使用<code>uptime</code>系统调用以滴答为单位打印计算机正常运行时间。（easy）</p></li><li><p>在<code>find</code>程序的名称匹配中支持正则表达式。_<strong>grep.c</strong>_对正则表达式有一些基本的支持。（easy）</p></li><li><p>xv6 shell（_<strong>user&#x2F;sh.c</strong>_）只是另一个用户程序，您可以对其进行改进。它是一个最小的shell，缺少建立在真实shell中的许多特性。例如，</p><ul><li>在处理<strong>文件中的</strong>shell命令时，将shell修改为不打印$（moderate）</li><li>将shell修改为支持<code>wait</code>（easy）</li><li>将shell修改为支持用“<code>;</code>”分隔的命令列表（moderate）</li><li>通过实现左括号“<code>(</code>” 以及右括号“<code>)</code>”来修改shell以支持子shell（moderate）</li><li>将shell修改为支持<code>tab</code>键补全（easy）</li><li>修改shell使其支持命令历史记录（moderate）</li><li>或者您希望shell执行的任何其他操作。</li></ul></li><li><p>如果您非常雄心勃勃，可能需要修改内核以支持所需的内核特性；xv6支持的并不多。</p></li></ul><h1 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h1><p>在上一个实验室中，您使用系统调用编写了一些实用程序。在本实验室中，您将向xv6添加一些新的系统调用，这将帮助您了解它们是如何工作的，并使您了解xv6内核的一些内部结构。您将在以后的实验室中添加更多系统调用。</p><blockquote><p>[!WARNING|label:Attention] 在你开始写代码之前，请阅读xv6手册《book-riscv-rev1》的第2章、第4章的第4.3节和第4.4节以及相关源代码文件：</p><ul><li>系统调用的用户空间代码在_<strong>user&#x2F;user.h</strong><em>和</em><strong>user&#x2F;usys.pl</strong>_中。</li><li>内核空间代码是_<strong>kernel&#x2F;syscall.h</strong><em>、</em><strong>kernel&#x2F;syscall.c</strong>_。</li><li>与进程相关的代码是_<strong>kernel&#x2F;proc.h</strong><em>和</em><strong>kernel&#x2F;proc.c</strong>_。</li></ul></blockquote><p>要开始本章实验，请将代码切换到<strong>syscall</strong>分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout syscall</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><p>如果运行<code>make grade</code>，您将看到测试分数的脚本无法执行<code>trace</code>和<code>sysinfotest</code>。您的工作是添加必要的系统调用和存根（stubs）以使它们工作。</p><h2 id="实验任务-1"><a href="#实验任务-1" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="System-call-tracing（moderate）"><a href="#System-call-tracing（moderate）" class="headerlink" title="System call tracing（moderate）"></a>System call tracing（moderate）</h3><blockquote><p>[!TIP|label:YOUR JOB] 在本作业中，您将添加一个系统调用跟踪功能，该功能可能会在以后调试实验时对您有所帮助。您将创建一个新的<code>trace</code>系统调用来控制跟踪。它应该有一个参数，这个参数是一个整数“掩码”（mask），它的比特位指定要跟踪的系统调用。例如，要跟踪<code>fork</code>系统调用，程序调用<code>trace(1 &lt;&lt; SYS_fork)</code>，其中<code>SYS_fork</code>是_<strong>kernel&#x2F;syscall.h</strong>_中的系统调用编号。如果在掩码中设置了系统调用的编号，则必须修改xv6内核，以便在每个系统调用即将返回时打印出一行。该行应该包含进程id、系统调用的名称和返回值；您不需要打印系统调用参数。<code>trace</code>系统调用应启用对调用它的进程及其随后派生的任何子进程的跟踪，但不应影响其他进程。</p></blockquote><p>我们提供了一个用户级程序版本的<code>trace</code>，它运行另一个启用了跟踪的程序（参见_<strong>user&#x2F;trace.c</strong>_）。完成后，您应该看到如下输出：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">trace 32 grep hello README</span>3: syscall read -&gt; 10233: syscall read -&gt; 9663: syscall read -&gt; 703: syscall read -&gt; 0<span class="hljs-meta prompt_">$</span><span class="language-bash"></span><span class="language-bash">$ trace 2147483647 grep hello README</span>4: syscall trace -&gt; 04: syscall exec -&gt; 34: syscall open -&gt; 34: syscall read -&gt; 10234: syscall read -&gt; 9664: syscall read -&gt; 704: syscall read -&gt; 04: syscall close -&gt; 0<span class="hljs-meta prompt_">$</span><span class="language-bash"></span><span class="language-bash">$ grep hello README</span><span class="hljs-meta prompt_">$</span><span class="language-bash"></span><span class="language-bash">$ trace 2 usertests forkforkfork</span>usertests startingtest forkforkfork: 407: syscall fork -&gt; 408408: syscall fork -&gt; 409409: syscall fork -&gt; 410410: syscall fork -&gt; 411409: syscall fork -&gt; 412410: syscall fork -&gt; 413409: syscall fork -&gt; 414411: syscall fork -&gt; 415...<span class="hljs-meta prompt_">$ </span><span class="language-bash"> </span></code></pre><p>在上面的第一个例子中，<code>trace</code>调用<code>grep</code>，仅跟踪了<code>read</code>系统调用。<code>32</code>是<code>1&lt;&lt;SYS_read</code>。在第二个示例中，<code>trace</code>在运行<code>grep</code>时跟踪所有系统调用；<code>2147483647</code>将所有31个低位置为1。在第三个示例中，程序没有被跟踪，因此没有打印跟踪输出。在第四个示例中，在<code>usertests</code>中测试的<code>forkforkfork</code>中所有子孙进程的<code>fork</code>系统调用都被追踪。如果程序的行为如上所示，则解决方案是正确的（尽管进程ID可能不同）</p><p><strong>提示：</strong></p><ul><li>在_<strong>Makefile</strong>_的<strong>UPROGS</strong>中添加<code>$U/_trace</code></li><li>运行<code>make qemu</code>，您将看到编译器无法编译_<strong>user&#x2F;trace.c</strong><em>，因为系统调用的用户空间存根还不存在：将系统调用的原型添加到</em><strong>user&#x2F;user.h</strong><em>，存根添加到</em><strong>user&#x2F;usys.pl</strong><em>，以及将系统调用编号添加到</em><strong>kernel&#x2F;syscall.h</strong><em>，</em><strong>Makefile</strong><em>调用perl脚本</em><strong>user&#x2F;usys.pl</strong><em>，它生成实际的系统调用存根</em><strong>user&#x2F;usys.S</strong>_，这个文件中的汇编代码使用RISC-V的<code>ecall</code>指令转换到内核。一旦修复了编译问题（_注：如果编译还未通过，尝试先<code>make clean</code>，再执行<code>make qemu</code>_），就运行<code>trace 32 grep hello README</code>；但由于您还没有在内核中实现系统调用，执行将失败。</li><li>在_<strong>kernel&#x2F;sysproc.c</strong><em>中添加一个<code>sys_trace()</code>函数，它通过将参数保存到<code>proc</code>结构体（请参见</em><strong>kernel&#x2F;proc.h</strong><em>）里的一个新变量中来实现新的系统调用。从用户空间检索系统调用参数的函数在</em><strong>kernel&#x2F;syscall.c</strong><em>中，您可以在</em><strong>kernel&#x2F;sysproc.c</strong>_中看到它们的使用示例。</li><li>修改<code>fork()</code>（请参阅_<strong>kernel&#x2F;proc.c</strong>_）将跟踪掩码从父进程复制到子进程。</li><li>修改_<strong>kernel&#x2F;syscall.c</strong>_中的<code>syscall()</code>函数以打印跟踪输出。您将需要添加一个系统调用名称数组以建立索引。</li></ul><h3 id="Sysinfo（moderate）"><a href="#Sysinfo（moderate）" class="headerlink" title="Sysinfo（moderate）"></a>Sysinfo（moderate）</h3><blockquote><p>[!TIP|label:YOUR JOB] 在这个作业中，您将添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针（参见_<strong>kernel&#x2F;sysinfo.h</strong>_）。内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。我们提供了一个测试程序<code>sysinfotest</code>；如果输出“<strong>sysinfotest: OK</strong>”则通过。</p></blockquote><p><strong>提示：</strong></p><ul><li>在_<strong>Makefile</strong>_的<strong>UPROGS</strong>中添加<code>$U/_sysinfotest</code></li><li>当运行<code>make qemu</code>时，_<strong>user&#x2F;sysinfotest.c</strong><em>将会编译失败，遵循和上一个作业一样的步骤添加<code>sysinfo</code>系统调用。要在</em><strong>user&#x2F;user.h</strong>_中声明<code>sysinfo()</code>的原型，需要预先声明<code>struct sysinfo</code>的存在：</li></ul><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>;</span><span class="hljs-type">int</span> <span class="hljs-title function_">sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo *)</span>;</code></pre><p>一旦修复了编译问题，就运行<code>sysinfotest</code>；但由于您还没有在内核中实现系统调用，执行将失败。</p><ul><li><code>sysinfo</code>需要将一个<code>struct sysinfo</code>复制回用户空间；请参阅<code>sys_fstat()</code>(<em><strong>kernel&#x2F;sysfile.c</strong></em>)和<code>filestat()</code>(<em><strong>kernel&#x2F;file.c</strong></em>)以获取如何使用<code>copyout()</code>执行此操作的示例。</li><li>要获取空闲内存量，请在_<strong>kernel&#x2F;kalloc.c</strong>_中添加一个函数</li><li>要获取进程数，请在_<strong>kernel&#x2F;proc.c</strong>_中添加一个函数</li></ul><h2 id="可选的挑战"><a href="#可选的挑战" class="headerlink" title="可选的挑战"></a>可选的挑战</h2><ul><li>打印所跟踪的系统调用的参数（easy）。</li><li>计算平均负载并通过<code>sysinfo</code>导出（moderate）。</li></ul><h1 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h1><p>在本实验室中，您将探索页表并对其进行修改，以简化将数据从用户空间复制到内核空间的函数。</p><blockquote><p>[!WARNING|label:Attention] 开始编码之前，请阅读xv6手册的第3章和相关文件：</p><ul><li>_<strong>kernel&#x2F;memlayout.h</strong>_，它捕获了内存的布局。</li><li>_<strong>kernel&#x2F;vm.c</strong>_，其中包含大多数虚拟内存（VM）代码。</li><li>_<strong>kernel&#x2F;kalloc.c</strong>_，它包含分配和释放物理内存的代码。</li></ul></blockquote><p>要启动实验，请切换到pgtbl分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout pgtbl</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h3 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h3><p>为了帮助您了解RISC-V页表，也许为了帮助将来的调试，您的第一个任务是编写一个打印页表内容的函数。</p><blockquote><p>[!TIP|label:YOUR JOB] 定义一个名为<code>vmprint()</code>的函数。它应当接收一个<code>pagetable_t</code>作为参数，并以下面描述的格式打印该页表。在<code>exec.c</code>中的<code>return argc</code>之前插入<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。如果你通过了<code>pte printout</code>测试的<code>make grade</code>，你将获得此作业的满分。</p></blockquote><p>现在，当您启动xv6时，它应该像这样打印输出来描述第一个进程刚刚完成<code>exec()</code>ing<code>init</code>时的页表：</p><pre><code class="hljs plaintext">page table 0x0000000087f6e000..0: pte 0x0000000021fda801 pa 0x0000000087f6a000.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</code></pre><p>第一行显示<code>vmprint</code>的参数。之后的每行对应一个PTE，包含树中指向页表页的PTE。每个PTE行都有一些“<code>..</code>”的缩进表明它在树中的深度。每个PTE行显示其在页表页中的PTE索引、PTE比特位以及从PTE提取的物理地址。不要打印无效的PTE。在上面的示例中，顶级页表页具有条目0和255的映射。条目0的下一级只映射了索引0，该索引0的下一级映射了条目0、1和2。</p><p>您的代码可能会发出与上面显示的不同的物理地址。条目数和虚拟地址应相同。</p><p><strong>一些提示：</strong></p><ul><li>你可以将<code>vmprint()</code>放在_<strong>kernel&#x2F;vm.c</strong>_中</li><li>使用定义在_<strong>kernel&#x2F;riscv.h</strong>_末尾处的宏</li><li>函数<code>freewalk</code>可能会对你有所启发</li><li>将<code>vmprint</code>的原型定义在_<strong>kernel&#x2F;defs.h</strong>_中，这样你就可以在<code>exec.c</code>中调用它了</li><li>在你的<code>printf</code>调用中使用<code>%p</code>来打印像上面示例中的完成的64比特的十六进制PTE和地址</li></ul><blockquote><p>[!NOTE|label:QUESTION] 根据文本中的图3-4解释<code>vmprint</code>的输出。page 0包含什么？page 2中是什么？在用户模式下运行时，进程是否可以读取&#x2F;写入page 1映射的内存？</p></blockquote><h3 id="A-kernel-page-table-per-process-hard"><a href="#A-kernel-page-table-per-process-hard" class="headerlink" title="A kernel page table per process (hard)"></a>A kernel page table per process (hard)</h3><p>Xv6有一个单独的用于在内核中执行程序时的内核页表。内核页表直接映射（恒等映射）到物理地址，也就是说内核虚拟地址<code>x</code>映射到物理地址仍然是<code>x</code>。Xv6还为每个进程的用户地址空间提供了一个单独的页表，只包含该进程用户内存的映射，从虚拟地址0开始。因为内核页表不包含这些映射，所以用户地址在内核中无效。因此，当内核需要使用在系统调用中传递的用户指针（例如，传递给<code>write()</code>的缓冲区指针）时，内核必须首先将指针转换为物理地址。本节和下一节的目标是允许内核直接解引用用户指针。</p><blockquote><p>[!TIP|label:YOUR JOB] 你的第一项工作是修改内核来让每一个进程在内核中执行时使用它自己的内核页表的副本。修改<code>struct proc</code>来为每一个进程维护一个内核页表，修改调度程序使得切换进程时也切换内核页表。对于这个步骤，每个进程的内核页表都应当与现有的的全局内核页表完全一致。如果你的<code>usertests</code>程序正确运行了，那么你就通过了这个实验。</p></blockquote><p>阅读本作业开头提到的章节和代码；了解虚拟内存代码的工作原理后，正确修改虚拟内存代码将更容易。页表设置中的错误可能会由于缺少映射而导致陷阱，可能会导致加载和存储影响到意料之外的物理页存页面，并且可能会导致执行来自错误内存页的指令。</p><p><strong>提示：</strong></p><ul><li>在<code>struct proc</code>中为进程的内核页表增加一个字段</li><li>为一个新进程生成一个内核页表的合理方案是实现一个修改版的<code>kvminit</code>，这个版本中应当创造一个新的页表而不是修改<code>kernel_pagetable</code>。你将会考虑在<code>allocproc</code>中调用这个函数</li><li>确保每一个进程的内核页表都关于该进程的内核栈有一个映射。在未修改的XV6中，所有的内核栈都在<code>procinit</code>中设置。你将要把这个功能部分或全部的迁移到<code>allocproc</code>中</li><li>修改<code>scheduler()</code>来加载进程的内核页表到核心的<code>satp</code>寄存器(参阅<code>kvminithart</code>来获取启发)。不要忘记在调用完<code>w_satp()</code>后调用<code>sfence_vma()</code></li><li>没有进程运行时<code>scheduler()</code>应当使用<code>kernel_pagetable</code></li><li>在<code>freeproc</code>中释放一个进程的内核页表</li><li>你需要一种方法来释放页表，而不必释放叶子物理内存页面。</li><li>调式页表时，也许<code>vmprint</code>能派上用场</li><li>修改XV6本来的函数或新增函数都是允许的；你或许至少需要在_<strong>kernel&#x2F;vm.c</strong><em>和</em><strong>kernel&#x2F;proc.c</strong><em>中这样做（但不要修改</em><strong>kernel&#x2F;vmcopyin.c</strong><em>, <em><strong>kernel&#x2F;stats.c</strong></em>, <em><strong>user&#x2F;usertests.c</strong></em>, 和</em><strong>user&#x2F;stats.c</strong>_）</li><li>页表映射丢失很可能导致内核遭遇页面错误。这将导致打印一段包含<code>sepc=0x00000000XXXXXXXX</code>的错误提示。你可以在_<strong>kernel&#x2F;kernel.asm</strong>_通过查询<code>XXXXXXXX</code>来定位错误。</li></ul><h3 id="Simplify-copyin-copyinstr（hard）"><a href="#Simplify-copyin-copyinstr（hard）" class="headerlink" title="Simplify copyin&#x2F;copyinstr（hard）"></a>Simplify <code>copyin</code>&#x2F;<code>copyinstr</code>（hard）</h3><p>内核的<code>copyin</code>函数读取用户指针指向的内存。它通过将用户指针转换为内核可以直接解引用的物理地址来实现这一点。这个转换是通过在软件中遍历进程页表来执行的。在本部分的实验中，您的工作是将用户空间的映射添加到每个进程的内核页表（上一节中创建），以允许<code>copyin</code>（和相关的字符串函数<code>copyinstr</code>）直接解引用用户指针。</p><blockquote><p>[!TIP|label:YOUR JOB] 将定义在_<strong>kernel&#x2F;vm.c</strong><em>中的<code>copyin</code>的主题内容替换为对<code>copyin_new</code>的调用（在</em><strong>kernel&#x2F;vmcopyin.c</strong>_中定义）；对<code>copyinstr</code>和<code>copyinstr_new</code>执行相同的操作。为每个进程的内核页表添加用户地址映射，以便<code>copyin_new</code>和<code>copyinstr_new</code>工作。如果<code>usertests</code>正确运行并且所有<code>make grade</code>测试都通过，那么你就完成了此项作业。</p></blockquote><p>此方案依赖于用户的虚拟地址范围不与内核用于自身指令和数据的虚拟地址范围重叠。Xv6使用从零开始的虚拟地址作为用户地址空间，幸运的是内核的内存从更高的地址开始。然而，这个方案将用户进程的最大大小限制为小于内核的最低虚拟地址。内核启动后，在XV6中该地址是<code>0xC000000</code>，即PLIC寄存器的地址；请参见_<strong>kernel&#x2F;vm.c</strong><em>中的<code>kvminit()</code>、</em><strong>kernel&#x2F;memlayout.h</strong>_和文中的图3-4。您需要修改xv6，以防止用户进程增长到超过PLIC的地址。</p><p><strong>一些提示：</strong></p><ul><li>先用对<code>copyin_new</code>的调用替换<code>copyin()</code>，确保正常工作后再去修改<code>copyinstr</code></li><li>在内核更改进程的用户映射的每一处，都以相同的方式更改进程的内核页表。包括<code>fork()</code>, <code>exec()</code>, 和<code>sbrk()</code>.</li><li>不要忘记在<code>userinit</code>的内核页表中包含第一个进程的用户页表</li><li>用户地址的PTE在进程的内核页表中需要什么权限？(在内核模式下，无法访问设置了<code>PTE_U</code>的页面）</li><li>别忘了上面提到的PLIC限制</li></ul><p>Linux使用的技术与您已经实现的技术类似。直到几年前，许多内核在用户和内核空间中都为当前进程使用相同的自身进程页表，并为用户和内核地址进行映射以避免在用户和内核空间之间切换时必须切换页表。然而，这种设置允许边信道攻击，如Meltdown和Spectre。</p><blockquote><p>[!NOTE|label:QUESTION] 解释为什么在<code>copyin_new()</code>中需要第三个测试<code>srcva + len &lt; srcva</code>：给出<code>srcva</code>和<code>len</code>值的例子，这样的值将使前两个测试为假（即它们不会导致返回-1），但是第三个测试为真 （导致返回-1）。</p></blockquote><h2 id="可选的挑战练习-1"><a href="#可选的挑战练习-1" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><ul><li>使用超级页来减少页表中PTE的数量</li><li>扩展您的解决方案以支持尽可能大的用户程序；也就是说，消除用户程序小于PLIC的限制</li><li>取消映射用户进程的第一页，以便使对空指针的解引用将导致错误。用户文本段必须从非0处开始，例如4096</li></ul><hr><h1 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h1><p>本实验探索如何使用陷阱实现系统调用。您将首先使用栈做一个热身练习，然后实现一个用户级陷阱处理的示例。</p><blockquote><p>[!WARNING|label:Attention] 开始编码之前，请阅读xv6手册的第4章和相关源文件：</p><ul><li>_<strong>kernel&#x2F;trampoline.S</strong>_：涉及从用户空间到内核空间再到内核空间的转换的程序集</li><li>_<strong>kernel&#x2F;trap.c</strong>_：处理所有中断的代码</li></ul></blockquote><p>要启动实验，请切换到<code>traps</code>分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout traps</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h3 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h3><p>理解一点RISC-V汇编是很重要的，你应该在6.004中接触过。xv6仓库中有一个文件_<strong>user&#x2F;call.c</strong><em>。执行<code>make fs.img</code>编译它，并在</em><strong>user&#x2F;call.asm</strong>_中生成可读的汇编版本。</p><p>阅读_<strong>call.asm</strong><em>中函数<code>g</code>、<code>f</code>和<code>main</code>的代码。RISC-V的使用手册在<a href="https://pdos.csail.mit.edu/6.828/2020/reference.html">参考页</a>上。以下是您应该回答的一些问题（将答案存储在</em><strong>answers-traps.txt</strong>_文件中）：</p><ol><li>哪些寄存器保存函数的参数？例如，在<code>main</code>对<code>printf</code>的调用中，哪个寄存器保存13？</li><li><code>main</code>的汇编代码中对函数<code>f</code>的调用在哪里？对<code>g</code>的调用在哪里(提示：编译器可能会将函数内联）</li><li><code>printf</code>函数位于哪个地址？</li><li>在<code>main</code>中<code>printf</code>的<code>jalr</code>之后的寄存器<code>ra</code>中有什么值？</li><li>运行以下代码。</li></ol><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);</code></pre><p>程序的输出是什么？这是将字节映射到字符的<a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">ASCII码表</a>。</p><p>输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把<code>i</code>设置成什么？是否需要将<code>57616</code>更改为其他值？</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">这里有一个小端和大端存储的描述</a>和一个<a href="http://www.networksorcery.com/enp/ien/ien137.txt">更异想天开的描述</a>。</p><ol start="6"><li>在下面的代码中，“<code>y=</code>”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？</li></ol><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);</code></pre><h3 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace(moderate)"></a>Backtrace(moderate)</h3><p>回溯(Backtrace)通常对于调试很有用：它是一个存放于栈上用于指示错误发生位置的函数调用列表。</p><p>在_<strong>kernel&#x2F;printf.c</strong>_中实现名为<code>backtrace()</code>的函数。在<code>sys_sleep</code>中插入一个对此函数的调用，然后运行<code>bttest</code>，它将会调用<code>sys_sleep</code>。你的输出应该如下所示：</p><pre><code class="hljs shell">backtrace:0x0000000080002cda0x0000000080002bb60x0000000080002898</code></pre><p>​ 在<code>bttest</code>退出qemu后。在你的终端：地址或许会稍有不同，但如果你运行<code>addr2line -e kernel/kernel</code>（或<code>riscv64-unknown-elf-addr2line -e kernel/kernel</code>），并将上面的地址剪切粘贴如下：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">addr2line -e kernel/kernel</span>0x0000000080002de20x0000000080002f4a0x0000000080002bfcCtrl-D</code></pre><p>​ 你应该看到类似下面的输出：</p><pre><code class="hljs plaintext">kernel/sysproc.c:74kernel/syscall.c:224kernel/trap.c:85</code></pre><p>​ 编译器向每一个栈帧中放置一个帧指针（frame pointer）保存调用者帧指针的地址。你的<code>backtrace</code>应当使用这些帧指针来遍历栈，并在每个栈帧中打印保存的返回地址。</p><p><strong>提示：</strong></p><ul><li><p>在_<strong>kernel&#x2F;defs.h</strong>_中添加<code>backtrace</code>的原型，那样你就能在<code>sys_sleep</code>中引用<code>backtrace</code></p></li><li><p>GCC编译器将当前正在执行的函数的帧指针保存在<code>s0</code>寄存器，将下面的函数添加到_<strong>kernel&#x2F;riscv.h</strong>_</p></li></ul><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> uint64<span class="hljs-title function_">r_fp</span><span class="hljs-params">()</span>&#123;  uint64 x;  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span>;  <span class="hljs-keyword">return</span> x;&#125;</code></pre><p>​ 并在<code>backtrace</code>中调用此函数来读取当前的帧指针。这个函数使用<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">内联汇编</a>来读取<code>s0</code></p><ul><li>这个<a href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">课堂笔记</a>中有张栈帧布局图。注意返回地址位于栈帧帧指针的固定偏移(-8)位置，并且保存的帧指针位于帧指针的固定偏移(-16)位置</li></ul><p><a href="https://github.com/duguosheng/6.S081-All-in-one/blob/main/labs/requirements/images/p2.png"><img src="https://github.com/duguosheng/6.S081-All-in-one/raw/main/labs/requirements/images/p2.png" alt="img"></a></p><ul><li>XV6在内核中以页面对齐的地址为每个栈分配一个页面。你可以通过<code>PGROUNDDOWN(fp)</code>和<code>PGROUNDUP(fp)</code>（参见_<strong>kernel&#x2F;riscv.h</strong>_）来计算栈页面的顶部和底部地址。这些数字对于<code>backtrace</code>终止循环是有帮助的。</li></ul><p>一旦你的<code>backtrace</code>能够运行，就在_<strong>kernel&#x2F;printf.c</strong>_的<code>panic</code>中调用它，那样你就可以在<code>panic</code>发生时看到内核的<code>backtrace</code>。</p><h3 id="Alarm-Hard"><a href="#Alarm-Hard" class="headerlink" title="Alarm(Hard)"></a>Alarm(Hard)</h3><blockquote><p>[!TIP|label:YOUR JOB] 在这个练习中你将向XV6添加一个特性，在进程使用CPU的时间内，XV6定期向进程发出警报。这对于那些希望限制CPU时间消耗的受计算限制的进程，或者对于那些计算的同时执行某些周期性操作的进程可能很有用。更普遍的来说，你将实现用户级中断&#x2F;故障处理程序的一种初级形式。例如，你可以在应用程序中使用类似的一些东西处理页面故障。如果你的解决方案通过了<code>alarmtest</code>和<code>usertests</code>就是正确的。</p></blockquote><p>你应当添加一个新的<code>sigalarm(interval, handler)</code>系统调用，如果一个程序调用了<code>sigalarm(n, fn)</code>，那么每当程序消耗了CPU时间达到n个“滴答”，内核应当使应用程序函数<code>fn</code>被调用。当<code>fn</code>返回时，应用应当在它离开的地方恢复执行。在XV6中，一个滴答是一段相当任意的时间单元，取决于硬件计时器生成中断的频率。如果一个程序调用了<code>sigalarm(0, 0)</code>，系统应当停止生成周期性的报警调用。</p><p>你将在XV6的存储库中找到名为_<strong>user&#x2F;alarmtest.c</strong><em>的文件。将其添加到</em><strong>Makefile</strong>_。注意：你必须添加了<code>sigalarm</code>和<code>sigreturn</code>系统调用后才能正确编译（往下看）。</p><p><code>alarmtest</code>在<code>test0</code>中调用了<code>sigalarm(2, periodic)</code>来要求内核每隔两个滴答强制调用<code>periodic()</code>，然后旋转一段时间。你可以在_<strong>user&#x2F;alarmtest.asm</strong>_中看到<code>alarmtest</code>的汇编代码，这或许会便于调试。当<code>alarmtest</code>产生如下输出并且<code>usertests</code>也能正常运行时，你的方案就是正确的：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">alarmtest</span>test0 start........alarm!test0 passedtest1 start...alarm!..alarm!...alarm!..alarm!...alarm!..alarm!...alarm!..alarm!...alarm!..alarm!test1 passedtest2 start................alarm!test2 passed<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>...ALL TESTS PASSED<span class="hljs-meta prompt_">$</span></code></pre><p>​当你完成后，你的方案也许仅有几行代码，但如何正确运行是一个棘手的问题。我们将使用原始存储库中的_<strong>alarmtest.c</strong><em>版本测试您的代码。你可以修改</em><strong>alarmtest.c</strong>_来帮助调试，但是要确保原来的<code>alarmtest</code>显示所有的测试都通过了。</p><h3 id="test0-invoke-handler-调用处理程序"><a href="#test0-invoke-handler-调用处理程序" class="headerlink" title="test0: invoke handler(调用处理程序)"></a>test0: invoke handler(调用处理程序)</h3><p>首先修改内核以跳转到用户空间中的报警处理程序，这将导致<code>test0</code>打印“alarm!”。不用担心输出“alarm!”之后会发生什么；如果您的程序在打印“alarm！”后崩溃，对于目前来说也是正常的。以下是一些<strong>提示</strong>：</p><ul><li><p>您需要修改_<strong>Makefile</strong><em>以使</em><strong>alarmtest.c</strong>_被编译为xv6用户程序。</p></li><li><p>放入_<strong>user&#x2F;user.h</strong>_的正确声明是：</p></li></ul><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> ticks, <span class="hljs-type">void</span> (*handler)())</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;</code></pre><ul><li><p>更新_<strong>user&#x2F;usys.pl</strong><em>（此文件生成</em><strong>user&#x2F;usys.S</strong><em>）、</em><strong>kernel&#x2F;syscall.h</strong><em>和</em><strong>kernel&#x2F;syscall.c</strong>_以允许<code>alarmtest</code>调用<code>sigalarm</code>和<code>sigreturn</code>系统调用。</p></li><li><p>目前来说，你的<code>sys_sigreturn</code>系统调用返回应该是零。</p></li><li><p>你的<code>sys_sigalarm()</code>应该将报警间隔和指向处理程序函数的指针存储在<code>struct proc</code>的新字段中（位于_<strong>kernel&#x2F;proc.h</strong>_）。</p></li><li><p>你也需要在<code>struct proc</code>新增一个新字段。用于跟踪自上一次调用（或直到下一次调用）到进程的报警处理程序间经历了多少滴答；您可以在_<strong>proc.c</strong>_的<code>allocproc()</code>中初始化<code>proc</code>字段。</p></li><li><p>每一个滴答声，硬件时钟就会强制一个中断，这个中断在_<strong>kernel&#x2F;trap.c</strong>_中的<code>usertrap()</code>中处理。</p></li><li><p>如果产生了计时器中断，您只想操纵进程的报警滴答；你需要写类似下面的代码</p></li></ul><pre><code class="hljs c"><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>) ...</code></pre><ul><li><p>仅当进程有未完成的计时器时才调用报警函数。请注意，用户报警函数的地址可能是0（例如，在_<strong>user&#x2F;alarmtest.asm</strong>_中，<code>periodic</code>位于地址0）。</p></li><li><p>您需要修改<code>usertrap()</code>，以便当进程的报警间隔期满时，用户进程执行处理程序函数。当RISC-V上的陷阱返回到用户空间时，什么决定了用户空间代码恢复执行的指令地址？</p></li><li><p>如果您告诉qemu只使用一个CPU，那么使用gdb查看陷阱会更容易，这可以通过运行</p></li></ul><pre><code class="hljs shell">make CPUS=1 qemu-gdb</code></pre><ul><li>如果<code>alarmtest</code>打印“alarm!”，则您已成功。</li></ul><h3 id="test1-test2-resume-interrupted-code-恢复被中断的代码"><a href="#test1-test2-resume-interrupted-code-恢复被中断的代码" class="headerlink" title="test1&#x2F;test2(): resume interrupted code(恢复被中断的代码)"></a>test1&#x2F;test2(): resume interrupted code(恢复被中断的代码)</h3><p><code>alarmtest</code>打印“alarm!”后，很可能会在<code>test0</code>或<code>test1</code>中崩溃，或者<code>alarmtest</code>（最后）打印“test1 failed”，或者<code>alarmtest</code>未打印“test1 passed”就退出。要解决此问题，必须确保完成报警处理程序后返回到用户程序最初被计时器中断的指令执行。必须确保寄存器内容恢复到中断时的值，以便用户程序在报警后可以不受干扰地继续运行。最后，您应该在每次报警计数器关闭后“重新配置”它，以便周期性地调用处理程序。</p><p>作为一个起始点，我们为您做了一个设计决策：用户报警处理程序需要在完成后调用<code>sigreturn</code>系统调用。请查看_<strong>alarmtest.c</strong>_中的<code>periodic</code>作为示例。这意味着您可以将代码添加到<code>usertrap</code>和<code>sys_sigreturn</code>中，这两个代码协同工作，以使用户进程在处理完警报后正确恢复。</p><p><strong>提示：</strong></p><ul><li><p>您的解决方案将要求您保存和恢复寄存器——您需要保存和恢复哪些寄存器才能正确恢复中断的代码？(提示：会有很多）</p></li><li><p>当计时器关闭时，让<code>usertrap</code>在<code>struct proc</code>中保存足够的状态，以使<code>sigreturn</code>可以正确返回中断的用户代码。</p></li><li><p>防止对处理程序的重复调用——如果处理程序还没有返回，内核就不应该再次调用它。<code>test2</code>测试这个。</p></li><li><p>一旦通过<code>test0</code>、<code>test1</code>和<code>test2</code>，就运行<code>usertests</code>以确保没有破坏内核的任何其他部分。</p></li></ul><h2 id="可选的挑战练习-2"><a href="#可选的挑战练习-2" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><ul><li>在<code>backtrace()</code>中打印函数的名称和行号，而不仅仅是数字化的地址。(hard)</li></ul><hr><h1 id="Lab5-xv6-lazy-page-allocation"><a href="#Lab5-xv6-lazy-page-allocation" class="headerlink" title="Lab5: xv6 lazy page allocation"></a>Lab5: xv6 lazy page allocation</h1><p>操作系统可以使用页表硬件的技巧之一是延迟分配用户空间堆内存（lazy allocation of user-space heap memory）。Xv6应用程序使用<code>sbrk()</code>系统调用向内核请求堆内存。在我们给出的内核中，<code>sbrk()</code>分配物理内存并将其映射到进程的虚拟地址空间。内核为一个大请求分配和映射内存可能需要很长时间。例如，考虑由262144个4096字节的页组成的千兆字节；即使单独一个页面的分配开销很低，但合起来如此大的分配数量将不可忽视。此外，有些程序申请分配的内存比实际使用的要多（例如，实现稀疏数组），或者为了以后的不时之需而分配内存。为了让<code>sbrk()</code>在这些情况下更快地完成，复杂的内核会延迟分配用户内存。也就是说，<code>sbrk()</code>不分配物理内存，只是记住分配了哪些用户地址，并在用户页表中将这些地址标记为无效。当进程第一次尝试使用延迟分配中给定的页面时，CPU生成一个页面错误（page fault），内核通过分配物理内存、置零并添加映射来处理该错误。您将在这个实验室中向xv6添加这个延迟分配特性。</p><blockquote><p>[!WARNING|label:Attention] 在开始编码之前，请阅读xv6手册的第4章（特别是4.6），以及可能要修改的相关文件：</p><ul><li><em><strong>kernel&#x2F;trap.c</strong></em></li><li><em><strong>kernel&#x2F;vm.c</strong></em></li><li><em><strong>kernel&#x2F;sysproc.c</strong></em></li></ul></blockquote><p>要启动实验，请切换到<code>lazy</code>分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout lazy</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h3 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (easy)</h3><blockquote><p>[!TIP|label:YOUR JOB] 你的首项任务是删除<code>sbrk(n)</code>系统调用中的页面分配代码（位于_<strong>sysproc.c</strong>_中的函数<code>sys_sbrk()</code>）。<code>sbrk(n)</code>系统调用将进程的内存大小增加n个字节，然后返回新分配区域的开始部分（即旧的大小）。新的<code>sbrk(n)</code>应该只将进程的大小（<code>myproc()-&gt;sz</code>）增加n，然后返回旧的大小。它不应该分配内存——因此您应该删除对<code>growproc()</code>的调用（但是您仍然需要增加进程的大小！）。</p></blockquote><p>试着猜猜这个修改的结果是什么：将会破坏什么？</p><p>进行此修改，启动xv6，并在shell中键入<code>echo hi</code>。你应该看到这样的输出：</p><pre><code class="hljs shell">init: starting sh<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hi</span>usertrap(): unexpected scause 0x000000000000000f pid=3            sepc=0x0000000000001258 stval=0x0000000000004008va=0x0000000000004000 pte=0x0000000000000000panic: uvmunmap: not mapped</code></pre><p>“<code>usertrap(): …</code>”这条消息来自_<strong>trap.c</strong>_中的用户陷阱处理程序；它捕获了一个不知道如何处理的异常。请确保您了解发生此页面错误的原因。“<code>stval=0x0..04008</code>”表示导致页面错误的虚拟地址是<code>0x4008</code>。</p><h3 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (moderate)</h3><blockquote><p>[!TIP|label:YOUR JOB] 修改_<strong>trap.c</strong>_中的代码以响应来自用户空间的页面错误，方法是新分配一个物理页面并映射到发生错误的地址，然后返回到用户空间，让进程继续执行。您应该在生成“<code>usertrap(): …</code>”消息的<code>printf</code>调用之前添加代码。你可以修改任何其他xv6内核代码，以使<code>echo hi</code>正常工作。</p></blockquote><p><strong>提示：</strong></p><ul><li>你可以在<code>usertrap()</code>中查看<code>r_scause()</code>的返回值是否为13或15来判断该错误是否为页面错误</li><li><code>stval</code>寄存器中保存了造成页面错误的虚拟地址，你可以通过<code>r_stval()</code>读取</li><li>参考_<strong>vm.c</strong>_中的<code>uvmalloc()</code>中的代码，那是一个<code>sbrk()</code>通过<code>growproc()</code>调用的函数。你将需要对<code>kalloc()</code>和<code>mappages()</code>进行调用</li><li>使用<code>PGROUNDDOWN(va)</code>将出错的虚拟地址向下舍入到页面边界</li><li>当前<code>uvmunmap()</code>会导致系统<code>panic</code>崩溃；请修改程序保证正常运行</li><li>如果内核崩溃，请在_<strong>kernel&#x2F;kernel.asm</strong>_中查看<code>sepc</code></li><li>使用pgtbl lab的<code>vmprint</code>函数打印页表的内容</li><li>如果您看到错误“incomplete type proc”，请include“spinlock.h”然后是“proc.h”。</li></ul><p>如果一切正常，你的lazy allocation应该使<code>echo hi</code>正常运行。您应该至少有一个页面错误（因为延迟分配），也许有两个。</p><h3 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (moderate)</h3><p>我们为您提供了<code>lazytests</code>，这是一个xv6用户程序，它测试一些可能会给您的惰性内存分配器带来压力的特定情况。修改内核代码，使所有<code>lazytests</code>和<code>usertests</code>都通过。</p><ul><li>处理<code>sbrk()</code>参数为负的情况。</li><li>如果某个进程在高于<code>sbrk()</code>分配的任何虚拟内存地址上出现页错误，则终止该进程。</li><li>在<code>fork()</code>中正确处理父到子内存拷贝。</li><li>处理这种情形：进程从<code>sbrk()</code>向系统调用（如<code>read</code>或<code>write</code>）传递有效地址，但尚未分配该地址的内存。</li><li>正确处理内存不足：如果在页面错误处理程序中执行<code>kalloc()</code>失败，则终止当前进程。</li><li>处理用户栈下面的无效页面上发生的错误。</li></ul><p>如果内核通过<code>lazytests</code>和<code>usertests</code>，那么您的解决方案是可以接受的：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lazytests</span>lazytests startingrunning test lazy alloctest lazy alloc: OKrunning test lazy unmap...usertrap(): ...test lazy unmap: OKrunning test out of memoryusertrap(): ...test out of memory: OKALL TESTS PASSED<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>...ALL TESTS PASSED<span class="hljs-meta prompt_">$</span></code></pre><h2 id="可选的挑战练习-3"><a href="#可选的挑战练习-3" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><ul><li>让延时分配协同上一个实验中简化版的<code>copyin</code>一起工作。</li></ul><hr><h1 id="Lab6-Copy-on-Write-Fork-for-xv6"><a href="#Lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab6: Copy-on-Write Fork for xv6"></a>Lab6: Copy-on-Write Fork for xv6</h1><p>虚拟内存提供了一定程度的间接寻址：内核可以通过将PTE标记为无效或只读来拦截内存引用，从而导致页面错误，还可以通过修改PTE来更改地址的含义。在计算机系统中有一种说法，任何系统问题都可以用某种程度的抽象方法来解决。Lazy allocation实验中提供了一个例子。这个实验探索了另一个例子：写时复制分支（copy-on write fork）。</p><p>在开始本实验前，将仓库切换到cow分支</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout cow</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><p><strong>问题</strong></p><p>xv6中的<code>fork()</code>系统调用将父进程的所有用户空间内存复制到子进程中。如果父进程较大，则复制可能需要很长时间。更糟糕的是，这项工作经常造成大量浪费；例如，子进程中的<code>fork()</code>后跟<code>exec()</code>将导致子进程丢弃复制的内存，而其中的大部分可能都从未使用过。另一方面，如果父子进程都使用一个页面，并且其中一个或两个对该页面有写操作，则确实需要复制。</p><p><strong>解决方案</strong></p><p>copy-on-write (COW) fork()的目标是推迟到子进程实际需要物理内存拷贝时再进行分配和复制物理内存页面。</p><p>COW fork()只为子进程创建一个页表，用户内存的PTE指向父进程的物理页。COW fork()将父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个COW页时，CPU将强制产生页面错误。内核页面错误处理程序检测到这种情况将为出错进程分配一页物理内存，将原始页复制到新页中，并修改出错进程中的相关PTE指向新的页面，将PTE标记为可写。当页面错误处理程序返回时，用户进程将能够写入其页面副本。</p><p>COW fork()将使得释放用户内存的物理页面变得更加棘手。给定的物理页可能会被多个进程的页表引用，并且只有在最后一个引用消失时才应该被释放。</p><h3 id="Implement-copy-on-write-hard"><a href="#Implement-copy-on-write-hard" class="headerlink" title="Implement copy-on write (hard)"></a>Implement copy-on write (hard)</h3><blockquote><p>[!TIP|label:YOUR JOB] 您的任务是在xv6内核中实现copy-on-write fork。如果修改后的内核同时成功执行<code>cowtest</code>和<code>usertests</code>程序就完成了。</p></blockquote><p>为了帮助测试你的实现方案，我们提供了一个名为<code>cowtest</code>的xv6程序（源代码位于_<strong>user&#x2F;cowtest.c</strong>_）。<code>cowtest</code>运行各种测试，但在未修改的xv6上，即使是第一个测试也会失败。因此，最初您将看到：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cowtest</span>simple: fork() failed<span class="hljs-meta prompt_">$ </span></code></pre><p>“simple”测试分配超过一半的可用物理内存，然后执行一系列的<code>fork()</code>。<code>fork</code>失败的原因是没有足够的可用物理内存来为子进程提供父进程内存的完整副本。</p><p>完成本实验后，内核应该通过<code>cowtest</code>和<code>usertests</code>中的所有测试。即：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cowtest</span>simple: oksimple: okthree: zombie!okthree: zombie!okthree: zombie!okfile: okALL COW TESTS PASSED<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>...ALL TESTS PASSED<span class="hljs-meta prompt_">$</span></code></pre><p><strong>这是一个合理的攻克计划：</strong></p><ol><li>修改<code>uvmcopy()</code>将父进程的物理页映射到子进程，而不是分配新页。在子进程和父进程的PTE中清除<code>PTE_W</code>标志。</li><li>修改<code>usertrap()</code>以识别页面错误。当COW页面出现页面错误时，使用<code>kalloc()</code>分配一个新页面，并将旧页面复制到新页面，然后将新页面添加到PTE中并设置<code>PTE_W</code>。</li><li>确保每个物理页在最后一个PTE对它的引用撤销时被释放——而不是在此之前。这样做的一个好方法是为每个物理页保留引用该页面的用户页表数的“引用计数”。当<code>kalloc()</code>分配页时，将页的引用计数设置为1。当<code>fork</code>导致子进程共享页面时，增加页的引用计数；每当任何进程从其页表中删除页面时，减少页的引用计数。<code>kfree()</code>只应在引用计数为零时将页面放回空闲列表。可以将这些计数保存在一个固定大小的整型数组中。你必须制定一个如何索引数组以及如何选择数组大小的方案。例如，您可以用页的物理地址除以4096对数组进行索引，并为数组提供等同于_<strong>kalloc.c</strong>_中<code>kinit()</code>在空闲列表中放置的所有页面的最高物理地址的元素数。</li><li>修改<code>copyout()</code>在遇到COW页面时使用与页面错误相同的方案。</li></ol><p><strong>提示：</strong></p><ul><li>lazy page allocation实验可能已经让您熟悉了许多与copy-on-write相关的xv6内核代码。但是，您不应该将这个实验室建立在您的lazy allocation解决方案的基础上；相反，请按照上面的说明从一个新的xv6开始。</li><li>有一种可能很有用的方法来记录每个PTE是否是COW映射。您可以使用RISC-V PTE中的RSW（reserved for software，即为软件保留的）位来实现此目的。</li><li><code>usertests</code>检查<code>cowtest</code>不测试的场景，所以别忘两个测试都需要完全通过。</li><li>_<strong>kernel&#x2F;riscv.h</strong>_的末尾有一些有用的宏和页表标志位的定义。</li><li>如果出现COW页面错误并且没有可用内存，则应终止进程。</li></ul><h2 id="可选的挑战练习-4"><a href="#可选的挑战练习-4" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><ul><li>修改xv6以同时支持lazy allocation和COW。</li><li>测量您的COW实现减少了多少xv6拷贝的字节数以及分配的物理页数。寻找并利用机会进一步减少这些数字。</li></ul><hr><h1 id="Lab7-Multithreading"><a href="#Lab7-Multithreading" class="headerlink" title="Lab7: Multithreading"></a>Lab7: Multithreading</h1><p>本实验将使您熟悉多线程。您将在用户级线程包中实现线程之间的切换，使用多个线程来加速程序，并实现一个屏障。</p><blockquote><p>[!WARNING|label:Attention] 在编写代码之前，您应该确保已经阅读了xv6手册中的“第7章: 调度”，并研究了相应的代码。</p></blockquote><p>要启动实验，请切换到thread分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout thread</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><p>在本练习中，您将为用户级线程系统设计上下文切换机制，然后实现它。为了让您开始，您的xv6有两个文件：_<strong>user&#x2F;uthread.c</strong><em>和</em><strong>user&#x2F;uthread_switch.S</strong><em>，以及一个规则：运行在</em><strong>Makefile</strong><em>中以构建<code>uthread</code>程序。</em><strong>uthread.c</strong>_包含大多数用户级线程包，以及三个简单测试线程的代码。线程包缺少一些用于创建线程和在线程之间切换的代码。</p><blockquote><p>[!TIP|label:YOUR JOB] 您的工作是提出一个创建线程和保存&#x2F;恢复寄存器以在线程之间切换的计划，并实现该计划。完成后，<code>make grade</code>应该表明您的解决方案通过了<code>uthread</code>测试。</p></blockquote><p>完成后，在xv6上运行<code>uthread</code>时应该会看到以下输出（三个线程可能以不同的顺序启动）：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span>...<span class="hljs-meta prompt_">$ </span><span class="language-bash">uthread</span>thread_a startedthread_b startedthread_c startedthread_c 0thread_a 0thread_b 0thread_c 1thread_a 1thread_b 1...thread_c 99thread_a 99thread_b 99thread_c: exit after 100thread_a: exit after 100thread_b: exit after 100thread_schedule: no runnable threads<span class="hljs-meta prompt_">$</span></code></pre><p>该输出来自三个测试线程，每个线程都有一个循环，该循环打印一行，然后将CPU让出给其他线程。</p><p>然而在此时还没有上下文切换的代码，您将看不到任何输出。</p><p>您需要将代码添加到_<strong>user&#x2F;uthread.c</strong><em>中的<code>thread_create()</code>和<code>thread_schedule()</code>，以及</em><strong>user&#x2F;uthread_switch.S</strong>_中的<code>thread_switch</code>。一个目标是确保当<code>thread_schedule()</code>第一次运行给定线程时，该线程在自己的栈上执行传递给<code>thread_create()</code>的函数。另一个目标是确保<code>thread_switch</code>保存被切换线程的寄存器，恢复切换到线程的寄存器，并返回到后一个线程指令中最后停止的点。您必须决定保存&#x2F;恢复寄存器的位置；修改<code>struct thread</code>以保存寄存器是一个很好的计划。您需要在<code>thread_schedule</code>中添加对<code>thread_switch</code>的调用；您可以将需要的任何参数传递给<code>thread_switch</code>，但目的是将线程从<code>t</code>切换到<code>next_thread</code>。</p><p><strong>提示：</strong></p><ul><li><code>thread_switch</code>只需要保存&#x2F;还原被调用方保存的寄存器（callee-save register，参见LEC5使用的文档《Calling Convention》）。为什么？</li><li>您可以在_<strong>user&#x2F;uthread.asm</strong>_中看到<code>uthread</code>的汇编代码，这对于调试可能很方便。</li><li>这可能对于测试你的代码很有用，使用<code>riscv64-linux-gnu-gdb</code>的单步调试通过你的<code>thread_switch</code>，你可以按这种方法开始：</li></ul><pre><code class="hljs shell">(gdb) file user/_uthreadReading symbols from user/_uthread...(gdb) b uthread.c:60</code></pre><p>这将在_<strong>uthread.c</strong>_的第60行设置断点。断点可能会（也可能不会）在运行<code>uthread</code>之前触发。为什么会出现这种情况？</p><p>一旦您的xv6 shell运行，键入“<code>uthread</code>”，gdb将在第60行停止。现在您可以键入如下命令来检查<code>uthread</code>的状态：</p><p><code>(gdb) p/x *next_thread</code></p><p>使用“<code>x</code>”，您可以检查内存位置的内容：</p><p><code>(gdb) x/x next_thread-&gt;stack</code></p><p>您可以跳到<code>thread_switch</code> 的开头，如下：</p><p><code>(gdb) b thread_switch</code></p><p><code>(gdb) c</code></p><p>您可以使用以下方法单步执行汇编指令：</p><p><code>(gdb) si</code></p><p>gdb的在线文档在<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">这里</a>。</p><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><p>在本作业中，您将探索使用哈希表的线程和锁的并行编程。您应该在具有多个内核的真实Linux或MacOS计算机（不是xv6，不是qemu）上执行此任务。最新的笔记本电脑都有多核处理器。</p><p>这个作业使用UNIX的pthread线程库。您可以使用<code>man pthreads</code>在手册页面上找到关于它的信息，您可以在web上查看，例如<a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_mutex_lock.html">这里</a>、<a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_mutex_init.html">这里</a>和<a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_create.html">这里</a>。</p><p>文件_<strong>notxv6&#x2F;ph.c</strong>_包含一个简单的哈希表，如果单个线程使用，该哈希表是正确的，但是多个线程使用时，该哈希表是不正确的。在您的xv6主目录（可能是<code>~/xv6-labs-2020</code>）中，键入以下内容：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make ph</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ph 1</span></code></pre><p>请注意，要构建<code>ph</code>，_<strong>Makefile</strong>_使用操作系统的gcc，而不是6.S081的工具。<code>ph</code>的参数指定在哈希表上执行<code>put</code>和<code>get</code>操作的线程数。运行一段时间后，<code>ph 1</code>将产生与以下类似的输出：</p><pre><code class="hljs plaintext">100000 puts, 3.991 seconds, 25056 puts/second0: 0 keys missing100000 gets, 3.981 seconds, 25118 gets/second</code></pre><p>您看到的数字可能与此示例输出的数字相差两倍或更多，这取决于您计算机的速度、是否有多个核心以及是否正在忙于做其他事情。</p><p><code>ph</code>运行两个基准程序。首先，它通过调用<code>put()</code>将许多键添加到哈希表中，并以每秒为单位打印puts的接收速率。之后它使用<code>get()</code>从哈希表中获取键。它打印由于puts而应该在哈希表中但丢失的键的数量（在本例中为0），并以每秒为单位打印gets的接收数量。</p><p>通过给<code>ph</code>一个大于1的参数，可以告诉它同时从多个线程使用其哈希表。试试<code>ph 2</code>：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ph 2</span>100000 puts, 1.885 seconds, 53044 puts/second1: 16579 keys missing0: 16579 keys missing200000 gets, 4.322 seconds, 46274 gets/second</code></pre><p>这个<code>ph 2</code>输出的第一行表明，当两个线程同时向哈希表添加条目时，它们达到每秒53044次插入的总速率。这大约是运行<code>ph 1</code>的单线程速度的两倍。这是一个优秀的“并行加速”，大约达到了人们希望的2倍（即两倍数量的核心每单位时间产出两倍的工作）。</p><p>然而，声明<code>16579 keys missing</code>的两行表示散列表中本应存在的大量键不存在。也就是说，puts应该将这些键添加到哈希表中，但出现了一些问题。请看一下_<strong>notxv6&#x2F;ph.c</strong>_，特别是<code>put()</code>和<code>insert()</code>。</p><blockquote><p>[!TIP|label:YOUR JOB] 为什么两个线程都丢失了键，而不是一个线程？确定可能导致键丢失的具有2个线程的事件序列。在_<strong>answers-thread.txt</strong>_中提交您的序列和简短解释。</p></blockquote><p>Tip</p><p>为了避免这种事件序列，请在_<strong>notxv6&#x2F;ph.c</strong>_中的<code>put</code>和<code>get</code>中插入<code>lock</code>和<code>unlock</code>语句，以便在两个线程中丢失的键数始终为0。相关的pthread调用包括：</p><ul><li><code>pthread_mutex_t lock; // declare a lock</code></li><li><code>pthread_mutex_init(&amp;lock, NULL); // initialize the lock</code></li><li><code>pthread_mutex_lock(&amp;lock); // acquire lock</code></li><li><code>pthread_mutex_unlock(&amp;lock); // release lock</code></li></ul><p>当<code>make grade</code>说您的代码通过<code>ph_safe</code>测试时，您就完成了，该测试需要两个线程的键缺失数为0。在此时，<code>ph_fast</code>测试失败是正常的。</p><p>不要忘记调用<code>pthread_mutex_init()</code>。首先用1个线程测试代码，然后用2个线程测试代码。您主要需要测试：程序运行是否正确呢（即，您是否消除了丢失的键？）？与单线程版本相比，双线程版本是否实现了并行加速（即单位时间内的工作量更多）？</p><p>在某些情况下，并发<code>put()</code>在哈希表中读取或写入的内存中没有重叠，因此不需要锁来相互保护。您能否更改_<strong>ph.c</strong>_以利用这种情况为某些<code>put()</code>获得并行加速？提示：每个散列桶加一个锁怎么样？</p><blockquote><p>[!TIP|label:YOUR JOB] 修改代码，使某些<code>put</code>操作在保持正确性的同时并行运行。当<code>make grade</code>说你的代码通过了<code>ph_safe</code>和<code>ph_fast</code>测试时，你就完成了。<code>ph_fast</code>测试要求两个线程每秒产生的<code>put</code>数至少是一个线程的1.25倍。</p></blockquote><h3 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h3><p>在本作业中，您将实现一个<a href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">屏障</a>（Barrier）：应用程序中的一个点，所有参与的线程在此点上必须等待，直到所有其他参与线程也达到该点。您将使用pthread条件变量，这是一种序列协调技术，类似于xv6的<code>sleep</code>和<code>wakeup</code>。</p><p>您应该在真正的计算机（不是xv6，不是qemu）上完成此任务。</p><p>文件_<strong>notxv6&#x2F;barrier.c</strong>_包含一个残缺的屏障实现。</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make barrier</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">./barrier 2</span>barrier: notxv6/barrier.c:42: thread: Assertion `i == t&#x27; failed.</code></pre><p>2指定在屏障上同步的线程数（_<strong>barrier.c</strong>_中的<code>nthread</code>）。每个线程执行一个循环。在每次循环迭代中，线程都会调用<code>barrier()</code>，然后以随机微秒数休眠。如果一个线程在另一个线程到达屏障之前离开屏障将触发断言（assert）。期望的行为是每个线程在<code>barrier()</code>中阻塞，直到<code>nthreads</code>的所有线程都调用了<code>barrier()</code>。</p><blockquote><p>[!TIP|label:YOUR JOB] 您的目标是实现期望的屏障行为。除了在<code>ph</code>作业中看到的lock原语外，还需要以下新的pthread原语；详情请看<a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">这里</a>和<a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">这里</a>。</p><ul><li><code>// 在cond上进入睡眠，释放锁mutex，在醒来时重新获取</code></li><li><code>pthread_cond_wait(&amp;cond, &amp;mutex);</code></li><li><code>// 唤醒睡在cond的所有线程</code></li><li><code>pthread_cond_broadcast(&amp;cond);</code></li></ul></blockquote><p>确保您的方案通过<code>make grade</code>的<code>barrier</code>测试。</p><p><code>pthread_cond_wait</code>在调用时释放<code>mutex</code>，并在返回前重新获取<code>mutex</code>。</p><p>我们已经为您提供了<code>barrier_init()</code>。您的工作是实现<code>barrier()</code>，这样panic就不会发生。我们为您定义了<code>struct barrier</code>；它的字段供您使用。</p><p><strong>有两个问题使您的任务变得复杂：</strong></p><ul><li>你必须处理一系列的<code>barrier</code>调用，我们称每一连串的调用为一轮（round）。<code>bstate.round</code>记录当前轮数。每次当所有线程都到达屏障时，都应增加<code>bstate.round</code>。</li><li>您必须处理这样的情况：一个线程在其他线程退出<code>barrier</code>之前进入了下一轮循环。特别是，您在前后两轮中重复使用<code>bstate.nthread</code>变量。确保在前一轮仍在使用<code>bstate.nthread</code>时，离开<code>barrier</code>并循环运行的线程不会增加<code>bstate.nthread</code>。</li></ul><p>使用一个、两个和两个以上的线程测试代码。</p><hr><h1 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h1><p>在本实验中，您将获得重新设计代码以提高并行性的经验。多核机器上并行性差的一个常见症状是频繁的锁争用。提高并行性通常涉及更改数据结构和锁定策略以减少争用。您将对xv6内存分配器和块缓存执行此操作。</p><blockquote><p>[!WARNING|label:Attention] 在编写代码之前，请确保阅读xv6手册中的以下部分：</p><ul><li>第6章：《锁》和相应的代码。</li><li>第3.5节：《代码：物理内存分配》</li><li>第8.1节至第8.3节：《概述》、《Buffer cache层》和《代码：Buffer cache》</li></ul></blockquote><p>要开始本实验，请将代码切换到<code>lock</code>分支</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout lock</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h3 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator(moderate)"></a>Memory allocator(moderate)</h3><p>程序_<strong>user&#x2F;kalloctest.c</strong>_强调了xv6的内存分配器：三个进程增长和缩小地址空间，导致对<code>kalloc</code>和<code>kfree</code>的多次调用。<code>kalloc</code>和<code>kfree</code>获得<code>kmem.lock</code>。<code>kalloctest</code>打印（作为“#fetch-and-add”）在<code>acquire</code>中由于尝试获取另一个内核已经持有的锁而进行的循环迭代次数，如<code>kmem</code>锁和一些其他锁。<code>acquire</code>中的循环迭代次数是锁争用的粗略度量。完成实验前，<code>kalloctest</code>的输出与此类似：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kalloctest</span>start test1test1 results:--- lock kmem/bcache statslock: kmem: #fetch-and-add 83375 #acquire() 433015lock: bcache: #fetch-and-add 0 #acquire() 1260--- top 5 contended locks:lock: kmem: #fetch-and-add 83375 #acquire() 433015lock: proc: #fetch-and-add 23737 #acquire() 130718lock: virtio_disk: #fetch-and-add 11159 #acquire() 114lock: proc: #fetch-and-add 5937 #acquire() 130786lock: proc: #fetch-and-add 4080 #acquire() 130786tot= 83375test1 FAIL</code></pre><p><code>acquire</code>为每个锁维护要获取该锁的<code>acquire</code>调用计数，以及<code>acquire</code>中循环尝试但未能设置锁的次数。<code>kalloctest</code>调用一个系统调用，使内核打印<code>kmem</code>和<code>bcache</code>锁（这是本实验的重点）以及5个最有具竞争的锁的计数。如果存在锁争用，则<code>acquire</code>循环迭代的次数将很大。系统调用返回<code>kmem</code>和<code>bcache</code>锁的循环迭代次数之和。</p><p>对于本实验，您必须使用具有多个内核的专用空载机器。如果你使用一台正在做其他事情的机器，<code>kalloctest</code>打印的计数将毫无意义。你可以使用专用的Athena 工作站或你自己的笔记本电脑，但不要使用拨号机。</p><p><code>kalloctest</code>中锁争用的根本原因是<code>kalloc()</code>有一个空闲列表，由一个锁保护。要消除锁争用，您必须重新设计内存分配器，以避免使用单个锁和列表。基本思想是为每个CPU维护一个空闲列表，每个列表都有自己的锁。因为每个CPU将在不同的列表上运行，不同CPU上的分配和释放可以并行运行。主要的挑战将是处理一个CPU的空闲列表为空，而另一个CPU的列表有空闲内存的情况；在这种情况下，一个CPU必须“窃取”另一个CPU空闲列表的一部分。窃取可能会引入锁争用，但这种情况希望不会经常发生。</p><blockquote><p>[!TIP|label:YOUR JOB] 您的工作是实现每个CPU的空闲列表，并在CPU的空闲列表为空时进行窃取。所有锁的命名必须以“<code>kmem</code>”开头。也就是说，您应该为每个锁调用<code>initlock</code>，并传递一个以“<code>kmem</code>”开头的名称。运行<code>kalloctest</code>以查看您的实现是否减少了锁争用。要检查它是否仍然可以分配所有内存，请运行<code>usertests sbrkmuch</code>。您的输出将与下面所示的类似，在<code>kmem</code>锁上的争用总数将大大减少，尽管具体的数字会有所不同。确保<code>usertests</code>中的所有测试都通过。评分应该表明考试通过。</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta prompt_"> $ </span><span class="language-bash">kalloctest</span>start test1test1 results:--- lock kmem/bcache statslock: kmem: #fetch-and-add 0 #acquire() 42843lock: kmem: #fetch-and-add 0 #acquire() 198674lock: kmem: #fetch-and-add 0 #acquire() 191534lock: bcache: #fetch-and-add 0 #acquire() 1242--- top 5 contended locks:lock: proc: #fetch-and-add 43861 #acquire() 117281lock: virtio_disk: #fetch-and-add 5347 #acquire() 114lock: proc: #fetch-and-add 4856 #acquire() 117312lock: proc: #fetch-and-add 4168 #acquire() 117316lock: proc: #fetch-and-add 2797 #acquire() 117266tot= 0test1 OKstart test2total free number of pages: 32499 (out of 32768).....test2 OK<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests sbrkmuch</span>usertests startingtest sbrkmuch: OKALL TESTS PASSED<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>...ALL TESTS PASSED<span class="hljs-meta prompt_">$ </span></code></pre><p><strong>提示：</strong></p><ul><li>您可以使用_<strong>kernel&#x2F;param.h</strong>_中的常量<code>NCPU</code></li><li>让<code>freerange</code>将所有可用内存分配给运行<code>freerange</code>的CPU。</li><li>函数<code>cpuid</code>返回当前的核心编号，但只有在中断关闭时调用它并使用其结果才是安全的。您应该使用<code>push_off()</code>和<code>pop_off()</code>来关闭和打开中断。</li><li>看看_<strong>kernel&#x2F;sprintf.c</strong>_中的<code>snprintf</code>函数，了解字符串如何进行格式化。尽管可以将所有锁命名为“<code>kmem</code>”。</li></ul><h3 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache(hard)"></a>Buffer cache(hard)</h3><p>这一半作业独立于前一半；不管你是否完成了前半部分，你都可以完成这半部分（并通过测试）。</p><p>如果多个进程密集地使用文件系统，它们可能会争夺<code>bcache.lock</code>，它保护_<strong>kernel&#x2F;bio.c</strong>_中的磁盘块缓存。<code>bcachetest</code>创建多个进程，这些进程重复读取不同的文件，以便在<code>bcache.lock</code>上生成争用；（在完成本实验之前）其输出如下所示：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bcachetest</span>start test0test0 results:--- lock kmem/bcache statslock: kmem: #fetch-and-add 0 #acquire() 33035lock: bcache: #fetch-and-add 16142 #acquire() 65978--- top 5 contended locks:lock: virtio_disk: #fetch-and-add 162870 #acquire() 1188lock: proc: #fetch-and-add 51936 #acquire() 73732lock: bcache: #fetch-and-add 16142 #acquire() 65978lock: uart: #fetch-and-add 7505 #acquire() 117lock: proc: #fetch-and-add 6937 #acquire() 73420tot= 16142test0: FAILstart test1test1 OK</code></pre><p>您可能会看到不同的输出，但<code>bcache</code>锁的<code>acquire</code>循环迭代次数将很高。如果查看_<strong>kernel&#x2F;bio.c</strong>_中的代码，您将看到<code>bcache.lock</code>保护已缓存的块缓冲区的列表、每个块缓冲区中的引用计数（<code>b-&gt;refcnt</code>）以及缓存块的标识（<code>b-&gt;dev</code>和<code>b-&gt;blockno</code>）。</p><blockquote><p>[!TIP|label:YOUR JOB] 修改块缓存，以便在运行<code>bcachetest</code>时，bcache（buffer cache的缩写）中所有锁的<code>acquire</code>循环迭代次数接近于零。理想情况下，块缓存中涉及的所有锁的计数总和应为零，但只要总和小于500就可以。修改<code>bget</code>和<code>brelse</code>，以便bcache中不同块的并发查找和释放不太可能在锁上发生冲突（例如，不必全部等待<code>bcache.lock</code>）。你必须保护每个块最多缓存一个副本的不变量。完成后，您的输出应该与下面显示的类似（尽管不完全相同）。确保<code>usertests</code>仍然通过。完成后，<code>make grade</code>应该通过所有测试。</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bcachetest</span>start test0test0 results:--- lock kmem/bcache statslock: kmem: #fetch-and-add 0 #acquire() 32954lock: kmem: #fetch-and-add 0 #acquire() 75lock: kmem: #fetch-and-add 0 #acquire() 73lock: bcache: #fetch-and-add 0 #acquire() 85lock: bcache.bucket: #fetch-and-add 0 #acquire() 4159lock: bcache.bucket: #fetch-and-add 0 #acquire() 2118lock: bcache.bucket: #fetch-and-add 0 #acquire() 4274lock: bcache.bucket: #fetch-and-add 0 #acquire() 4326lock: bcache.bucket: #fetch-and-add 0 #acquire() 6334lock: bcache.bucket: #fetch-and-add 0 #acquire() 6321lock: bcache.bucket: #fetch-and-add 0 #acquire() 6704lock: bcache.bucket: #fetch-and-add 0 #acquire() 6696lock: bcache.bucket: #fetch-and-add 0 #acquire() 7757lock: bcache.bucket: #fetch-and-add 0 #acquire() 6199lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136lock: bcache.bucket: #fetch-and-add 0 #acquire() 2123--- top 5 contended locks:lock: virtio_disk: #fetch-and-add 158235 #acquire() 1193lock: proc: #fetch-and-add 117563 #acquire() 3708493lock: proc: #fetch-and-add 65921 #acquire() 3710254lock: proc: #fetch-and-add 44090 #acquire() 3708607lock: proc: #fetch-and-add 43252 #acquire() 3708521tot= 128test0: OKstart test1test1 OK<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>  ...ALL TESTS PASSED<span class="hljs-meta prompt_">$</span></code></pre><p>请将你所有的锁以“<code>bcache</code>”开头进行命名。也就是说，您应该为每个锁调用<code>initlock</code>，并传递一个以“<code>bcache</code>”开头的名称。</p><p>减少块缓存中的争用比<code>kalloc</code>更复杂，因为bcache缓冲区真正的在进程（以及CPU）之间共享。对于<code>kalloc</code>，可以通过给每个CPU设置自己的分配器来消除大部分争用；这对块缓存不起作用。我们建议您使用每个哈希桶都有一个锁的哈希表在缓存中查找块号。</p><p>在您的解决方案中，以下是一些存在锁冲突但可以接受的情形：</p><ul><li>当两个进程同时使用相同的块号时。<code>bcachetest test0</code>始终不会这样做。</li><li>当两个进程同时在cache中未命中时，需要找到一个未使用的块进行替换。<code>bcachetest test0</code>始终不会这样做。</li><li>在你用来划分块和锁的方案中某些块可能会发生冲突，当两个进程同时使用冲突的块时。例如，如果两个进程使用的块，其块号散列到哈希表中相同的槽。<code>bcachetest test0</code>可能会执行此操作，具体取决于您的设计，但您应该尝试调整方案的细节以避免冲突（例如，更改哈希表的大小）。</li></ul><p><code>bcachetest</code>的<code>test1</code>使用的块比缓冲区更多，并且执行大量文件系统代码路径。</p><p><strong>提示：</strong></p><ul><li>请阅读xv6手册中对块缓存的描述（第8.1-8.3节）。</li><li>可以使用固定数量的散列桶，而不动态调整哈希表的大小。使用素数个存储桶（例如13）来降低散列冲突的可能性。</li><li>在哈希表中搜索缓冲区并在找不到缓冲区时为该缓冲区分配条目必须是原子的。</li><li>删除保存了所有缓冲区的列表（<code>bcache.head</code>等），改为标记上次使用时间的时间戳缓冲区（即使用_<strong>kernel&#x2F;trap.c</strong>_中的<code>ticks</code>）。通过此更改，<code>brelse</code>不需要获取bcache锁，并且<code>bget</code>可以根据时间戳选择最近使用最少的块。</li><li>可以在<code>bget</code>中串行化回收（即<code>bget</code>中的一部分：当缓存中的查找未命中时，它选择要复用的缓冲区）。</li><li>在某些情况下，您的解决方案可能需要持有两个锁；例如，在回收过程中，您可能需要持有bcache锁和每个bucket（散列桶）一个锁。确保避免死锁。</li><li>替换块时，您可能会将<code>struct buf</code>从一个bucket移动到另一个bucket，因为新块散列到不同的bucket。您可能会遇到一个棘手的情况：新块可能会散列到与旧块相同的bucket中。在这种情况下，请确保避免死锁。</li><li>一些调试技巧：实现bucket锁，但将全局<code>bcache.lock</code>的<code>acquire</code>&#x2F;<code>release</code>保留在<code>bget</code>的开头&#x2F;结尾，以串行化代码。一旦您确定它在没有竞争条件的情况下是正确的，请移除全局锁并处理并发性问题。您还可以运行<code>make CPUS=1 qemu</code>以使用一个内核进行测试。</li></ul><h2 id="可选的挑战练习-5"><a href="#可选的挑战练习-5" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><p>在buffer cache中进行无锁查找。提示：使用gcc的<code>__sync_*</code>函数。您如何证明自己的实现是正确的？</p><hr><h1 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h1><p>在本实验室中，您将向xv6文件系统添加大型文件和符号链接。</p><blockquote><p>[!WARNING|label:Attention] 在编写代码之前，您应该阅读《xv6手册》中的《第八章：文件系统》，并学习相应的代码。</p></blockquote><p>获取实验室的xv6源代码并切换到fs分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout fs</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h3 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files(moderate)"></a>Large files(moderate)</h3><p>在本作业中，您将增加xv6文件的最大大小。目前，xv6文件限制为268个块或<code>268*BSIZE</code>字节（在xv6中<code>BSIZE</code>为1024）。此限制来自以下事实：一个xv6 inode包含12个“直接”块号和一个“间接”块号，“一级间接”块指一个最多可容纳256个块号的块，总共12+256&#x3D;268个块。</p><p><code>bigfile</code>命令可以创建最长的文件，并报告其大小：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bigfile</span>..wrote 268 blocksbigfile: file is too small<span class="hljs-meta prompt_">$</span></code></pre><p>测试失败，因为<code>bigfile</code>希望能够创建一个包含65803个块的文件，但未修改的xv6将文件限制为268个块。</p><p>您将更改xv6文件系统代码，以支持每个inode中可包含256个一级间接块地址的“二级间接”块，每个一级间接块最多可以包含256个数据块地址。结果将是一个文件将能够包含多达65803个块，或256*256+256+11个块（11而不是12，因为我们将为二级间接块牺牲一个直接块号）。</p><h4 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h4><p><code>mkfs</code>程序创建xv6文件系统磁盘映像，并确定文件系统的总块数；此大小由_<strong>kernel&#x2F;param.h</strong>_中的<code>FSSIZE</code>控制。您将看到，该实验室存储库中的<code>FSSIZE</code>设置为200000个块。您应该在<code>make</code>输出中看到来自<code>mkfs/mkfs</code>的以下输出：</p><pre><code class="hljs plaintext">nmeta 70 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000</code></pre><p>这一行描述了<code>mkfs/mkfs</code>构建的文件系统：它有70个元数据块（用于描述文件系统的块）和199930个数据块，总计200000个块。</p><p>如果在实验期间的任何时候，您发现自己必须从头开始重建文件系统，您可以运行<code>make clean</code>，强制<code>make</code>重建_<strong>fs.img</strong>_。</p><h4 id="看什么"><a href="#看什么" class="headerlink" title="看什么"></a>看什么</h4><p>磁盘索引节点的格式由_<strong>fs.h</strong>_中的<code>struct dinode</code>定义。您应当尤其对<code>NDIRECT</code>、<code>NINDIRECT</code>、<code>MAXFILE</code>和<code>struct dinode</code>的<code>addrs[]</code>元素感兴趣。查看《XV6手册》中的图8.3，了解标准xv6索引结点的示意图。</p><p>在磁盘上查找文件数据的代码位于_<strong>fs.c</strong>_的<code>bmap()</code>中。看看它，确保你明白它在做什么。在读取和写入文件时都会调用<code>bmap()</code>。写入时，<code>bmap()</code>会根据需要分配新块以保存文件内容，如果需要，还会分配间接块以保存块地址。</p><p><code>bmap()</code>处理两种类型的块编号。<code>bn</code>参数是一个“逻辑块号”——文件中相对于文件开头的块号。<code>ip-&gt;addrs[]</code>中的块号和<code>bread()</code>的参数都是磁盘块号。您可以将<code>bmap()</code>视为将文件的逻辑块号映射到磁盘块号。</p><h4 id="你的工作"><a href="#你的工作" class="headerlink" title="你的工作"></a>你的工作</h4><p>修改<code>bmap()</code>，以便除了直接块和一级间接块之外，它还实现二级间接块。你只需要有11个直接块，而不是12个，为你的新的二级间接块腾出空间；不允许更改磁盘inode的大小。<code>ip-&gt;addrs[]</code>的前11个元素应该是直接块；第12个应该是一个一级间接块（与当前的一样）；13号应该是你的新二级间接块。当<code>bigfile</code>写入65803个块并成功运行<code>usertests</code>时，此练习完成：</p><pre><code class="hljs plaintext">$ bigfile..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................wrote 65803 blocksdone; ok$ usertests...ALL TESTS PASSED$</code></pre><p>运行<code>bigfile</code>至少需要一分钟半的时间。</p><p><strong>提示：</strong></p><ul><li>确保您理解<code>bmap()</code>。写出<code>ip-&gt;addrs[]</code>、间接块、二级间接块和它所指向的一级间接块以及数据块之间的关系图。确保您理解为什么添加二级间接块会将最大文件大小增加256*256个块（实际上要-1，因为您必须将直接块的数量减少一个）。</li><li>考虑如何使用逻辑块号索引二级间接块及其指向的间接块。</li><li>如果更改<code>NDIRECT</code>的定义，则可能必须更改_<strong>file.h</strong>_文件中<code>struct inode</code>中<code>addrs[]</code>的声明。确保<code>struct inode</code>和<code>struct dinode</code>在其<code>addrs[]</code>数组中具有相同数量的元素。</li><li>如果更改<code>NDIRECT</code>的定义，请确保创建一个新的_<strong>fs.img</strong>_，因为<code>mkfs</code>使用<code>NDIRECT</code>构建文件系统。</li><li>如果您的文件系统进入坏状态，可能是由于崩溃，请删除_<strong>fs.img</strong>_（从Unix而不是xv6执行此操作）。<code>make</code>将为您构建一个新的干净文件系统映像。</li><li>别忘了把你<code>bread()</code>的每一个块都<code>brelse()</code>。</li><li>您应该仅根据需要分配间接块和二级间接块，就像原始的<code>bmap()</code>。</li><li>确保<code>itrunc</code>释放文件的所有块，包括二级间接块。</li></ul><h3 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links(moderate)"></a>Symbolic links(moderate)</h3><p>在本练习中，您将向xv6添加符号链接。符号链接（或软链接）是指按路径名链接的文件；当一个符号链接打开时，内核跟随该链接指向引用的文件。符号链接类似于硬链接，但硬链接仅限于指向同一磁盘上的文件，而符号链接可以跨磁盘设备。尽管xv6不支持多个设备，但实现此系统调用是了解路径名查找工作原理的一个很好的练习。</p><h4 id="你的工作-1"><a href="#你的工作-1" class="headerlink" title="你的工作"></a>你的工作</h4><blockquote><p>[!TIP|label:YOUR JOB] 您将实现<code>symlink(char *target, char *path)</code>系统调用，该调用在引用由<code>target</code>命名的文件的路径处创建一个新的符号链接。有关更多信息，请参阅<code>symlink</code>手册页（注：执行<code>man symlink</code>）。要进行测试，请将<code>symlinktest</code>添加到_<strong>Makefile</strong>_并运行它。当测试产生以下输出（包括<code>usertests</code>运行成功）时，您就完成本作业了。</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">symlinktest</span>Start: test symlinkstest symlinks: okStart: test concurrent symlinkstest concurrent symlinks: ok<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>...ALL TESTS PASSED<span class="hljs-meta prompt_">$ </span></code></pre><p><strong>提示：</strong></p><ul><li>首先，为<code>symlink</code>创建一个新的系统调用号，在_<strong>user&#x2F;usys.pl</strong><em>、</em><strong>user&#x2F;user.h</strong><em>中添加一个条目，并在</em><strong>kernel&#x2F;sysfile.c</strong>_中实现一个空的<code>sys_symlink</code>。</li><li>向_<strong>kernel&#x2F;stat.h</strong>_添加新的文件类型（<code>T_SYMLINK</code>）以表示符号链接。</li><li>在k_<strong>ernel&#x2F;fcntl.h</strong><em>中添加一个新标志（<code>O_NOFOLLOW</code>），该标志可用于<code>open</code>系统调用。请注意，传递给<code>open</code>的标志使用按位或运算符组合，因此新标志不应与任何现有标志重叠。一旦将</em><strong>user&#x2F;symlinktest.c</strong><em>添加到</em><strong>Makefile</strong>_中，您就可以编译它。</li><li>实现<code>symlink(target, path)</code>系统调用，以在<code>path</code>处创建一个新的指向<code>target</code>的符号链接。请注意，系统调用的成功不需要<code>target</code>已经存在。您需要选择存储符号链接目标路径的位置，例如在inode的数据块中。<code>symlink</code>应返回一个表示成功（0）或失败（-1）的整数，类似于<code>link</code>和<code>unlink</code>。</li><li>修改<code>open</code>系统调用以处理路径指向符号链接的情况。如果文件不存在，则打开必须失败。当进程向<code>open</code>传递<code>O_NOFOLLOW</code>标志时，<code>open</code>应打开符号链接（而不是跟随符号链接）。</li><li>如果链接文件也是符号链接，则必须递归地跟随它，直到到达非链接文件为止。如果链接形成循环，则必须返回错误代码。你可以通过以下方式估算存在循环：通过在链接深度达到某个阈值（例如10）时返回错误代码。</li><li>其他系统调用（如<code>link</code>和<code>unlink</code>）不得跟随符号链接；这些系统调用对符号链接本身进行操作。</li><li>您不必处理指向此实验的目录的符号链接。</li></ul><h2 id="可选的挑战练习-6"><a href="#可选的挑战练习-6" class="headerlink" title="可选的挑战练习"></a>可选的挑战练习</h2><p>实现三级间接块</p><hr><h1 id="Lab10-mmap"><a href="#Lab10-mmap" class="headerlink" title="Lab10: mmap"></a>Lab10: mmap</h1><h3 id="mmap-hard"><a href="#mmap-hard" class="headerlink" title="mmap(hard)"></a>mmap(hard)</h3><p><code>mmap</code>和<code>munmap</code>系统调用允许UNIX程序对其地址空间进行详细控制。它们可用于在进程之间共享内存，将文件映射到进程地址空间，并作为用户级页面错误方案的一部分，如本课程中讨论的垃圾收集算法。在本实验室中，您将把<code>mmap</code>和<code>munmap</code>添加到xv6中，重点关注内存映射文件（memory-mapped files）。</p><p>获取实验室的xv6源代码并切换到<code>mmap</code>分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout mmap</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><p>手册页面（运行<code>man 2 mmap</code>）显示了<code>mmap</code>的以下声明：</p><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;</code></pre><p>可以通过多种方式调用<code>mmap</code>，但本实验只需要与内存映射文件相关的功能子集。您可以假设<code>addr</code>始终为零，这意味着内核应该决定映射文件的虚拟地址。<code>mmap</code>返回该地址，如果失败则返回<code>0xffffffffffffffff</code>。<code>length</code>是要映射的字节数；它可能与文件的长度不同。<code>prot</code>指示内存是否应映射为可读、可写，以及&#x2F;或者可执行的；您可以认为<code>prot</code>是<code>PROT_READ</code>或<code>PROT_WRITE</code>或两者兼有。<code>flags</code>要么是<code>MAP_SHARED</code>（映射内存的修改应写回文件），要么是<code>MAP_PRIVATE</code>（映射内存的修改不应写回文件）。您不必在<code>flags</code>中实现任何其他位。<code>fd</code>是要映射的文件的打开文件描述符。可以假定<code>offset</code>为零（它是要映射的文件的起点）。</p><p>允许进程映射同一个<code>MAP_SHARED</code>文件而不共享物理页面。</p><p><code>munmap(addr, length)</code>应删除指定地址范围内的<code>mmap</code>映射。如果进程修改了内存并将其映射为<code>MAP_SHARED</code>，则应首先将修改写入文件。<code>munmap</code>调用可能只覆盖<code>mmap</code>区域的一部分，但您可以认为它取消映射的位置要么在区域起始位置，要么在区域结束位置，要么就是整个区域(但不会在区域中间“打洞”)。</p><blockquote><p>[!TIP|label:YOUR JOB] 您应该实现足够的<code>mmap</code>和<code>munmap</code>功能，以使<code>mmaptest</code>测试程序正常工作。如果<code>mmaptest</code>不会用到某个<code>mmap</code>的特性，则不需要实现该特性。</p></blockquote><p>完成后，您应该会看到以下输出：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mmaptest</span>mmap_test startingtest mmap ftest mmap f: OKtest mmap privatetest mmap private: OKtest mmap read-onlytest mmap read-only: OKtest mmap read/writetest mmap read/write: OKtest mmap dirtytest mmap dirty: OKtest not-mapped unmaptest not-mapped unmap: OKtest mmap two filestest mmap two files: OKmmap_test: ALL OKfork_test startingfork_test OKmmaptest: all tests succeeded<span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span>usertests starting...ALL TESTS PASSED<span class="hljs-meta prompt_">$ </span></code></pre><p><strong>提示：</strong></p><ul><li>首先，向<code>UPROGS</code>添加<code>_mmaptest</code>，以及<code>mmap</code>和<code>munmap</code>系统调用，以便让_<strong>user&#x2F;mmaptest.c</strong><em>进行编译。现在，只需从<code>mmap</code>和<code>munmap</code>返回错误。我们在</em><strong>kernel&#x2F;fcntl.h</strong>_中为您定义了<code>PROT_READ</code>等。运行<code>mmaptest</code>，它将在第一次<code>mmap</code>调用时失败。</li><li>惰性地填写页表，以响应页错误。也就是说，<code>mmap</code>不应该分配物理内存或读取文件。相反，在<code>usertrap</code>中（或由<code>usertrap</code>调用）的页面错误处理代码中执行此操作，就像在lazy page allocation实验中一样。惰性分配的原因是确保大文件的<code>mmap</code>是快速的，并且比物理内存大的文件的<code>mmap</code>是可能的。</li><li>跟踪<code>mmap</code>为每个进程映射的内容。定义与第15课中描述的VMA（虚拟内存区域）对应的结构体，记录<code>mmap</code>创建的虚拟内存范围的地址、长度、权限、文件等。由于xv6内核中没有内存分配器，因此可以声明一个固定大小的VMA数组，并根据需要从该数组进行分配。大小为16应该就足够了。</li><li>实现<code>mmap</code>：在进程的地址空间中找到一个未使用的区域来映射文件，并将VMA添加到进程的映射区域表中。VMA应该包含指向映射文件对应<code>struct file</code>的指针；<code>mmap</code>应该增加文件的引用计数，以便在文件关闭时结构体不会消失（提示：请参阅<code>filedup</code>）。运行<code>mmaptest</code>：第一次<code>mmap</code>应该成功，但是第一次访问被<code>mmap</code>的内存将导致页面错误并终止<code>mmaptest</code>。</li><li>添加代码以导致在<code>mmap</code>的区域中产生页面错误，从而分配一页物理内存，将4096字节的相关文件读入该页面，并将其映射到用户地址空间。使用<code>readi</code>读取文件，它接受一个偏移量参数，在该偏移处读取文件（但必须lock&#x2F;unlock传递给<code>readi</code>的索引结点）。不要忘记在页面上正确设置权限。运行<code>mmaptest</code>；它应该到达第一个<code>munmap</code>。</li><li>实现<code>munmap</code>：找到地址范围的VMA并取消映射指定页面（提示：使用<code>uvmunmap</code>）。如果<code>munmap</code>删除了先前<code>mmap</code>的所有页面，它应该减少相应<code>struct file</code>的引用计数。如果未映射的页面已被修改，并且文件已映射到<code>MAP_SHARED</code>，请将页面写回该文件。查看<code>filewrite</code>以获得灵感。</li><li>理想情况下，您的实现将只写回程序实际修改的<code>MAP_SHARED</code>页面。RISC-V PTE中的脏位（<code>D</code>）表示是否已写入页面。但是，<code>mmaptest</code>不检查非脏页是否没有回写；因此，您可以不用看<code>D</code>位就写回页面。</li><li>修改<code>exit</code>将进程的已映射区域取消映射，就像调用了<code>munmap</code>一样。运行<code>mmaptest</code>；<code>mmap_test</code>应该通过，但可能不会通过<code>fork_test</code>。</li><li>修改<code>fork</code>以确保子对象具有与父对象相同的映射区域。不要忘记增加VMA的<code>struct file</code>的引用计数。在子进程的页面错误处理程序中，可以分配新的物理页面，而不是与父级共享页面。后者会更酷，但需要更多的实施工作。运行<code>mmaptest</code>；它应该通过<code>mmap_test</code>和<code>fork_test</code>。</li></ul><p>运行<code>usertests</code>以确保一切正常。</p><hr><h1 id="Lab11-Network"><a href="#Lab11-Network" class="headerlink" title="Lab11: Network"></a>Lab11: Network</h1><p>在本实验室中，您将为网络接口卡（NIC）编写一个xv6设备驱动程序。</p><p>获取xv6实验的源代码并切换到<code>net</code>分支：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout net</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">make clean</span></code></pre><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Tip</p><p>在编写代码之前，您可能会发现阅读xv6手册中的《第5章：中断和设备驱动》很有帮助。</p><p>您将使用名为E1000的网络设备来处理网络通信。对于xv6（以及您编写的驱动程序），E1000看起来像是连接到真正以太网局域网（LAN）的真正硬件。事实上，用于与您的驱动程序对话的E1000是qemu提供的模拟，连接到的LAN也由qemu模拟。在这个模拟LAN上，xv6（“来宾”）的IP地址为10.0.2.15。Qemu还安排运行Qemu的计算机出现在IP地址为10.0.2.2的LAN上。当xv6使用E1000将数据包发送到10.0.2.2时，qemu会将数据包发送到运行qemu的（真实）计算机上的相应应用程序（“主机”）。</p><p>您将使用QEMU的“用户模式网络栈（user-mode network stack）”。<a href="https://www.qemu.org/docs/master/system/net.html#using-the-user-mode-network-stack">QEMU的文档</a>中有更多关于用户模式栈的内容。我们已经更新了_<strong>Makefile</strong>_以启用QEMU的用户模式网络栈和E1000网卡。</p><p>_<strong>Makefile</strong><em>将QEMU配置为将所有传入和传出数据包记录到实验目录中的</em><strong>packets.pcap</strong>_文件中。查看这些记录可能有助于确认xv6正在发送和接收您期望的数据包。要显示记录的数据包，请执行以下操作：</p><pre><code class="hljs plaintext">tcpdump -XXnr packets.pcap</code></pre><p>我们已将一些文件添加到本实验的xv6存储库中。_<strong>kernel&#x2F;e1000.c</strong><em>文件包含E1000的初始化代码以及用于发送和接收数据包的空函数，您将填写这些函数。</em><strong>kernel&#x2F;e1000_dev.h</strong><em>包含E1000定义的寄存器和标志位的定义，并在<a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">《英特尔E1000软件开发人员手册》</a>中进行了描述。</em><strong>kernel&#x2F;net.c</strong><em>和</em><strong>kernel&#x2F;net.h</strong><em>包含一个实现IP、UDP和ARP协议的简单网络栈。这些文件还包含用于保存数据包的灵活数据结构（称为<code>mbuf</code>）的代码。最后，</em><strong>kernel&#x2F;pci.c</strong>_包含在xv6引导时在PCI总线上搜索E1000卡的代码。</p><h4 id="你的工作-hard"><a href="#你的工作-hard" class="headerlink" title="你的工作(hard)"></a>你的工作(hard)</h4><blockquote><p>[!TIP|label:YOUR JOB] 您的工作是在_<strong>kernel&#x2F;e1000.c</strong>_中完成<code>e1000_transmit()</code>和<code>e1000_recv()</code>，以便驱动程序可以发送和接收数据包。当<code>make grade</code>表示您的解决方案通过了所有测试时，您就完成了。</p></blockquote><p>Tip</p><p>在编写代码时，您会发现自己参考了<a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">《E1000软件开发人员手册》</a>。以下部分可能特别有用：</p><ul><li>Section 2是必不可少的，它概述了整个设备。</li><li>Section 3.2概述了数据包接收。</li><li>Section 3.3与Section 3.4一起概述了数据包传输。</li><li>Section 13概述了E1000使用的寄存器。</li><li>Section 14可能会帮助您理解我们提供的init代码。</li></ul><p>浏览<a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">《E1000软件开发人员手册》</a>。本手册涵盖了几个密切相关的以太网控制器。QEMU模拟82540EM。现在浏览第2章，了解该设备。要编写驱动程序，您需要熟悉第3章和第14章以及第4.1节（虽然不包括4.1的子节）。你还需要参考第13章。其他章节主要介绍你的驱动程序不必与之交互的E1000组件。一开始不要担心细节；只需了解文档的结构，就可以在以后找到内容。E1000具有许多高级功能，其中大部分您可以忽略。完成这个实验只需要一小部分基本功能。</p><p>我们在_<strong>e1000.c</strong>_中提供的<code>e1000_init()</code>函数将E1000配置为读取要从RAM传输的数据包，并将接收到的数据包写入RAM。这种技术称为DMA，用于直接内存访问，指的是E1000硬件直接向RAM写入和读取数据包。</p><p>由于数据包突发到达的速度可能快于驱动程序处理数据包的速度，因此<code>e1000_init()</code>为E1000提供了多个缓冲区，E1000可以将数据包写入其中。E1000要求这些缓冲区由RAM中的“描述符”数组描述；每个描述符在RAM中都包含一个地址，E1000可以在其中写入接收到的数据包。<code>struct rx_desc</code>描述描述符格式。描述符数组称为接收环或接收队列。它是一个圆环，在这个意义上，当网卡或驱动程序到达队列的末尾时，它会绕回到数组的开头。<code>e1000_init()</code>使用<code>mbufalloc()</code>为要进行DMA的E1000分配<code>mbuf</code>数据包缓冲区。此外还有一个传输环，驱动程序将需要E1000发送的数据包放入其中。<code>e1000_init()</code>将两个环的大小配置为<code>RX_RING_SIZE</code>和<code>TX_RING_SIZE</code>。</p><p>当_<strong>net.c</strong>_中的网络栈需要发送数据包时，它会调用<code>e1000_transmit()</code>，并使用一个保存要发送的数据包的<code>mbuf</code>作为参数。传输代码必须在TX（传输）环的描述符中放置指向数据包数据的指针。<code>struct tx_desc</code>描述了描述符的格式。您需要确保每个<code>mbuf</code>最终被释放，但只能在E1000完成数据包传输之后（E1000在描述符中设置<code>E1000_TXD_STAT_DD</code>位以指示此情况）。</p><p>当当E1000从以太网接收到每个包时，它首先将包DMA到下一个RX(接收)环描述符指向的<code>mbuf</code>，然后产生一个中断。<code>e1000_recv()</code>代码必须扫描RX环，并通过调用<code>net_rx()</code>将每个新数据包的<code>mbuf</code>发送到网络栈（在_<strong>net.c</strong>_中）。然后，您需要分配一个新的<code>mbuf</code>并将其放入描述符中，以便当E1000再次到达RX环中的该点时，它会找到一个新的缓冲区，以便DMA新数据包。</p><p>除了在RAM中读取和写入描述符环外，您的驱动程序还需要通过其内存映射控制寄存器与E1000交互，以检测接收到数据包何时可用，并通知E1000驱动程序已经用要发送的数据包填充了一些TX描述符。全局变量<code>regs</code>包含指向E1000第一个控制寄存器的指针；您的驱动程序可以通过将<code>regs</code>索引为数组来获取其他寄存器。您需要特别使用索引<code>E1000_RDT</code>和<code>E1000_TDT</code>。</p><p>要测试驱动程序，请在一个窗口中运行<code>make server</code>，在另一个窗口中运行<code>make qemu</code>，然后在xv6中运行<code>nettests</code>。<code>nettests</code>中的第一个测试尝试将UDP数据包发送到主机操作系统，地址是<code>make server</code>运行的程序。如果您还没有完成实验，E1000驱动程序实际上不会发送数据包，也不会发生什么事情。</p><p>完成实验后，E1000驱动程序将发送数据包，qemu将其发送到主机，<code>make server</code>将看到它并发送响应数据包，然后E1000驱动程序和<code>nettests</code>将看到响应数据包。但是，在主机发送应答之前，它会向xv6发送一个“ARP”请求包，以找出其48位以太网地址，并期望xv6以ARP应答进行响应。一旦您完成了对E1000驱动程序的工作，_<strong>kernel&#x2F;net.c</strong>_就会处理这个问题。如果一切顺利，<code>nettests</code>将打印<code>testing ping: OK</code>，<code>make server</code>将打印<code>a message from xv6!</code>。</p><p><code>tcpdump -XXnr packets.pcap</code>应该生成这样的输出:</p><pre><code class="hljs plaintext">reading from file packets.pcap, link-type EN10MB (Ethernet)15:27:40.861988 IP 10.0.2.15.2000 &gt; 10.0.2.2.25603: UDP, length 19        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.&gt;.......        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........        0x0020:  0000 0000 0000 0a00 020f                 ..........15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....        0x0020:  5255 0a00 0202 0a00 0202                 RU........15:27:40.863036 IP 10.0.2.2.25603 &gt; 10.0.2.15.2000: UDP, length 17        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!</code></pre><p>您的输出看起来会有些不同，但它应该包含字符串“ARP, Request”，“ARP, Reply”，“UDP”，“a.message.from.xv6”和“this.is.the.host”。</p><p><code>nettests</code>执行一些其他测试，最终通过（真实的）互联网将DNS请求发送到谷歌的一个名称服务器。您应该确保您的代码通过所有这些测试，然后您应该看到以下输出：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nettests</span>nettests running on port 25603testing ping: OKtesting single-process pings: OKtesting multi-process pings: OKtesting DNSDNS arecord for pdos.csail.mit.edu. is 128.52.129.126DNS OKall tests passed.</code></pre><p>您应该确保<code>make grade</code>同意您的解决方案通过。</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>首先，将打印语句添加到<code>e1000_transmit()</code>和<code>e1000_recv()</code>，然后运行<code>make server</code>和（在xv6中）<code>nettests</code>。您应该从打印语句中看到，<code>nettests</code>生成对<code>e1000_transmit</code>的调用。</p><p><strong>实现<code>e1000_transmit</code>的一些提示：</strong></p><ul><li>首先，通过读取<code>E1000_TDT</code>控制寄存器，向E1000询问等待下一个数据包的TX环索引。</li><li>然后检查环是否溢出。如果<code>E1000_TXD_STAT_DD</code>未在<code>E1000_TDT</code>索引的描述符中设置，则E1000尚未完成先前相应的传输请求，因此返回错误。</li><li>否则，使用<code>mbuffree()</code>释放从该描述符传输的最后一个<code>mbuf</code>（如果有）。</li><li>然后填写描述符。<code>m-&gt;head</code>指向内存中数据包的内容，<code>m-&gt;len</code>是数据包的长度。设置必要的cmd标志（请参阅E1000手册的第3.3节），并保存指向<code>mbuf</code>的指针，以便稍后释放。</li><li>最后，通过将一加到<code>E1000_TDT再对TX_RING_SIZE</code>取模来更新环位置。</li><li>如果<code>e1000_transmit()</code>成功地将<code>mbuf</code>添加到环中，则返回0。如果失败（例如，没有可用的描述符来传输<code>mbuf</code>），则返回-1，以便调用方知道应该释放<code>mbuf</code>。</li></ul><p><strong>实现<code>e1000_recv</code>的一些提示：</strong></p><ul><li>首先通过提取<code>E1000_RDT</code>控制寄存器并加一对<code>RX_RING_SIZE</code>取模，向E1000询问下一个等待接收数据包（如果有）所在的环索引。</li><li>然后通过检查描述符<code>status</code>部分中的<code>E1000_RXD_STAT_DD</code>位来检查新数据包是否可用。如果不可用，请停止。</li><li>否则，将<code>mbuf</code>的<code>m-&gt;len</code>更新为描述符中报告的长度。使用<code>net_rx()</code>将<code>mbuf</code>传送到网络栈。</li><li>然后使用<code>mbufalloc()</code>分配一个新的<code>mbuf</code>，以替换刚刚给<code>net_rx()</code>的<code>mbuf</code>。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清除为零。</li><li>最后，将<code>E1000_RDT</code>寄存器更新为最后处理的环描述符的索引。</li><li><code>e1000_init()</code>使用mbufs初始化RX环，您需要通过浏览代码来了解它是如何做到这一点的。</li><li>在某刻，曾经到达的数据包总数将超过环大小（16）；确保你的代码可以处理这个问题。</li></ul><p>您将需要锁来应对xv6可能从多个进程使用E1000，或者在中断到达时在内核线程中使用E1000的可能性。</p><hr><h1 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h1><h2 id="实验难度"><a href="#实验难度" class="headerlink" title="实验难度"></a>实验难度</h2><p>每个实验都具有相应的难度</p><ul><li><p>Easy：不到一个小时。这些锻炼通常是为后续锻炼做的热身运动。</p></li><li><p>Moderate：1-2小时。</p></li><li><p>Hard：超过2个小时。这些练习通常不需要很多代码，但是代码很难正确。</p></li></ul><p>实验往往不需要很多行代码(几十到几百行) ，但是代码在概念上很复杂，而且细节往往很重要。所以，在你写任何代码之前，一定要完成实验室指定的阅读，通读相关文件，查阅文档(RISC-V手册等存放在了<a href="https://pdos.csail.mit.edu/6.828/2020/reference.html">参考页面</a>上)。只有当你确定掌握了任务和解决方案，再开始编码。当你开始编写代码的时候，一小步一小步地实现你的解决方案(作业通常会建议如何将问题分解为更小的步骤)，并且在继续下一个步骤之前测试每个步骤是否正常工作。</p><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>确保你理解了c和指针。Kernighan和Ritchie的《c程序设计语言》一书对C语言进行了简要的描述。这里有一些有用的指针练习。除非你已经完全掌握了C语言，不要跳过或略读上面的指针练习。如果你不能真正理解C语言中的指针，你将在实验室中遭受难以言喻的痛苦，然后最终以一种艰难的方式来理解它们。相信我们，你不会想知道什么是“艰难的路”的。</p><p>一些常见的习惯用法特别值得记住:</p><ul><li><p>如果<code>int *p = (int*)100</code>，那么<code>(int)p + 1</code>及<code>(int)(p + 1)</code>是不同的数字，第一个是101，但第二个是104。当向指针添加一个整数时，如第二种情况，整数被隐式地乘以指针指向的对象的大小。</p></li><li><p><code>p[i]</code>被定义为与<code>*(p+i)</code>相同，指向内存中p指向的第i个对象，当对象大于1字节时，上面所说的加法规则有利于此定义工作</p></li></ul><p>虽然大多数C程序不需要在指针和整数之间进行强制转换，但操作系统经常需要这样做。每当您看到一个包含内存地址的加法时，问问自己它是整数加法还是指针加法，并确保所添加的值是否适当地相乘。</p><ul><li><p>如果你有一个部分工作的练习，请通过提交代码来检查你的进度。如果您稍后破坏了某些东西，那么您可以回滚到您的检查点，然后以较小的步骤继续前进。要了解关于Git的更多信息，请查看<a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git用户手册</a>，或者您可能会发现这个<a href="http://eagain.net/articles/git-for-computer-scientists/">面向计算机科学家的Git概述</a>非常有用。</p></li><li><p>如果您没有通过测试，确保您了解为什么您的代码没有通过测试。插入打印(printf)语句，直到您理解正在发生的事情。</p></li><li><p>您可能会发现您的print语句可能会产生许多您想要搜索的输出；其中一种方法是在<code>script</code>内部运行<code>make qemu</code>（在您的机器上运行<code>man script</code>），它将所有控制台输出记录到一个文件中，然后您可以搜索该文件。别忘了退出<code>script</code>。</p></li><li><p>在许多情况下，print语句就足够了，但有时能够单步遍历一些汇编代码或检查堆栈上的变量是有帮助的。要在xv6中使用gdb，请在一个窗口中运行<code>make qemu-gdb</code>，在另一个窗口中运行<code>gdb</code>（或<code>riscv64-linux-gnu-gdb</code>），设置断点，后跟“<code>c</code>”（continue），xv6将一直运行，直到到达断点。（有关有用的GDB提示，请参阅<a href="https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf">使用GNU调试器</a>。）</p></li><li><p>如果要查看编译器为内核生成的程序集是什么，或者要找出特定内核地址的指令是什么，请参阅文件<code>kernel.asm</code>，该文件在编译内核时由Makefile生成。（Makefile同时也为所有用户程序生成.asm文件。）</p></li><li><p>如果内核崩溃，它将打印一条错误消息，列出崩溃时程序计数器的值；您可以进行搜索<code>kernel.asm</code>找出程序计数器崩溃时在哪个函数中，或者可以运行<code>addr2line -e kernel/kernel pc-value</code>（有关详细信息，请运行<code>man addr2line</code>）。如果要获取回溯，请使用gdb重新启动：在一个窗口中运行’<code>make qemu-gdb</code>‘，在另一个窗口中运行gdb（或<code>riscv64-linux-gnu-gdb</code>），在<code>panic</code>中设置断点（“<code>b panic</code>”），后跟“<code>c</code>”（continue）。当内核到达断点时，键入“bt”以获取回溯跟踪。</p></li><li><p>如果您的内核挂起(例如，由于死锁)或无法进一步执行(例如，由于在执行内核指令时出现页面错误)，您可以使用gdb查找挂起的位置。在一个窗口中运行“ <code>make qemu-gdb</code>”，在另一个窗口中运行 <code>gdb</code> (<code>riscv64-linux-gnu-gdb</code>) ，后跟“<code>c</code>”(continue)。当内核出现挂起时，在 <code>qemu-gdb</code> 窗口中按 <code>Ctrl-C</code> 并键入“<code>bt</code>”以获得回溯跟踪。</p></li><li><p>qemu有一个“监视器”，允许您查询模拟机器的状态。您可以通过键入<code>&lt;Ctrl&gt;+a c</code>（c表示控制台）来获得它。一个特别有用的monitor命令<code>是info mem</code>，用于打印页表。您可能需要使用<code>cpu</code>命令来选择<code>info mem</code>查看哪一个核心，或者可以使用<code>make CPUS=1 qemu</code>启动qemu，以使其只有一个核心。</p></li></ul><p>花时间学习上述工具是非常值得的</p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易获取ext2文件系统的信息</title>
      <link href="/2023/04/26/%E7%AE%80%E6%98%93%E8%8E%B7%E5%8F%96ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
      <url>/2023/04/26/%E7%AE%80%E6%98%93%E8%8E%B7%E5%8F%96ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/redis-5fb76d3ec9fd434fe46a579d9c1c8a83.jpeg"></p><p>我的仓库地址：<a href="https://github.com/wwinter117/fetchext2.git">https://github.com/wwinter117/fetchext2.git</a></p><pre><code class="hljs plaintext">parallels@ubuntu:~/Dev/github/fetchext2$ ./fetchext2 vdisk-1k-100m --------------------------- [B0]BootBlock...--------------------------- [B1]SuperBlocks_magic                        = 61267s_inodes_count                 = 25584s_blocks_count                 = 102400s_r_blocks_count               = 5120s_free_inodes_count            = 25573s_free_blocks_count            = 94415s_first_data_block             = 1s_log_block_size               = 0s_blocks_per_group             = 8192s_inodes_per_group             = 1968s_max_mnt_count                = 0s_mtime                        = Thu Jan  1 08:00:00 1970s_wtime                        = Sun Aug 18 12:59:11 2024block size                     = 1024inode size                     = 256--------------------------- [B2]Group Desc-0bg_block_bitmap                = 259bg_inode_bitmap                = 260bg_inode_table                 = 261bg_free_blocks_count           = 7426bg_free_inodes_count           = 1957bg_used_dirs_count             = 2bg_pad                         = 0--------------------------- [B259]BMAP0   : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 64  : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 128 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 192 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 256 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 320 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 384 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 448 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 512 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 576 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 640 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 704 : 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111100 768 : ...--------------------------- [B260]IMAP0   : 11111111 11100000 00000000 00000000 00000000 00000000 00000000 00000000 64  : ...--------------------------- [B261]DIRSdrwxr-xr-xi_uid                          = 0i_gid                          = 0i_size                         = 1024i_ctime                        = Sun Aug 18 12:59:11 2024i_links_count                  = 3i_block[0] = 753--------------------------- [B753]ENTRYStype inode rec_len name_len named    2     12      1        .                   d    2     12      2        ..                  d    11    1000    10       lost+found          --------------------------- [B2]Group Desc-1(not used)--------------------------- [B2]Group Desc-2(not used)--------------------------- [B2]Group Desc-3(not used)--------------------------- [B2]Group Desc-4(not used)--------------------------- [B2]Group Desc-5(not used)--------------------------- [B2]Group Desc-6(not used)--------------------------- [B2]Group Desc-7(not used)--------------------------- [B2]Group Desc-8(not used)--------------------------- [B2]Group Desc-9(not used)--------------------------- [B2]Group Desc-10(not used)--------------------------- [B2]Group Desc-11(not used)--------------------------- [B2]Group Desc-12(not used)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 文件系统 </tag>
            
            <tag> ext2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于riscv的小型操作系统</title>
      <link href="/2023/04/02/%E5%9F%BA%E4%BA%8Eriscv%E7%9A%84%E5%B0%8F%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/04/02/%E5%9F%BA%E4%BA%8Eriscv%E7%9A%84%E5%B0%8F%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/riscv-7630a5e65eaa20a4f697de7b40bba24c.jpeg"></p><p><a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:wwinter117&#x2F;myrvos.git</p><h1 id="myrvos"><a href="#myrvos" class="headerlink" title="myrvos"></a>myrvos</h1><p>一个运行在risc-v指令集架构之上的小型操作系统</p><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul><li>RISC-V工具链 (<code>riscv64-unknown-elf-gcc</code>, <code>riscv64-unknown-elf-objcopy</code>, <code>riscv64-unknown-elf-objdump</code>)</li><li>QEMU系统模拟器 (<code>qemu-system-riscv32</code>)</li><li>GDB多架构版本 (<code>gdb-multiarch</code>)</li></ul><p>确保这些工具已经安装并且在系统路径中。</p><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p>使用以下命令来构建整个项目：</p><pre><code class="hljs shell">make all</code></pre><p>这将会编译所有源代码，并将生成的文件放置在build目录下。</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>一旦构建完成，可以使用以下命令来通过QEMU运行操作系统：</p><pre><code class="hljs shell">make run</code></pre><p>这条命令将启动QEMU模拟器并加载操作系统。可以通过QEMU的控制台来与操作系统交互。</p><h2 id="调试项目"><a href="#调试项目" class="headerlink" title="调试项目"></a>调试项目</h2><p>如果需要调试操作系统，可以使用以下命令：</p><pre><code class="hljs shell">make debug</code></pre><p>这会启动QEMU模拟器并等待GDB的连接。然后，可以使用GDB连接到QEMU，并开始调试。</p><h2 id="查看汇编代码"><a href="#查看汇编代码" class="headerlink" title="查看汇编代码"></a>查看汇编代码</h2><p>如果想要查看操作系统的汇编代码，可以运行：</p><pre><code class="hljs shell">make code</code></pre><p>这会使用objdump工具来反汇编操作系统，并通过less命令分页显示。</p><h2 id="清理项目"><a href="#清理项目" class="headerlink" title="清理项目"></a>清理项目</h2><p>要删除所有构建生成的文件，运行：</p><pre><code class="hljs shell">make clean</code></pre><p>这会删除build目录下所有的文件，清理项目环境。</p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 M1 Pro 芯片的 macOS 上编译 JDK 17</title>
      <link href="/2022/12/26/%E5%9C%A8%20M1%20Pro%20%E8%8A%AF%E7%89%87%E4%B8%8A%E7%BC%96%E8%AF%91%20JDK%2017/"/>
      <url>/2022/12/26/%E5%9C%A8%20M1%20Pro%20%E8%8A%AF%E7%89%87%E4%B8%8A%E7%BC%96%E8%AF%91%20JDK%2017/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/m1-pro-72d455dd20ed2ed2273a1cf5544d154c.jpeg"></p><h2 id="为什么编译jdk17u这个版本"><a href="#为什么编译jdk17u这个版本" class="headerlink" title="为什么编译jdk17u这个版本"></a>为什么编译jdk17u这个版本</h2><p><code>JDK 8</code> 最早发布时，主要支持的是 <code>x86</code> 和 <code>x64</code> 架构的系统。<code>Apple M1 Pro</code> 芯片使用的是 <code>AArch64</code> 架构，而 <code>JDK 8</code> 并没有对 <code>macOS/AArch64</code> 提供原生支持，需要使用<code>Rosetta 2</code> 转译工具在 <code>M1 Pro </code>芯片上运行基于 <code>x86_64</code> 架构的 <code>JDK 8</code>。</p><p><code>JDK 17</code> 已经为 <code>macOS/AArch64</code> 提供了原生支持，性能和兼容性都更好。</p><ul><li><a href="https://openjdk.java.net/jeps/306">JEP 306: Restore Always-Strict Floating-Point Semantics</a></li><li><a href="https://openjdk.java.net/jeps/356">JEP 356: Enhanced Pseudo-Random Number Generators</a></li><li><a href="https://openjdk.java.net/jeps/382">JEP 382: New macOS Rendering Pipeline</a></li><li><a href="https://openjdk.java.net/jeps/391">JEP 391: macOS&#x2F;AArch64 Port</a></li><li><a href="https://openjdk.java.net/jeps/398">JEP 398: Deprecate the Applet API for Removal</a></li><li><a href="https://openjdk.java.net/jeps/403">JEP 403: Strongly Encapsulate JDK Internals</a></li><li><a href="https://openjdk.java.net/jeps/406">JEP 406: Pattern Matching for switch (Preview)</a></li><li><a href="https://openjdk.java.net/jeps/407">JEP 407: Remove RMI Activation</a></li><li><a href="https://openjdk.java.net/jeps/409">JEP 409: Sealed Classes</a></li><li><a href="https://openjdk.java.net/jeps/410">JEP 410: Remove the Experimental AOT and JIT Compiler</a></li><li><a href="https://openjdk.java.net/jeps/411">JEP 411: Deprecate the Security Manager for Removal</a></li><li><a href="https://openjdk.java.net/jeps/412">JEP 412: Foreign Function &amp; Memory API (Incubator)</a></li><li><a href="https://openjdk.java.net/jeps/414">JEP 414: Vector API (Second Incubator)</a></li><li><a href="https://openjdk.java.net/jeps/415">JEP 415: Context-Specific Deserialization Filters</a></li></ul><p>其中 <code>JEP 391</code>的增强是专门为了支持 <code>macOS/AArch64</code>（即 <code>M</code> 系列芯片）的，因此从 <code>JDK 17</code> 开始，编译 <code>JDK</code> 会充分利用 <code>M1</code> 芯片的架构优势，而不需要依赖 <code>Rosetta 2</code> 来进行<code> x86</code> 到 <code>ARM</code> 的转译。</p><p>详细的构建流程查看<code>openjdk</code>官方： <a href="https://github.com/openjdk/jdk17u/blob/master/doc/building.md">https://github.com/openjdk/jdk17u/blob/master/doc/building.md</a></p><p>接下来是在 <code>m1pro</code> 芯片的 <code>macos</code> 上的编译过程</p><h2 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h2><p><strong>bootjdk</strong></p><p>遵循<code>N-1</code>，使用<code>jdk16</code>编译<code>jdk17u</code></p><pre><code class="hljs plaintext"># 下载jdk16来编译jdk17ubrew install --cask adoptopenjdk/openjdk/adoptopenjdk16# 获取 JDK 16 的安装路径（无需将其加入环境变量）/usr/libexec/java_home -v 16# 一般以上命令会输出以下路径，记录下这个路径，后面编译时指定这个路径/Library/Java/JavaVirtualMachines/adoptopenjdk-16.jdk/Contents/Home</code></pre><p><strong>xcode</strong></p><p>重要：使用推荐的<code>13.1</code>的这个版本</p><p>如果你的<code>Xcode</code>不是这个版本可以按照下面流程进行下载：</p><pre><code class="hljs plaintext"># apple官网下载版本13.1版本的Xcode（以下链接下载，需要登录）https://developer.apple.com/download/all/?q=13.1# 解压（或者双击解压）xip --expand Xcode_13.1.xip# 记录下解压后的路径，一般以下是用户目录下的Download路径：～/Downloads/Xcode.app</code></pre><p><strong>freetype</strong></p><pre><code class="hljs plaintext">brew install freetype</code></pre><p><strong>autoconf</strong></p><pre><code class="hljs plaintext">brew install autoconf</code></pre><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p><strong>ssh:</strong></p><pre><code class="hljs plaintext">git clone git@github.com:openjdk/jdk17u.git</code></pre><p><strong>https:</strong></p><pre><code class="hljs plaintext">git clone https://github.com/openjdk/jdk17u.git</code></pre><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>进入源码目录，输入：</p><pre><code class="hljs plaintext">sh configure --with-boot-jdk=/Library/Java/JavaVirtualMachines/adoptopenjdk-16.jdk/Contents/Home/ --with-xcode-path=/Users/zhangdongdong/Downloads/Xcode.appsh configure --with-boot-jdk=/Library/Java/JavaVirtualMachines/adoptopenjdk-16.jdk/Contents/Home/ --with-xcode-path=/Applications/Xcode.app</code></pre><p>其中</p><p><code>--with-boot-jdk=</code> 后面指定刚才下载的jdk16的路径<br><code>--with-xcode-path=</code> 后面指定刚才下载的Xcode路径</p><p>成功会出现类似于以下内容：</p><pre><code class="hljs plaintext">====================================================A new configuration has been successfully created in/Users/zhangdongdong/dev/github/x/jdk17u/build/macosx-aarch64-server-releaseusing configure arguments &#x27;--with-boot-jdk=/Library/Java/JavaVirtualMachines/adoptopenjdk-16.jdk/Contents/Home/ --with-boot-jdk-jvmargs=-Xmx4096M --with-xcode-path=/Users/zhangdongdong/Downloads/Xcode.app&#x27;.Configuration summary:* Name:           macosx-aarch64-server-release* Debug level:    release* HS debug level: product* JVM variants:   server* JVM features:   server: &#x27;cds compiler1 compiler2 dtrace epsilongc g1gc jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc&#x27; * OpenJDK target: OS: macosx, CPU architecture: aarch64, address length: 64* Version string: 17.0.13-internal+0-adhoc.zhangdongdong.jdk17u (17.0.13-internal)Tools summary:* Boot JDK:       openjdk version &quot;16.0.1&quot; 2021-04-20 OpenJDK Runtime Environment AdoptOpenJDK-16.0.1+9 (build 16.0.1+9) OpenJDK 64-Bit Server VM AdoptOpenJDK-16.0.1+9 (build 16.0.1+9, mixed mode, sharing) (at /Library/Java/JavaVirtualMachines/adoptopenjdk-16.jdk/Contents/Home)* Toolchain:      clang (clang/LLVM from Xcode 13.1)* C Compiler:     Version 13.0.0 (at /Users/zhangdongdong/Downloads/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang)* C++ Compiler:   Version 13.0.0 (at /Users/zhangdongdong/Downloads/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++)Build performance summary:* Cores to use:   8* Memory limit:   16384 MBThe following warnings were produced. Repeated here for convenience:</code></pre><p>可以看见已经配置了<code>bootjdk</code>为<code>jdk16.0.1</code>，<code>Xcode</code>版本为<code>13.1</code></p><p>然后可以输入下面命令，开始编译：</p><pre><code class="hljs plaintext">make images</code></pre><p>等待一段时间后，编译成功会输出以下内容：</p><pre><code class="hljs plaintext">...Creating jdk imageCreating CDS archive for jdk imageCreating CDS-NOCOOPS archive for jdk imageStopping sjavac serverFinished building target &#x27;images&#x27; in configuration &#x27;macosx-aarch64-server-release&#x27;</code></pre><h2 id="idea中验证"><a href="#idea中验证" class="headerlink" title="idea中验证"></a>idea中验证</h2><p>投稿视频中演示</p>]]></content>
      
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> macos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot字节码解释器片段</title>
      <link href="/2022/09/28/HotSpot%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E7%89%87%E6%AE%B5/"/>
      <url>/2022/09/28/HotSpot%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E7%89%87%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/jvm-3af4ecb7bbe2376bffb9225160a6a0dd.jpg"></p><p>以下代码片段是 <code>JVM</code> 中对象分配的核心逻辑，来自《深入理解java虚拟机》第三版p49。</p><pre><code class="hljs c++"><span class="hljs-comment">// 确保常量池中的类已经被解析</span><span class="hljs-keyword">if</span> (!constants-&gt;<span class="hljs-built_in">tag_at</span>(index).<span class="hljs-built_in">is_unresolved_Klass</span>()) &#123;    <span class="hljs-comment">// 获取常量池中的Klass对象</span>    oop entry = (Klassoop) *constants-&gt;<span class="hljs-built_in">obj_at_addr</span>(index);        <span class="hljs-comment">// 断言该对象是一个已解析的Klass</span>    <span class="hljs-built_in">assert</span>(entry-&gt;<span class="hljs-built_in">is_klass</span>(), <span class="hljs-string">&quot;Should be resolved klass&quot;</span>);    klassOop k_entry = (klassOop) entry;        <span class="hljs-comment">// 断言该类是一个实例类（instanceKlass）</span>    <span class="hljs-built_in">assert</span>(k_entry-&gt;<span class="hljs-built_in">klass_part</span>()-&gt;<span class="hljs-built_in">oop_is_instance</span>(), <span class="hljs-string">&quot;Should be instanceKlass&quot;</span>);    instanceKlass* ik = (instanceKlass*) k_entry-&gt;<span class="hljs-built_in">klass_part</span>();    <span class="hljs-comment">// 确保类已经初始化并且可以快速分配</span>    <span class="hljs-keyword">if</span> (ik-&gt;<span class="hljs-built_in">is_initialized</span>() &amp;&amp; ik-&gt;<span class="hljs-built_in">can_be_fastpath_allocated</span>()) &#123;        <span class="hljs-comment">// 计算对象大小</span>        <span class="hljs-type">size_t</span> obj_size = ik-&gt;<span class="hljs-built_in">size_helper</span>();        oop result = <span class="hljs-literal">NULL</span>;                <span class="hljs-comment">// 判断是否需要将内存区域置零</span>        <span class="hljs-type">bool</span> need_zero = !ZeroTLAB;        <span class="hljs-comment">// 尝试在TLAB中分配内存</span>        <span class="hljs-keyword">if</span> (UseTLAB) &#123;            result = (oop) THREAD-&gt;<span class="hljs-built_in">tlab</span>()-&gt;<span class="hljs-built_in">allocate</span>(obj_size);        &#125;        <span class="hljs-comment">// 如果在TLAB分配失败，则尝试直接在Eden中分配</span>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">NULL</span>) &#123;            need_zero = <span class="hljs-literal">true</span>;retry:            HeapWord* compare_to = *Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">top_addr</span>();            HeapWord* new_top = compare_to + obj_size;            <span class="hljs-comment">// 使用CAS操作安全地更新堆顶指针</span>            <span class="hljs-keyword">if</span> (new_top &lt;= *Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">end_addr</span>()) &#123;                <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg_ptr</span>(new_top, Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">top_addr</span>(), compare_to) != compare_to) &#123;                    <span class="hljs-comment">// 如果CAS失败，重试分配</span>                    <span class="hljs-keyword">goto</span> retry;                &#125;                result = (oop) compare_to;                <span class="hljs-comment">// 如果需要，将对象内存区域置零</span>                <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">NULL</span> &amp;&amp; need_zero) &#123;                    HeapWord* to_zero = (HeapWord*) result + <span class="hljs-built_in">sizeof</span>(oopDesc) / oopSize;                    obj_size -= <span class="hljs-built_in">sizeof</span>(oopDesc) / oopSize;                    <span class="hljs-keyword">if</span> (obj_size &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-built_in">memset</span>(to_zero, <span class="hljs-number">0</span>, obj_size * HeapWordSize);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 根据是否启用偏向锁，设置对象头信息</span>        <span class="hljs-keyword">if</span> (UseBiasedLocking) &#123;            result-&gt;<span class="hljs-built_in">set_mark</span>(ik-&gt;<span class="hljs-built_in">prototype_header</span>());        &#125; <span class="hljs-keyword">else</span> &#123;            result-&gt;<span class="hljs-built_in">set_mark</span>(markOopDesc::<span class="hljs-built_in">prototype</span>());            result-&gt;<span class="hljs-built_in">set_klass_gap</span>(<span class="hljs-number">0</span>);        &#125;        result-&gt;<span class="hljs-built_in">set_klass</span>(k_entry);        <span class="hljs-comment">// 将对象引用压入栈中，继续执行下一条字节码指令</span>        <span class="hljs-built_in">SET_STACK_OBJECT</span>(result, <span class="hljs-number">0</span>);        <span class="hljs-built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h3 id="代码简化和解释"><a href="#代码简化和解释" class="headerlink" title="代码简化和解释"></a>代码简化和解释</h3><h4 id="1-确保常量池中存放的是已解析的类"><a href="#1-确保常量池中存放的是已解析的类" class="headerlink" title="1. 确保常量池中存放的是已解析的类"></a>1. 确保常量池中存放的是已解析的类</h4><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!constants-&gt;<span class="hljs-built_in">tag_at</span>(index).<span class="hljs-built_in">is_unresolved_Klass</span>()) &#123;    oop entry = (Klassoop) *constants-&gt;<span class="hljs-built_in">obj_at_addr</span>(index);    <span class="hljs-built_in">assert</span>(entry-&gt;<span class="hljs-built_in">is_klass</span>(), <span class="hljs-string">&quot;Should be resolved klass&quot;</span>);    klassOop k_entry = (klassOop) entry;    <span class="hljs-built_in">assert</span>(k_entry-&gt;<span class="hljs-built_in">klass_part</span>()-&gt;<span class="hljs-built_in">oop_is_instance</span>(), <span class="hljs-string">&quot;Should be instanceKlass&quot;</span>);    instanceKlass* ik = (instanceKlass*) k_entry-&gt;<span class="hljs-built_in">klass_part</span>();&#125;</code></pre><ul><li>这部分代码首先检查常量池中的一个条目，确保它是一个已经解析过的类（即<code>Klass</code> 对象）。</li><li><code>assert</code> 语句用于验证这个条目是否确实是一个 <code>klassOop</code> （代表类的元数据对象）以及它是否是一个实例类（<code>instanceKlass</code>）。</li><li><code>instanceKlass</code> 是 <code>HotSpot</code> 中表示类元数据的一个重要结构，它包含类的字段、方法等信息。</li></ul><h4 id="2-确保对象所属类型已经经过初始化阶段"><a href="#2-确保对象所属类型已经经过初始化阶段" class="headerlink" title="2. 确保对象所属类型已经经过初始化阶段"></a>2. 确保对象所属类型已经经过初始化阶段</h4><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (ik-&gt;<span class="hljs-built_in">is_initialized</span>() &amp;&amp; ik-&gt;<span class="hljs-built_in">can_be_fastpath_allocated</span>()) &#123;    <span class="hljs-type">size_t</span> obj_size = ik-&gt;<span class="hljs-built_in">size_helper</span>();    oop result = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">bool</span> need_zero = !ZeroTLAB;</code></pre><ul><li>在继续对象分配之前，确保这个类已经完成初始化阶段（即其静态初始化块已经执行）。</li><li><code>size_helper()</code> 计算对象的大小。</li><li><code>need_zero</code> 用于决定是否需要将对象的内存区域置为零。</li></ul><h4 id="3-在TLAB（Thread-Local-Allocation-Buffer）中分配对象"><a href="#3-在TLAB（Thread-Local-Allocation-Buffer）中分配对象" class="headerlink" title="3. 在TLAB（Thread-Local Allocation Buffer）中分配对象"></a>3. 在TLAB（Thread-Local Allocation Buffer）中分配对象</h4><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (UseTLAB) &#123;    result = (oop) THREAD-&gt;<span class="hljs-built_in">tlab</span>()-&gt;<span class="hljs-built_in">allocate</span>(obj_size);    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">NULL</span>) &#123;        need_zero = <span class="hljs-literal">true</span>;    &#125;</code></pre><ul><li>如果启用了 <code>TLAB</code>（线程本地分配缓存），则尝试在 <code>TLAB</code> 中分配对象。如果分配失败（<code>result == NULL</code>），将 <code>need_zero</code> 设置为 <code>true</code>，以确保稍后分配时内存区域会被清零。</li></ul><h4 id="4-直接在Eden空间分配对象"><a href="#4-直接在Eden空间分配对象" class="headerlink" title="4. 直接在Eden空间分配对象"></a>4. 直接在Eden空间分配对象</h4><pre><code class="hljs cpp">HeapWord* compare_to = *Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">top_addr</span>();HeapWord* new_top = compare_to + obj_size;<span class="hljs-keyword">if</span> (new_top &lt;= *Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">end_addr</span>()) &#123;    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg_ptr</span>(new_top, Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">top_addr</span>(), compare_to) != compare_to) &#123;        <span class="hljs-keyword">goto</span> retry;    &#125;    result = (oop) compare_to;    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">if</span> (need_zero) &#123;            HeapWord* to_zero = (HeapWord*) result + <span class="hljs-built_in">sizeof</span>(oopDesc) / oopSize;            obj_size -= <span class="hljs-built_in">sizeof</span>(oopDesc) / oopSize;            <span class="hljs-keyword">if</span> (obj_size &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">memset</span>(to_zero, <span class="hljs-number">0</span>, obj_size * HeapWordSize);            &#125;        &#125;    &#125;&#125;</code></pre><ul><li>如果在 <code>TLAB</code> 分配失败，就尝试在 <code>Eden</code> 空间分配对象。</li><li>通过 <code>CAS</code>（Compare-And-Swap，比较并交换）操作确保在多线程环境下安全地更新堆顶指针。若 <code>CAS</code> 失败，则通过<code>goto retry</code>重新尝试。</li><li>如果分配成功且 <code>need_zero</code> 为 <code>true</code>，则使用 <code>memset</code> 函数将对象的内存置零。</li></ul><h4 id="5-设置对象头信息"><a href="#5-设置对象头信息" class="headerlink" title="5. 设置对象头信息"></a>5. 设置对象头信息</h4><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (UseBiasedLocking) &#123;    result-&gt;<span class="hljs-built_in">set_mark</span>(ik-&gt;<span class="hljs-built_in">prototype_header</span>());&#125; <span class="hljs-keyword">else</span> &#123;    result-&gt;<span class="hljs-built_in">set_mark</span>(markOopDesc::<span class="hljs-built_in">prototype</span>());    result-&gt;<span class="hljs-built_in">set_klass_gap</span>(<span class="hljs-number">0</span>);&#125;result-&gt;<span class="hljs-built_in">set_klass</span>(k_entry);</code></pre><ul><li>根据是否启用了偏向锁（<code>Biased Locking</code>）来设置对象头信息。</li><li>设置完对象头信息后，将对象的类指针（<code>klass</code>）设置为刚才解析的 <code>k_entry</code>。</li></ul><h4 id="6-将对象引用入栈，继续执行下一条指令"><a href="#6-将对象引用入栈，继续执行下一条指令" class="headerlink" title="6. 将对象引用入栈，继续执行下一条指令"></a>6. 将对象引用入栈，继续执行下一条指令</h4><pre><code class="hljs cpp"><span class="hljs-built_in">SET_STACK_OBJECT</span>(result, <span class="hljs-number">0</span>);<span class="hljs-built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);</code></pre><ul><li>将新分配的对象引用压入Java栈中，并更新程序计数器（PC）和操作数栈顶指针，继续执行后续的字节码指令。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> hotspot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-spec-8. Threads and Locks【Second Edition Spec】</title>
      <link href="/2022/09/12/jvm-spec-8.%20Threads%20and%20Locks%E3%80%90Second%20Edition%20Spec%E3%80%91/"/>
      <url>/2022/09/12/jvm-spec-8.%20Threads%20and%20Locks%E3%80%90Second%20Edition%20Spec%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>This chapter details the low-level actions that may be used to explain the interaction of Java virtual machine threads with a shared main memory. It has been adapted with minimal changes from Chapter 17 of the first edition of _The Java_TM <em>Language Specification</em>, by James Gosling, Bill Joy, and Guy Steele.</p><hr><h2 id="8-1-Terminology-and-Framework"><a href="#8-1-Terminology-and-Framework" class="headerlink" title="8.1 Terminology and Framework"></a>8.1 Terminology and Framework</h2><p>A <em>variable</em> is any location within a program that may be stored into. This includes not only class variables and instance variables, but also components of arrays. Variables are kept in a <em>main memory</em> that is shared by all threads. Because it is impossible for one thread to access parameters or local variables of another thread, it does not matter whether parameters and local variables are thought of as residing in the shared main memory or in the working memory of the thread that owns them.</p><p>Every thread has a <em>working memory</em> in which it keeps its own <em>working copy</em> of variables that it must use or assign. As the thread executes a program, it operates on these working copies. The main memory contains the _master copy_of every variable. There are rules about when a thread is permitted or required to transfer the contents of its working copy of a variable into the master copy or vice versa.</p><p>The main memory also contains <em>locks</em>; there is one lock associated with each object. Threads may compete to acquire a lock.</p><p>For the purposes of this chapter, the verbs <em>use</em>, <em>assign</em>, <em>load</em>, <em>store</em>, <em>lock</em>, and <em>unlock</em> name actions that a thread can perform. The verbs <em>read</em>, <em>write</em>, <em>lock</em>, and <em>unlock</em> name actions that the main memory subsystem can perform. Each of these operations is atomic (indivisible). </p><p>A <em>use</em> or <em>assign</em> operation is a tightly coupled interaction between a thread’s execution engine and the thread’s working memory. A <em>lock</em> or <em>unlock</em> operation is a tightly coupled interaction between a thread’s execution engine and the main memory. But the transfer of data between the main memory and a thread’s working memory is loosely coupled. When data is copied from the main memory to a working memory, two actions must occur: a <em>read</em> operation performed by the main memory, followed some time later by a corresponding <em>load</em> operation performed by the working memory. When data is copied from a working memory to the main memory, two actions must occur: a _store_operation performed by the working memory, followed some time later by a corresponding <em>write</em> operation performed by the main memory. There may be some transit time between main memory and a working memory, and the transit time may be different for each transaction; thus, operations initiated by a thread on different variables may be viewed by another thread as occurring in a different order. For each variable, however, the operations in main memory on behalf of any one thread are performed in the same order as the corresponding operations by that thread. (This is explained in greater detail later.)</p><p>A single thread issues a stream of <em>use</em>, <em>assign</em>, <em>lock</em>, and <em>unlock</em> operations as dictated by the semantics of the program it is executing. The underlying Java virtual machine implementation is then required additionally to perform appropriate <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> operations so as to obey a certain set of constraints, explained later. If the implementation correctly follows these rules and the programmer follows certain other rules of programming, then data can be reliably transferred between threads through shared variables. The rules are designed to be “tight” enough to make this possible, but “loose” enough to allow hardware and software designers considerable freedom to improve speed and throughput through such mechanisms as registers, queues, and caches.</p><p>Here are the detailed definitions of each of the operations:</p><ul><li><p>A <em>use</em> action (by a thread) transfers the contents of the thread’s working copy of a variable to the thread’s execution engine. This action is performed whenever a thread executes a virtual machine instruction that uses the value of a variable.</p></li><li><p>An <em>assign</em> action (by a thread) transfers a value from the thread’s execution engine into the thread’s working copy of a variable. This action is performed whenever a thread executes a virtual machine instruction that assigns to a variable.</p></li><li><p>A <em>read</em> action (by the main memory) transmits the contents of the master copy of a variable to a thread’s working memory for use by a later <em>load</em> operation.</p></li><li><p>A <em>load</em> action (by a thread) puts a value transmitted from main memory by a <em>read</em> action into the thread’s working copy of a variable.</p></li><li><p>A <em>store</em> action (by a thread) transmits the contents of the thread’s working copy of a variable to main memory for use by a later <em>write</em> operation.</p></li><li><p>A <em>write</em> action (by the main memory) puts a value transmitted from the thread’s working memory by a <em>store</em> action into the master copy of a variable in main memory.</p></li><li><p>A <em>lock</em> action (by a thread tightly synchronized with main memory) causes a thread to acquire one claim on a particular lock.</p></li><li><p>An <em>unlock</em> action (by a thread tightly synchronized with main memory) causes a thread to release one claim on a particular lock.</p></li></ul><p>Thus, the interaction of a thread with a variable over time consists of a sequence of <em>use</em>, <em>assign</em>, <em>load</em>, and <em>store</em> operations. Main memory performs a <em>read</em> operation for every <em>load</em> and a <em>write</em> operation for every <em>store</em>. A thread’s interactions with a lock over time consist of a sequence of <em>lock</em> and <em>unlock</em> operations. All the globally visible behavior of a thread thus comprises all the thread’s operations on variables and locks.</p><hr><h2 id="8-2-Execution-Order-and-Consistency"><a href="#8-2-Execution-Order-and-Consistency" class="headerlink" title="8.2 Execution Order and Consistency"></a>8.2 Execution Order and Consistency</h2><p>The rules of execution order constrain the order in which certain events may occur. There are four general constraints on the relationships among actions:</p><ul><li><p>The actions performed by any one thread are totally ordered; that is, for any two actions performed by a thread, one action precedes the other.</p></li><li><p>The actions performed by the main memory for any one variable are totally ordered; that is, for any two actions performed by the main memory on the same variable, one action precedes the other.</p></li><li><p>The actions performed by the main memory for any one lock are totally ordered; that is, for any two actions performed by the main memory on the same lock, one action precedes the other.</p></li><li><p>It is not permitted for an action to follow itself.</p></li></ul><p>The last rule may seem trivial, but it does need to be stated separately and explicitly for completeness. Without the rule, it would be possible to propose a set of actions by two or more threads and precedence relationships among the actions that would satisfy all the other rules but would require an action to follow itself.</p><p>Threads do not interact directly; they communicate only through the shared main memory. The relationships between the actions of a thread and the actions of main memory are constrained in three ways: </p><ul><li><p>Each <em>lock</em> or <em>unlock</em> action is performed jointly by some thread and the main memory.</p></li><li><p>Each <em>load</em> action by a thread is uniquely paired with a <em>read</em> action by the main memory such that the <em>load</em> action follows the <em>read</em> action.</p></li><li><p>Each <em>store</em> action by a thread is uniquely paired with a <em>write</em> action by the main memory such that the <em>write</em> action follows the <em>store</em> action.</p></li></ul><p>Most of the rules in the following sections further constrain the order in which certain actions take place. A rule may state that one action must precede or follow some other action. Note that this relationship is transitive: if action _A_must precede action <em>B</em>, and <em>B</em> must precede <em>C</em>, then <em>A</em> must precede <em>C</em>. The programmer must remember that these rules are the <em>only</em> constraints on the ordering of actions; if no rule or combination of rules implies that action <em>A</em> must precede action <em>B</em>, then a Java virtual machine implementation is free to perform action <em>B</em> before action <em>A</em>, or to perform action <em>B</em> concurrently with action <em>A</em>. This freedom can be the key to good performance. Conversely, an implementation is not required to take advantage of all the freedoms given it.</p><p>In the rules that follow, the phrasing “<em>B</em> must intervene between <em>A</em> and <em>C</em>“ means that action <em>B</em> must follow action <em>A</em> and precede action <em>C</em>.</p><hr><h2 id="8-3-Rules-About-Variables"><a href="#8-3-Rules-About-Variables" class="headerlink" title="8.3 Rules About Variables"></a>8.3 Rules About Variables</h2><p>Let <em>T</em> be a thread and <em>V</em> be a variable. There are certain constraints on the operations performed by <em>T</em> with respect to <em>V</em>  :</p><ul><li><p>A <em>use</em> or <em>assign</em> by <em>T</em> of <em>V</em> is permitted only when dictated by execution by <em>T</em> of the program according to the standard execution model. For example, an occurrence of <em>V</em> as an operand of the <code>+</code> operator requires that a single <em>use</em> operation occur on <em>V</em>  ; an occurrence of <em>V</em> as the left-hand operand of the assignment operator <code>=</code> requires that a single <em>assign</em> operation occur. All <em>use</em> and <em>assign</em> actions by a given thread must occur in the order specified by the program being executed by the thread. If the following rules forbid <em>T</em> to perform a required <em>use</em> as its next action, it may be necessary for <em>T</em> to perform a <em>load</em> first in order to make progress.</p></li><li><p>A <em>store</em> operation by <em>T</em> on <em>V</em> must intervene between an <em>assign</em> by <em>T</em> of <em>V</em> and a subsequent <em>load</em> by <em>T</em> of <em>V</em>. (Less formally: a thread is not permitted to lose the most recent assign.)</p></li><li><p>An <em>assign</em> operation by <em>T</em> on <em>V</em> must intervene between a <em>load</em> or <em>store</em> by <em>T</em> of <em>V</em> and a subsequent <em>store</em> by <em>T</em> of <em>V</em>. (Less formally: a thread is not permitted to write data from its working memory back to main memory for no reason.)</p></li><li><p>After a thread is created, it must perform an <em>assign</em> or <em>load</em> operation on a variable before performing a <em>use</em> or <em>store</em> operation on that variable. (Less formally: a new thread starts with an empty working memory.)</p></li><li><p>After a variable is created, every thread must perform an <em>assign</em> or <em>load</em> operation on that variable before performing a <em>use</em> or <em>store</em> operation on that variable. (Less formally: a new variable is created only in main memory and is not initially in any thread’s working memory.)</p></li></ul><p>Provided that all the constraints in Sections <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html#22227">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html#22253">8.6</a>, and <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html#22258">8.7</a> are obeyed, a <em>load</em> or <em>store</em> operation may be issued at any time by any thread on any variable, at the whim of the implementation.</p><p>There are also certain constraints on the <em>read</em> and <em>write</em> operations performed by main memory:</p><ul><li><p>For every <em>load</em> operation performed by any thread <em>T</em> on its working copy of a variable <em>V</em>, there must be a corresponding preceding <em>read</em> operation by the main memory on the master copy of <em>V</em>, and the <em>load</em> operation must put into the working copy the data transmitted by the corresponding <em>read</em> operation.</p></li><li><p>For every <em>store</em> operation performed by any thread <em>T</em> on its working copy of a variable <em>V</em>, there must follow a corresponding <em>write</em> operation by the main memory on the master copy of <em>V</em>, and the <em>write</em> operation must put into the master copy the data transmitted by the corresponding <em>store</em> operation.</p></li><li><p>Let action <em>A</em> be a <em>load</em> or <em>store</em> by thread <em>T</em> on variable <em>V</em>, and let action <em>P</em> be the corresponding <em>read</em> or <em>write</em> by the main memory on variable <em>V</em>. Similarly, let action <em>B</em> be some other <em>load</em> or <em>store</em> by thread <em>T</em> on that same variable <em>V</em>, and let action <em>Q</em> be the corresponding <em>read</em> or <em>write</em> by the main memory on variable <em>V</em>. If <em>A</em> precedes <em>B</em>, then <em>P</em> must precede <em>Q</em>. (Less formally: operations on the master copy of any given variable on behalf of a thread are performed by the main memory in exactly the order that the thread requested.)</p></li></ul><p>Note that this last rule applies <em>only</em> to actions by a thread on the <em>same</em> variable. However, there is a more stringent rule for <code>volatile</code> variables <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html#22258">(§8.7)</a>.</p><hr><h2 id="8-4-Nonatomic-Treatment-of-double-and-long-Variables"><a href="#8-4-Nonatomic-Treatment-of-double-and-long-Variables" class="headerlink" title="8.4 Nonatomic Treatment of double and long Variables"></a>8.4 Nonatomic Treatment of <code>double</code> and <code>long</code> Variables</h2><p>If a <code>double</code> or <code>long</code> variable is not declared <code>volatile</code>, then for the purposes of <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> operations it is treated as if it were two variables of 32 bits each; wherever the rules require one of these operations, two such operations are performed, one for each 32-bit half. The manner in which the 64 bits of a <code>double</code> or <code>long</code> variable are encoded into two 32-bit quantities and the order of the operations on the halves of the variables are not defined by <em>The Java</em> <em>Language Specification</em>. </p><p>This matters only because a <em>read</em> or <em>write</em> of a <code>double</code> or <code>long</code> variable may be handled by an actual main memory as two 32-bit <em>read</em> or <em>write</em> operations that may be separated in time, with other operations coming between them. Consequently, if two threads concurrently assign distinct values to the same shared non-<code>volatile</code> <code>double</code> or <code>long</code> variable, a subsequent use of that variable may obtain a value that is not equal to either of the assigned values, but rather some implementation-dependent mixture of the two values.</p><p>An implementation is free to implement <em>load</em>, <em>store</em>, <em>read</em>, and <em>write</em> operations for <code>double</code> and <code>long</code> values as atomic 64-bit operations; in fact, this is strongly encouraged. The model divides them into 32-bit halves for the sake of currently popular microprocessors that fail to provide efficient atomic memory transactions on 64-bit quantities. It would have been simpler for the Java virtual machine to define all memory transactions on single variables as atomic; this more complex definition is a pragmatic concession to current hardware practice. In the future this concession may be eliminated. Meanwhile, programmers are cautioned to explicitly synchronize access to shared <code>double</code> and <code>long</code> variables.</p><hr><h2 id="8-5-Rules-About-Locks"><a href="#8-5-Rules-About-Locks" class="headerlink" title="8.5 Rules About Locks"></a>8.5 Rules About Locks</h2><p>Let <em>T</em> be a thread and <em>L</em> be a lock. There are certain constraints on the operations performed by <em>T</em> with respect to <em>L</em>:</p><ul><li><p>A <em>lock</em> operation by <em>T</em> on <em>L</em> may occur only if, for every thread <em>S</em> other than <em>T</em>, the number of preceding <em>unlock</em> operations by <em>S</em> on <em>L</em> equals the number of preceding <em>lock</em> operations by <em>S</em> on <em>L</em>. (Less formally: only one thread at a time is permitted to lay claim to a lock; moreover, a thread may acquire the same lock multiple times and does not relinquish ownership of it until a matching number of <em>unlock</em> operations have been performed.)</p></li><li><p>An <em>unlock</em> operation by thread <em>T</em> on lock <em>L</em> may occur only if the number of preceding <em>unlock</em> operations by <em>T</em> on <em>L</em> is strictly less than the number of preceding <em>lock</em> operations by <em>T</em> on <em>L</em>. (Less formally: a thread is not permitted to unlock a lock it does not own.)</p></li></ul><p>With respect to a lock, the <em>lock</em> and <em>unlock</em> operations performed by all the threads are performed in some total sequential order. This total order must be consistent with the total order on the operations of each thread.</p><hr><h2 id="8-6-Rules-About-the-Interaction-of-Locks-and-Variables"><a href="#8-6-Rules-About-the-Interaction-of-Locks-and-Variables" class="headerlink" title="8.6 Rules About the Interaction of Locks and Variables"></a>8.6 Rules About the Interaction of Locks and Variables</h2><p>Let <em>T</em> be any thread, let <em>V</em> be any variable, and let <em>L</em> be any lock. There are certain constraints on the operations performed by <em>T</em> with respect to <em>V</em> and <em>L</em>:</p><ul><li><p>Between an <em>assign</em> operation by <em>T</em> on <em>V</em> and a subsequent <em>unlock</em> operation by <em>T</em> on <em>L</em>, a <em>store</em> operation by <em>T</em> on <em>V</em> must intervene; moreover, the <em>write</em> operation corresponding to that <em>store</em> must precede the <em>unlock</em> operation, as seen by main memory. (Less formally: if a thread is to perform an <em>unlock</em> operation on <em>any</em> lock, it must first copy <em>all</em> assigned values in its working memory back out to main memory.)</p></li><li><p>Between a <em>lock</em> operation by <em>T</em> on <em>L</em> and a subsequent <em>use</em> or <em>store</em> operation by <em>T</em> on a variable <em>V</em>, an <em>assign</em> or <em>load</em> operation on <em>V</em> must intervene; moreover, if it is a <em>load</em> operation, then the <em>read</em> operation corresponding to that <em>load</em> must follow the <em>lock</em> operation, as seen by main memory. (Less formally: a <em>lock</em> operation behaves as if it flushes <em>all</em> variables from the thread’s working memory, after which the thread must either assign them itself or load copies anew from main memory.)</p></li></ul><hr><h2 id="8-7-Rules-for-volatile-Variables"><a href="#8-7-Rules-for-volatile-Variables" class="headerlink" title="8.7 Rules for volatile Variables"></a>8.7 Rules for <code>volatile</code> Variables</h2><p>If a variable is declared volatile, then additional constraints apply to the operations of each thread. Let <em>T</em> be a thread and let <em>V</em> and <em>W</em> be volatile variables.</p><ul><li><p>A <em>use</em> operation by <em>T</em> on <em>V</em> is permitted only if the previous operation by <em>T</em> on <em>V</em> was <em>load</em>, and a <em>load</em> operation by <em>T</em> on <em>V</em> is permitted only if the next operation by <em>T</em> on <em>V</em> is <em>use</em>. The <em>use</em> operation is said to be “associated” with the <em>read</em> operation that corresponds to the <em>load</em>.</p></li><li><p>A <em>store</em> operation by <em>T</em> on <em>V</em> is permitted only if the previous operation by <em>T</em> on <em>V</em> was <em>assign</em>, and an <em>assign</em> operation by <em>T</em> on <em>V</em> is permitted only if the next operation by <em>T</em> on <em>V</em> is <em>store</em>. The <em>assign</em> operation is said to be “associated” with the <em>write</em> operation that corresponds to the <em>store</em>.</p></li><li><p>Let action <em>A</em> be a <em>use</em> or <em>assign</em> by thread <em>T</em> on variable <em>V</em>, let action <em>F</em> be the <em>load</em> or <em>store</em> associated with <em>A</em>, and let action <em>P</em> be the <em>read</em> or <em>write</em> of <em>V</em> that corresponds to <em>F</em>. Similarly, let action <em>B</em> be a <em>use</em> or <em>assign</em> by thread _T_on variable <em>W</em>, let action <em>G</em> be the <em>load</em> or <em>store</em> associated with <em>B</em>, and let action <em>Q</em> be the <em>read</em> or <em>write</em> of <em>W</em> that corresponds to <em>G</em>. If <em>A</em> precedes <em>B</em>, then <em>P</em> must precede <em>Q</em>. (Less formally: operations on the master copies of volatile variables on behalf of a thread are performed by the main memory in exactly the order that the thread requested.)</p></li></ul><hr><h2 id="8-8-Prescient-Store-Operations"><a href="#8-8-Prescient-Store-Operations" class="headerlink" title="8.8 Prescient Store Operations"></a>8.8 Prescient Store Operations</h2><p>If a variable is not declared <code>volatile</code>, then the rules in the previous sections are relaxed slightly to allow <em>store</em> operations to occur earlier than would otherwise be permitted. The purpose of this relaxation is to allow optimizing compilers to perform certain kinds of code rearrangement that preserve the semantics of properly synchronized programs, but might be caught in the act of performing memory operations out of order by programs that are not properly synchronized.</p><p>Suppose that a <em>store</em> by <em>T</em> of <em>V</em> would follow a particular <em>assign</em> by <em>T</em> of <em>V</em> according to the rules of the previous sections, with no intervening <em>load</em> or <em>assign</em> by <em>T</em> of <em>V</em>. Then that <em>store</em> operation would send to the main memory the value that the <em>assign</em> operation put into the working memory of thread <em>T</em>. The special rule allows the <em>store</em> operation actually to occur before the <em>assign</em> operation instead, if the following restrictions are obeyed:</p><ul><li><p>If the <em>store</em> operation occurs, the <em>assign</em> is bound to occur. (Remember, these are restrictions on what actually happens, not on what a thread plans to do. No fair performing a <em>store</em> and then throwing an exception before the <em>assign</em> occurs!)</p></li><li><p>No <em>lock</em> operation intervenes between the relocated <em>store</em> and the <em>assign</em>.</p></li><li><p>No <em>load</em> of <em>V</em> intervenes between the relocated <em>store</em> and the <em>assign</em>.</p></li><li><p>No other <em>store</em> of <em>V</em> intervenes between the relocated <em>store</em> and the <em>assign</em>.</p></li><li><p>The <em>store</em> operation sends to the main memory the value that the <em>assign</em> operation will put into the working memory of thread <em>T</em>.</p></li></ul><p> </p><p>This last property inspires us to call such an early <em>store</em> operation <em>prescient</em>: it has to know ahead of time, somehow, what value will be stored by the <em>assign</em> that it should have followed. In practice, optimized compiled code will compute such values early (which is permitted if, for example, the computation has no side effects and throws no exceptions), store them early (before entering a loop, for example), and keep them in working registers for later use within the loop.</p><hr><h2 id="8-9-Discussion"><a href="#8-9-Discussion" class="headerlink" title="8.9 Discussion"></a>8.9 Discussion</h2><p>Any association between locks and variables is purely conventional. Locking any lock conceptually flushes <em>all</em> variables from a thread’s working memory, and unlocking any lock forces the writing out to main memory of _all_variables that the thread has assigned. That a lock may be associated with a particular object or a class is purely a convention. For example, in some applications it may be appropriate always to lock an object before accessing any of its instance variables; <code>synchronized</code> methods are a convenient way to follow this convention. In other applications, it may suffice to use a single lock to synchronize access to a large collection of objects.</p><p>If a thread uses a particular shared variable only after locking a particular lock and before the corresponding unlocking of that same lock, then the thread will read the shared value of that variable from main memory after the _lock_operation, if necessary, and will copy back to main memory the value most recently assigned to that variable before the <em>unlock</em> operation. This, in conjunction with the mutual exclusion rules for locks, suffices to guarantee that values are correctly transmitted from one thread to another through shared variables.</p><p>The rules for volatile variables effectively require that main memory be touched exactly once for each <em>use</em> or <em>assign</em> of a volatile variable by a thread, and that main memory be touched in exactly the order dictated by the thread execution semantics. However, such memory operations are not ordered with respect to <em>read</em> and <em>write</em> operations on nonvolatile variables.</p><hr><h2 id="8-10-Example-Possible-Swap"><a href="#8-10-Example-Possible-Swap" class="headerlink" title="8.10 Example: Possible Swap"></a>8.10 Example: Possible Swap</h2><p>Consider a class that has class variables <code>a</code> and <code>b</code> and methods <code>hither</code> and <code>yon</code>:</p><blockquote><p>class Sample {<br>    int a &#x3D; 1, b &#x3D; 2;<br>    void hither() {<br>        a &#x3D; b;<br>    }<br>    void yon()<br>        b &#x3D; a;<br>    }<br>}</p></blockquote><p>Now suppose that two threads are created and that one thread calls <code>hither</code> while the other thread calls <code>yon</code>. What is the required set of actions and what are the ordering constraints?</p><p>Let us consider the thread that calls <code>hither</code>. According to the rules, this thread must perform a <em>use</em> of <code>b</code> followed by an <em>assign</em> of <code>a</code>. That is the bare minimum required to execute a call to the method <code>hither</code>.</p><p>Now, the first operation on variable <code>b</code> by the thread cannot be <em>use</em>. But it may be <em>assign</em> or <em>load</em>. An <em>assign</em> to <code>b</code> cannot occur because the program text does not call for such an <em>assign</em> operation, so a <em>load</em> of <code>b</code> is required. This _load_operation by the thread in turn requires a preceding <em>read</em> operation for <code>b</code> by the main memory.</p><p>The thread may optionally <em>store</em> the value of <code>a</code> after the <em>assign</em> has occurred. If it does, then the <em>store</em> operation in turn requires a following <em>write</em> operation for <code>a</code> by the main memory.</p><p>The situation for the thread that calls <code>yon</code> is similar, but with the roles of <code>a</code> and <code>b</code> exchanged.</p><p>The total set of operations may be pictured as follows:</p><p><img src="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.anc.gif">  </p><p>Here an arrow from action <em>A</em> to action <em>B</em> indicates that <em>A</em> must precede <em>B</em>.</p><p>In what order may the operations by the main memory occur? The only constraint is that it is not possible both for the <em>write</em> of <code>a</code> to precede the <em>read</em> of <code>a</code> and for the <em>write</em> of <code>b</code> to precede the <em>read</em> of <code>b</code>, because the causality arrows in the diagram would form a loop so that an action would have to precede itself, which is not allowed. Assuming that the optional <em>store</em> and <em>write</em> operations are to occur, there are three possible orderings in which the main memory might legitimately perform its operations. Let <code>ha</code> and <code>hb</code> be the working copies of <code>a</code> and <code>b</code> for the <code>hither</code> thread, let <code>ya</code> and <code>yb</code> be the working copies for the <code>yon</code> thread, and let <code>ma</code> and <code>mb</code> be the master copies in main memory. Initially <code>ma=1</code> and <code>mb=2</code>. Then the three possible orderings of operations and the resulting states are as follows:</p><ul><li><p><em>write</em> <code>a``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>read</em> <code>a</code>, <em>read</em> <code>b``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>write</em> <code>b</code> (then <code>ha=2</code>, <code>hb=2</code>, <code>ma=2</code>, <code>mb=2</code>, <code>ya=2</code>, <code>yb=2</code>)</p></li><li><p><em>read</em> <code>a``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>write</em> <code>a</code>, <em>write</em> <code>b``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>read</em> <code>b</code> (then <code>ha=1</code>, <code>hb=1</code>, <code>ma=1</code>, <code>mb=1</code>, <code>ya=1</code>, <code>yb=1</code>)</p></li><li><p><em>read</em> <code>a``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>write</em> <code>a</code>, <em>read</em> <code>b``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>write</em> <code>b</code> (then <code>ha=2</code>, <code>hb=2</code>, <code>ma=2</code>, <code>mb=1</code>, <code>ya=1</code>, <code>yb=1</code>)</p></li></ul><p>Thus, the net result might be that, in main memory, <code>b</code> is copied into <code>a</code>, <code>a</code> is copied into <code>b</code>, or the values of <code>a</code> and <code>b</code> are swapped; moreover, the working copies of the variables might or might not agree. It would be incorrect, of course, to assume that any one of these outcomes is more likely than another. This is one place in which the behavior of a program is necessarily timing-dependent.</p><p>Of course, an implementation might also choose not to perform the <em>store</em> and <em>write</em> operations, or only one of the two pairs, leading to yet other possible results.</p><p>Now suppose that we modify the example to use <code>synchronized</code> methods:</p><blockquote><p>class SynchSample {<br>    int a &#x3D; 1, b &#x3D; 2;<br>    synchronized void hither() {<br>        a &#x3D; b;<br>    }<br>    synchronized void yon()<br>        b &#x3D; a;<br>    }<br>}</p></blockquote><p>Let us again consider the thread that calls <code>hither</code>. According to the rules, this thread must perform a <em>lock</em> operation (on the instance of class <code>SynchSample</code> on which the <code>hither</code> method is being called) before the body of method <code>hither</code> is executed. This is followed by a <em>use</em> of <code>b</code> and then an <em>assign</em> of <code>a</code>. Finally, an <em>unlock</em> operation on that same instance of <code>SynchSample</code> must be performed after the body of method <code>hither</code> completes. That is the bare minimum required to execute a call to the method <code>hither</code>.</p><p>As before, a <em>load</em> of <code>b</code> is required, which in turn requires a preceding <em>read</em> operation for <code>b</code> by the main memory. Because the <em>load</em> follows the <em>lock</em> operation, the corresponding <em>read</em> must also follow the <em>lock</em> operation.</p><p>Because an <em>unlock</em> operation follows the <em>assign</em> of <code>a</code>, a <em>store</em> operation on <code>a</code> is mandatory, which in turn requires a following <em>write</em> operation for <code>a</code> by the main memory. The <em>write</em> must precede the <em>unlock</em> operation.</p><p>The situation for the thread that calls <code>yon</code> is similar, but with the roles of <code>a</code> and <code>b</code> exchanged.</p><p>The total set of operations may be pictured as follows:</p><p><img src="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.anc1.gif">  </p><p>The <em>lock</em> and <em>unlock</em> operations provide further constraints on the order of operations by the main memory; the <em>lock</em> operation by one thread cannot occur between the <em>lock</em> and <em>unlock</em> operations of the other thread. Moreover, the <em>unlock</em> operations require that the <em>store</em> and <em>write</em> operations occur. It follows that only two sequences are possible:</p><ul><li><p><em>write</em> <code>a``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>read</em> <code>a</code>, <em>read</em> <code>b``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>write</em> <code>b</code> (then <code>ha=2</code>, <code>hb=2</code>, <code>ma=2</code>, <code>mb=2</code>, <code>ya=2</code>, <code>yb=2</code>)</p></li><li><p><em>read</em> <code>a``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>write</em> <code>a</code>, <em>write</em> <code>b``![](https://docs.oracle.com/javase/specs/jvms/se6/html/chars/arrwrite.gif)</code><em>read</em> <code>b</code> (then <code>ha=1</code>, <code>hb=1</code>, <code>ma=1</code>, <code>mb=1</code>, <code>ya=1</code>, <code>yb=1</code>)</p></li></ul><p>While the resulting state is timing-dependent, it can be seen that the two threads will necessarily agree on the values of <code>a</code> and <code>b</code>.</p><hr><h2 id="8-11-Example-Out-of-Order-Writes"><a href="#8-11-Example-Out-of-Order-Writes" class="headerlink" title="8.11 Example: Out-of-Order Writes"></a>8.11 Example: Out-of-Order Writes</h2><p>This example is similar to that in the preceding section, except that one method assigns to both variables and the other method reads both variables. Consider a class that has class variables <code>a</code> and <code>b</code> and methods <code>to</code> and <code>fro</code>:</p><blockquote><p>class Simple {<br>    int a &#x3D; 1, b &#x3D; 2;<br>    void to() {<br>        a &#x3D; 3;<br>        b &#x3D; 4;<br>    }<br>    void fro()<br>        System.out.println(“a&#x3D; “ + a + “, b&#x3D;” + b);<br>    }<br>}</p></blockquote><p>Now suppose that two threads are created and that one thread calls <code>to</code> while the other thread calls <code>fro</code>. What is the required set of actions and what are the ordering constraints?</p><p>Let us consider the thread that calls <code>to</code>. According to the rules, this thread must perform an <em>assign</em> of <code>a</code> followed by an <em>assign</em> of <code>b</code>. That is the bare minimum required to execute a call to the method <code>to</code>. Because there is no synchronization, it is at the option of the implementation whether or not to <em>store</em> the assigned values back to main memory! Therefore, the thread that calls <code>fro</code> may obtain either <code>1</code> or <code>3</code> for the value of <code>a</code> and independently may obtain either <code>2</code> or <code>4</code> for the value of <code>b</code>.</p><p>Now suppose that <code>to</code> is <code>synchronized</code> but <code>fro</code> is not:</p><blockquote><p>class SynchSimple {<br>    int a &#x3D; 1, b &#x3D; 2;<br>    synchronized void to() {<br>        a &#x3D; 3;<br>        b &#x3D; 4;<br>    }<br>    void fro()<br>        System.out.println(“a&#x3D; “ + a + “, b&#x3D;” + b);<br>    }<br>}</p></blockquote><p>In this case the method <code>to</code> will be forced to <em>store</em> the assigned values back to main memory before the <em>unlock</em> operation at the end of the method. The method <code>fro</code> must, of course, use <code>a</code> and <code>b</code> (in that order) and so must <em>load</em> values for <code>a</code> and <code>b</code> from main memory.</p><p>The total set of operations may be pictured as follows:  </p><p><img src="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.anc2.gif">  </p><p>Here an arrow from action <em>A</em> to action <em>B</em> indicates that <em>A</em> must precede <em>B</em>.</p><p>In what order may the operations by the main memory occur? Note that the rules do not require that <em>write</em> <code>a</code> occur before <em>write</em> <code>b</code>; neither do they require that <em>read</em> <code>a</code> occur before <em>read</em> <code>b</code>. Also, even though method <code>to</code> is synchronized, method <code>fro</code> is not synchronized, so there is nothing to prevent the <em>read</em> operations from occurring between the <em>lock</em> and <em>unlock</em> operations. (The point is that declaring one method <code>synchronized</code> does not of itself make that method behave as if it were atomic.)</p><p>As a result, the method <code>fro</code> could still obtain either <code>1</code> or <code>3</code> for the value of <code>a</code> and independently could obtain either <code>2</code> or <code>4</code> for the value of <code>b</code>. In particular, <code>fro</code> might observe the value <code>1</code> for <code>a</code> and <code>4</code> for <code>b</code>. Thus, even though <code>to</code> does an <em>assign</em> to <code>a</code> and then an <em>assign</em> to <code>b</code>, the <em>write</em> operations to main memory may be observed by another thread to occur as if in the opposite order. </p><p>Finally, suppose that <code>to</code> and <code>fro</code> are both <code>synchronized</code>:</p><blockquote><p>class SynchSynchSimple {<br>    int a &#x3D; 1, b &#x3D; 2;<br>    synchronized void to() {<br>        a &#x3D; 3;<br>        b &#x3D; 4;<br>    }<br>    synchronized void fro()<br>        System.out.println(“a&#x3D; “ + a + “, b&#x3D;” + b);<br>    }<br>}</p></blockquote><p>In this case, the actions of method <code>fro</code> cannot be interleaved with the actions of method <code>to</code>, and so <code>fro</code> will print either “<code>a=1, b=2</code>“ or “<code>a=3, b=4</code>“.</p><hr><h2 id="8-12-Threads"><a href="#8-12-Threads" class="headerlink" title="8.12 Threads"></a>8.12 Threads</h2><p>Threads are created and managed by the classes <code>Thread</code> and <code>ThreadGroup</code>. Creating a <code>Thread</code> object creates a thread, and that is the only way to create a thread. When the thread is created, it is not yet active; it begins to run when its <code>start</code> method is called.</p><hr><h2 id="8-13-Locks-and-Synchronization"><a href="#8-13-Locks-and-Synchronization" class="headerlink" title="8.13 Locks and Synchronization"></a>8.13 Locks and Synchronization</h2><p>There is a lock associated with every object. The Java programming language does not provide a way to perform separate <em>lock</em> and <em>unlock</em> operations; instead, they are implicitly performed by high-level constructs that always arrange to pair such operations correctly. (The Java virtual machine, however, provides separate <em>monitorenter</em> and <em>monitorexit</em> instructions that implement the <em>lock</em> and <em>unlock</em> operations.)</p><p>The <code>synchronized</code> statement computes a reference to an object; it then attempts to perform a <em>lock</em> operation on that object and does not proceed further until the <em>lock</em> operation has successfully completed. (A <em>lock</em> operation may be delayed because the rules about locks can prevent the main memory from participating until some other thread is ready to perform one or more <em>unlock</em> operations.) After the lock operation has been performed, the body of the <code>synchronized</code> statement is executed. Normally, a compiler for the Java programming language ensures that the <em>lock</em> operation implemented by a <em>monitorenter</em> instruction executed prior to the execution of the body of the <code>synchronized</code> statement is matched by an unlock operation implemented by a <em>monitorexit</em> instruction whenever the <code>synchronized</code> statement completes, whether completion is normal or abrupt.</p><p>A <code>synchronized</code> method automatically performs a <em>lock</em> operation when it is invoked; its body is not executed until the <em>lock</em> operation has successfully completed. If the method is an instance method, it locks the lock associated with the instance for which it was invoked (that is, the object that will be known as <code>this</code> during execution of the method’s body). If the method is <code>static</code>, it locks the lock associated with the <code>Class</code> object that represents the class in which the method is defined. If execution of the method’s body is ever completed, either normally or abruptly, an <em>unlock</em> operation is automatically performed on that same lock.</p><p>Best practice is that if a variable is ever to be assigned by one thread and used or assigned by another, then all accesses to that variable should be enclosed in <code>synchronized</code> methods or <code>synchronized</code> statements.</p><p>Although a compiler for the Java programming language normally guarantees structured use of locks (see <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Compiling.doc.html#6530">Section 7.14, “Synchronization”</a>), there is no assurance that all code submitted to the Java virtual machine will obey this property. Implementations of the Java virtual machine are permitted but not required to enforce both of the following two rules guaranteeing structured locking.</p><p>Let <em>T</em> be a thread and <em>L</em> be a lock. Then:</p><ol start="2"><li><p>The number of <em>lock</em> operations performed by <em>T</em> on <em>L</em> during a method invocation must equal the number of <em>unlock</em> operations performed by <em>T</em> on <em>L</em> during the method invocation whether the method invocation completes normally or abruptly. </p></li><li><p>At no point during a method invocation may the number of <em>unlock</em> operations performed by <em>T</em> on <em>L</em> since the method invocation exceed the number of <em>lock</em> operations performed by <em>T</em> on <em>L</em> since the method invocation.</p></li></ol><p>In less formal terms, during a method invocation every <em>unlock</em> operation on <em>L</em> must match some preceding <em>lock</em> operation on <em>L</em>. </p><p>Note that the locking and unlocking automatically performed by the Java virtual machine when invoking a synchronized method are considered to occur during the calling method’s invocation.</p><hr><h2 id="8-14-Wait-Sets-and-Notification"><a href="#8-14-Wait-Sets-and-Notification" class="headerlink" title="8.14 Wait Sets and Notification"></a>8.14 Wait Sets and Notification</h2><p>Every object, in addition to having an associated lock, has an associated wait set, which is a set of threads. When an object is first created, its wait set is empty.</p><p>Wait sets are used by the methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> of class <code>Object</code>. These methods also interact with the scheduling mechanism for threads.</p><p>The method <code>wait</code> should be invoked for an object only when the current thread (call it <em>T</em>  ) has already locked the object’s lock. Suppose that thread <em>T</em> has in fact performed <em>N</em> <em>lock</em> operations on the object that have not been matched by <em>unlock</em> operations on that same object. The <code>wait</code> method then adds the current thread to the wait set for the object, disables the current thread for thread scheduling purposes, and performs <em>N</em> <em>unlock</em> operations on the object to relinquish the lock on it. Locks having been locked by thread <em>T</em> on objects other than the one <em>T</em> is to wait on are not relinquished. The thread <em>T</em> then lies dormant until one of three things happens:</p><ul><li><p>Some other thread invokes the <code>notify</code> method for that object, and thread <em>T</em> happens to be the one arbitrarily chosen as the one to notify.</p></li><li><p>Some other thread invokes the <code>notifyAll</code> method for that object.</p></li><li><p>If the call by thread <em>T</em> to the <code>wait</code> method specified a time-out interval, then the specified amount of real time elapses.</p></li></ul><p>The thread <em>T</em> is then removed from the wait set and reenabled for thread scheduling. It then locks the object again (which may involve competing in the usual manner with other threads); once it has gained control of the lock, it performs <em>N</em> - <em>1</em> additional <em>lock</em> operations on that same object and then returns from the invocation of the <code>wait</code> method. Thus, on return from the <code>wait</code> method, the state of the object’s lock is exactly as it was when the <code>wait</code> method was invoked.</p><p>The <code>notify</code> method should be invoked for an object only when the current thread has already locked the object’s lock, or an <code>IllegalMonitorStateException</code> will be thrown. If the wait set for the object is not empty, then some arbitrarily chosen thread is removed from the wait set and reenabled for thread scheduling. (Of course, that thread will not be able to proceed until the current thread relinquishes the object’s lock.)</p><p>The <code>notifyAll</code> method should be invoked for an object only when the current thread has already locked the object’s lock, or an <code>IllegalMonitorStateException</code> will be thrown. Every thread in the wait set for the object is removed from the wait set and reenabled for thread scheduling. (Those threads will not be able to proceed until the current thread relinquishes the object’s lock.)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 官方文档翻译 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-spec-3. Compiling for the Java Virtual Machine</title>
      <link href="/2022/09/02/jvm-spec-3.%20Compiling%20for%20the%20Java%20Virtual%20Machine/"/>
      <url>/2022/09/02/jvm-spec-3.%20Compiling%20for%20the%20Java%20Virtual%20Machine/</url>
      
        <content type="html"><![CDATA[<p>The Java Virtual Machine machine is designed to support the Java programming language. Oracle’s JDK software contains a compiler from source code written in the Java programming language to the instruction set of the Java Virtual Machine, and a run-time system that implements the Java Virtual Machine itself. Understanding how one compiler utilizes the Java Virtual Machine is useful to the prospective compiler writer, as well as to one trying to understand the Java Virtual Machine itself. The numbered sections in this chapter are not normative.</p><p>Java虚拟机（Java Virtual Machine，JVM）的设计是为了支持Java编程语言。Oracle的JDK软件包含一个编译器，它将用Java编程语言编写的源代码编译成JVM的指令集，并且JDK中还包含一个实现JVM的运行时系统。了解一个编译器如何利用JVM，对于未来的编译器编写者以及试图理解JVM本身的人都是有帮助的。本章中编号的章节不是规范性的。</p><p>Note that the term “compiler” is sometimes used when referring to a translator from the instruction set of a Java Virtual Machine to the instruction set of a specific CPU. One example of such a translator is a just-in-time (JIT) code generator, which generates platform-specific instructions only after Java Virtual Machine code has been loaded. This chapter does not address issues associated with code generation, only those associated with compiling source code written in the Java programming language to Java Virtual Machine instructions.</p><p>需要注意的是，“编译器”一词有时也用来指从Java虚拟机指令集到特定CPU指令集的翻译器。此类翻译器的一个例子是即时编译器（JIT，Just-In-Time）代码生成器，它只在Java虚拟机代码被加载后生成平台特定的指令。本章不讨论与代码生成相关的问题，仅讨论将用Java编程语言编写的源代码编译为Java虚拟机指令时涉及的问题。</p><hr><h2 id="3-1-Format-of-Examples"><a href="#3-1-Format-of-Examples" class="headerlink" title="3.1 Format of Examples"></a>3.1 Format of Examples</h2><p>This chapter consists mainly of examples of source code together with annotated listings of the Java Virtual Machine code that the javac compiler in Oracle’s JDK release 1.0.2 generates for the examples. The Java Virtual Machine code is written in the informal “virtual machine assembly language” output by Oracle’s javap utility, distributed with the JDK release. You can use javap to generate additional examples of compiled methods.</p><p>本章主要由源代码示例以及Oracle JDK 1.0.2版本中的<code>javac</code>编译器为这些示例生成的Java虚拟机代码的带注释列表组成。Java虚拟机代码以非正式的“虚拟机汇编语言”编写，这种语言由Oracle的<code>javap</code>工具输出，该工具与JDK发行版一起分发。你可以使用<code>javap</code>生成编译方法的其他示例。</p><p>The format of the examples should be familiar to anyone who has read assembly code. Each instruction takes the form:</p><p>示例的格式对于读过汇编代码的人来说应该是熟悉的。每条指令的形式如下：</p><pre><code class="hljs plaintext">&lt;index&gt; &lt;opcode&gt; [ &lt;operand1&gt; [ &lt;operand2&gt;... ]] [&lt;comment&gt;]</code></pre><p>The &lt;index&gt; is the index of the opcode of the instruction in the array that contains the bytes of Java Virtual Machine code for this method. Alternatively, the &lt;index&gt; may be thought of as a byte offset from the beginning of the method. The &lt;opcode&gt; is the mnemonic for the instruction’s opcode, and the zero or more &lt;operandN&gt; are the operands of the instruction. The optional &lt;comment&gt; is given in end-of-line comment syntax:</p><p>&lt;index&gt; 是指令在包含该方法的Java虚拟机代码字节数组中的索引。或者说，&lt;index&gt; 可以被视为从方法起始处开始的字节偏移量。&lt;opcode&gt; 是指令的操作码的助记符，而一个或多个&lt;operandN&gt; 是该指令的操作数。可选的 &lt;comment&gt; 以行尾注释的语法给出：</p><pre><code class="hljs plaintext">8 bipush 100 // Push int constant 100</code></pre><p>Some of the material in the comments is emitted by javap; the rest is supplied by the authors. The &lt;index&gt; prefacing each instruction may be used as the target of a control transfer instruction. For instance, a goto 8 instruction transfers control to the instruction at index 8. Note that the actual operands of Java Virtual Machine control transfer instructions are offsets from the addresses of the opcodes of those instructions; these operands are displayed by javap (and are shown in this chapter) as more easily read offsets into their methods.</p><p>注释中的部分内容由<code>javap</code>输出，其他内容则由作者提供。前置于每条指令的&lt;index&gt;可以作为控制转移指令的目标。例如，goto 8指令会将控制转移到索引为8的指令处。需要注意的是，Java虚拟机控制转移指令的实际操作数是从这些指令的操作码地址起的偏移量；这些操作数由<code>javap</code>显示（也在本章中显示）为更易读的方法偏移量。</p><p>We preface an operand representing a run-time constant pool index with a hash sign and follow the instruction by a comment identifying the run-time constant pool item referenced, as in:</p><p>我们在表示运行时常量池索引的操作数前加上井号，并在指令后面附上一个注释，用以标识引用的运行时常量池项，例如：</p><pre><code class="hljs plaintext">10 ldc #1 // Push float constant 100.0</code></pre><pre><code class="hljs plaintext">9 invokevirtual #4 // Method Example.addTwo(II)I</code></pre><p>For the purposes of this chapter, we do not worry about specifying details such as operand sizes.</p><p>出于本章的目的，我们不必关心指定操作数大小等细节。</p><h2 id="3-2-Use-of-Constants-Local-Variables-and-Control-Constructs"><a href="#3-2-Use-of-Constants-Local-Variables-and-Control-Constructs" class="headerlink" title="3.2 Use of Constants, Local Variables, and Control Constructs"></a>3.2 Use of Constants, Local Variables, and Control Constructs</h2><p>Java Virtual Machine code exhibits a set of general characteristics imposed by the Java Virtual Machine’s design and use of types. In the first example we encounter many of these, and we consider them in some detail.</p><p>Java虚拟机代码表现出一组由Java虚拟机的设计和类型使用所决定的一般特性。在第一个示例中，我们会遇到许多这样的特性，并会详细讨论它们。</p><p>The spin method simply spins around an empty for loop 100 times:</p><p><code>spin</code>方法简单地在一个空的<code>for</code>循环中运行100次：</p><hr><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">spin</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;        ; <span class="hljs-comment">// Loop body is empty</span>    &#125;&#125;</code></pre><p>A compiler might compile spin to:</p><p>编译器可能会将<code>spin</code>编译为：</p><pre><code class="hljs plaintext">0 iconst_0       // Push int constant 01 istore_1       // Store into local variable 1 (i=0)2 goto 8         // First time through don&#x27;t increment5 iinc 1 1       // Increment local variable 1 by 1 (i++)8 iload_1        // Push local variable 1 (i)9 bipush 100     // Push int constant 10011 if_icmplt 5   // Compare and loop if less than (i &lt; 100)14 return        // Return void when done</code></pre><p>The Java Virtual Machine is stack-oriented, with most operations taking one or more operands from the operand stack of the Java Virtual Machine’s current frame or pushing results back onto the operand stack. A new frame is created each time a method is invoked, and with it is created a new operand stack and set of local variables for use by that method (§2.6). At any one point of the computation, there are thus likely to be many frames and equally many operand stacks per thread of control, corresponding to many nested method invocations. Only the operand stack in the current frame is active.</p><p>Java虚拟机是基于栈的，大多数操作从当前栈帧的操作数栈中获取一个或多个操作数，或者将结果推回到操作数栈。每次调用方法时都会创建一个新的栈帧，同时为该方法创建一个新的操作数栈和一组本地变量。在计算的任何一点上，控制线程通常会有许多栈帧和同样多的操作数栈，对应于许多嵌套的方法调用。只有当前栈帧中的操作数栈是活动的。</p><p>The instruction set of the Java Virtual Machine distinguishes operand types by using distinct bytecodes for operations on its various data types. The method spin operates only on values of type int. The instructions in its compiled code chosen to operate on typed data (iconst_0, istore_1, iinc, iload_1, if_icmplt) are all specialized for type int.</p><p>Java虚拟机的指令集通过使用不同的数据类型操作的字节码来区分操作数类型。<code>spin</code>方法仅处理<code>int</code>类型的值。其编译代码中的指令（如<code>iconst_0</code>、<code>istore_1</code>、<code>iinc</code>、<code>iload_1</code>、<code>if_icmplt</code>）都是专门为<code>int</code>类型定制的。</p><p>The two constants in spin, 0 and 100, are pushed onto the operand stack using two different instructions. The 0 is pushed using an iconst_0 instruction, one of the family of iconst_&lt;i&gt; instructions. The 100 is pushed using a bipush instruction, which fetches the value it pushes as an immediate operand.</p><p><code>spin</code>中的两个常量0和100使用了两种不同的指令将它们推送到操作数栈中。0使用<code>iconst_0</code>指令推送，它属于<code>iconst_&lt;i&gt;</code>指令家族。100则使用<code>bipush</code>指令推送，这个指令将值作为立即数操作数获取并推送。</p><p>The Java Virtual Machine frequently takes advantage of the likelihood of certain operands (int constants -1, 0, 1, 2, 3, 4 and 5 in the case of the iconst_&lt;i&gt; instructions) by making those operands implicit in the opcode. Because the iconst_0 instruction knows it is going to push an int 0, iconst_0 does not need to store an operand to tell it what value to push, nor does it need to fetch or decode an operand. Compiling the push of 0 as bipush 0 would have been correct, but would have made the compiled code for spin one byte longer. A simple virtual machine would have also spent additional time fetching and decoding the explicit operand each time around the loop. Use of implicit operands makes compiled code more compact and efficient.</p><p>Java虚拟机经常利用某些操作数的可能性（例如<code>iconst_&lt;i&gt;</code>指令中的<code>int</code>常量-1、0、1、2、3、4和5），通过使这些操作数在操作码中隐含，从而优化性能。由于<code>iconst_0</code>指令知道它将推送一个<code>int 0</code>，因此<code>iconst_0</code>不需要存储操作数来指示它要推送的值，也不需要获取或解码操作数。将推送0编译为<code>bipush 0</code>虽然是正确的，但会使<code>spin</code>的编译代码增加一个字节长度。一个简单的虚拟机在每次循环时也会花费额外的时间来获取和解码显式操作数。使用隐式操作数可以使编译后的代码更加紧凑和高效。</p><p>The int i in spin is stored as Java Virtual Machine local variable 1. Because most Java Virtual Machine instructions operate on values popped from the operand stack rather than directly on local variables, instructions that transfer values between local variables and the operand stack are common in code compiled for the Java Virtual Machine. These operations also have special support in the instruction set. In spin, values are transferred to and from local variables using the istore_1 and iload_1 instructions, each of which implicitly operates on local variable 1. The istore_1 instruction pops an int from the operand stack and stores it in local variable 1. The iload_1 instruction pushes the value in local variable 1 on to the operand stack.</p><p><code>spin</code>中的<code>int i</code>被存储为Java虚拟机的本地变量1。由于大多数Java虚拟机指令在操作数栈中弹出值进行操作，而不是直接对本地变量进行操作，因此在为Java虚拟机编译的代码中，值在本地变量和操作数栈之间传递的指令是很常见的。这些操作在指令集中也得到了特殊支持。在<code>spin</code>中，值通过<code>istore_1</code>和<code>iload_1</code>指令在本地变量和操作数栈之间传递，每条指令都隐式地操作本地变量1。<code>istore_1</code>指令从操作数栈中弹出一个<code>int</code>并将其存储在本地变量1中。<code>iload_1</code>指令则将本地变量1中的值推送到操作数栈上。</p><p>The use (and reuse) of local variables is the responsibility of the compiler writer. The specialized load and store instructions should encourage the compiler writer to reuse local variables as much as is feasible. The resulting code is faster, more compact, and uses less space in the frame.</p><p>本地变量的使用（以及重用）是编译器编写者的责任。专用的加载和存储指令应鼓励编译器编写者尽可能多地重用本地变量。这样产生的代码速度更快、更紧凑，并且在栈帧中占用更少的空间。</p><p>Certain very frequent operations on local variables are catered to specially by the Java Virtual Machine. The iinc instruction increments the contents of a local variable by a one-byte signed value. The iinc instruction in spin increments the first local variable (its first operand) by 1 (its second operand). The iinc instruction is very handy when implementing looping constructs.</p><p>Java虚拟机特别支持某些非常频繁的本地变量操作。<code>iinc</code>指令通过一个字节的有符号值增加本地变量的内容。<code>spin</code>中的<code>iinc</code>指令将第一个本地变量（其第一个操作数）增加1（其第二个操作数）。<code>iinc</code>指令在实现循环结构时非常方便。</p><p>The for loop of spin is accomplished mainly by these instructions:</p><p><code>spin</code>的<code>for</code>循环主要通过以下指令实现：</p><pre><code class="hljs asm">5  iinc 1 1        // Increment local variable 1 by 1 (i++)8  iload_1         // Push local variable 1 (i)9  bipush 100      // Push int constant 10011 if_icmplt 5     // Compare and loop if less than (i &lt; 100)</code></pre><p>The bipush instruction pushes the value 100 onto the operand stack as an int, then the if_icmplt instruction pops that value off the operand stack and compares it against i. If the comparison succeeds (the variable i is less than 100), control is transferred to index 5 and the next iteration of the for loop begins. Otherwise, control passes to the instruction following the if_icmplt.</p><p><code>bipush</code>指令将值100作为<code>int</code>推送到操作数栈上，然后<code>if_icmplt</code>指令将该值从操作数栈中弹出并与<code>i</code>进行比较。如果比较成功（变量<code>i</code>小于100），控制转移到索引5，并开始<code>for</code>循环的下一次迭代。否则，控制转移到<code>if_icmplt</code>之后的指令。</p><p>If the spin example had used a data type other than int for the loop counter, the compiled code would necessarily change to reflect the different data type. For instance, if instead of an int the spin example uses a double, as shown:</p><p>如果<code>spin</code>示例为循环计数器使用了<code>int</code>以外的数据类型，则编译后的代码必然会改变以反映不同的数据类型。例如，如果将<code>spin</code>示例中的<code>int</code>替换为<code>double</code>，如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dspin</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">double</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0.0</span>; i &lt; <span class="hljs-number">100.0</span>; i++) &#123;        ; <span class="hljs-comment">// Loop body is empty</span>    &#125;&#125;</code></pre><p>the compiled code is:</p><p>编译后的代码为：</p><pre><code class="hljs asm">0  dconst_0      // Push double constant 0.01  dstore_1      // Store into local variables 1 and 22  goto 9        // First time through don&#x27;t increment5  dload_1       // Push local variables 1 and 26  dconst_1      // Push double constant 1.07  dadd          // Add; there is no dinc instruction8  dstore_1      // Store result in local variables 1 and 29  dload_1       // Push local variables 1 and 210 ldc2_w #4     // Push double constant 100.013 dcmpg         // There is no if_dcmplt instruction14 iflt 5        // Compare and loop if less than (i &lt; 100.0)17 return        // Return void when done</code></pre><p>The instructions that operate on typed data are now specialized for type double. (The ldc2_w instruction will be discussed later in this chapter.)</p><p>现在操作类型化数据的指令专门用于<code>double</code>类型。（<code>ldc2_w</code>指令将在本章稍后讨论。）</p><p>Recall that double values occupy two local variables, although they are only accessed using the lesser index of the two local variables. This is also the case for values of type long. Again for example,</p><p>请记住，<code>double</code>值占用两个本地变量，尽管它们只使用两个本地变量中较小的索引进行访问。对于<code>long</code>类型的值也是如此。再例如，</p><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-title function_">doubleLocals</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span> &#123;    <span class="hljs-keyword">return</span> d1 + d2;&#125;</code></pre><p>becomes<br>编译后为</p><pre><code class="hljs plaintext">0 dload_1 // First argument in local variables 1 and 21 dload_3 // Second argument in local variables 3 and 42 dadd3 dreturn</code></pre><p>Note that local variables of the local variable pairs used to store double values in doubleLocals must never be manipulated individually.</p><p>请注意，用于在<code>doubleLocals</code>中存储<code>double</code>值的本地变量对中的本地变量，绝不能单独操作。</p><p>The Java Virtual Machine’s opcode size of 1 byte results in its compiled code being very compact. However, 1-byte opcodes also mean that the Java Virtual Machine instruction set must stay small. As a compromise, the Java Virtual Machine does not provide equal support for all data types: it is not completely orthogonal (Table 2.11.1-A).</p><p>Java虚拟机的操作码大小为1字节，这使得其编译后的代码非常紧凑。然而，1字节的操作码也意味着Java虚拟机指令集必须保持较小的规模。作为一种妥协，Java虚拟机并未对所有数据类型提供相同的支持：它并非完全正交（参见表2.11.1-A）。</p><p>For example, the comparison of values of type int in the for statement of example spin can be implemented using a single if_icmplt instruction; however, there is no single instruction in the Java Virtual Machine instruction set that performs a conditional branch on values of type double. Thus, dspin must implement its comparison of values of type double using a dcmpg instruction followed by an iflt instruction.</p><p>例如，在<code>spin</code>示例的<code>for</code>语句中，对<code>int</code>类型值的比较可以使用单个<code>if_icmplt</code>指令来实现；然而，在Java虚拟机指令集中没有单个指令可以对<code>double</code>类型的值执行条件分支。因此，<code>dspin</code>必须使用<code>dcmpg</code>指令，然后跟随<code>iflt</code>指令来实现对<code>double</code>类型值的比较。</p><p>The Java Virtual Machine provides the most direct support for data of type int. This is partly in anticipation of efficient implementations of the Java Virtual Machine’s operand stacks and local variable arrays. It is also motivated by the frequency of int data in typical programs. Other integral types have less direct support. There are no byte, char, or short versions of the store, load, or add instructions, for instance. Here is the spin example written using a short:</p><p>Java虚拟机为<code>int</code>类型的数据提供了最直接的支持。这部分是为了预期Java虚拟机操作数栈和本地变量数组的高效实现。它也是由于在典型程序中<code>int</code>数据的频繁使用。其他整数类型的支持则较少。例如，没有<code>byte</code>、<code>char</code>或<code>short</code>版本的存储、加载或添加指令。以下是使用<code>short</code>编写的<code>spin</code>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sspin</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">short</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;        ; <span class="hljs-comment">// Loop body is empty</span>    &#125;&#125;</code></pre><p>It must be compiled for the Java Virtual Machine, as follows, using instructions operating on another type, most likely int, converting between short and int values as necessary to ensure that the results of operations on short data stay within the appropriate range:</p><p>它必须为Java虚拟机编译，如下所示，使用在另一种类型（最可能是<code>int</code>）上操作的指令，在<code>short</code>和<code>int</code>值之间进行转换，以确保对<code>short</code>数据的操作结果保持在适当的范围内：</p><pre><code class="hljs plaintext">0  iconst_01  istore_12  goto 105  iload_16  iconst_17  iadd8  i2s9  istore_110 iload_111 bipush 10013 if_icmplt 516 return</code></pre><p>The lack of direct support for byte, char, and short types in the Java Virtual Machine is not particularly painful, because values of those types are internally promoted to int (byte and short are sign-extended to int, char is zero-extended). Operations on byte, char, and short data can thus be done using int instructions. The only additional cost is that of truncating the values of int operations to valid ranges.</p><p>Java虚拟机对<code>byte</code>、<code>char</code>和<code>short</code>类型缺乏直接支持并不是特别麻烦，因为这些类型的值在内部被提升为<code>int</code>（<code>byte</code>和<code>short</code>被符号扩展为<code>int</code>，<code>char</code>被零扩展）。因此，对<code>byte</code>、<code>char</code>和<code>short</code>数据的操作可以使用<code>int</code>指令进行。唯一的额外成本是将<code>int</code>操作的值截断为有效范围。</p><p>The long and floating-point types have an intermediate level of support in the Java Virtual Machine, lacking only the full complement of conditional control transfer instructions.</p><p><code>long</code>和浮点类型在Java虚拟机中具有中级支持，仅缺少完整的条件控制转移指令集。</p><hr><h2 id="3-3-Arithmetic"><a href="#3-3-Arithmetic" class="headerlink" title="3.3 Arithmetic"></a>3.3 Arithmetic</h2><p>The Java Virtual Machine generally does arithmetic on its operand stack. (The exception is the iinc instruction, which directly increments the value of a local variable.) For instance, the align2grain method aligns an int value to a given power of 2:</p><p>Java虚拟机通常在其操作数栈上进行算术运算。（例外情况是<code>iinc</code>指令，它直接增加本地变量的值。）例如，<code>align2grain</code>方法将一个<code>int</code>值对齐到一个给定的2的幂次方：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">align2grain</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> grain)</span> &#123;    <span class="hljs-keyword">return</span> ((i + grain-<span class="hljs-number">1</span>) &amp; ~(grain-<span class="hljs-number">1</span>));&#125;</code></pre><p>Operands for arithmetic operations are popped from the operand stack, and the results of operations are pushed back onto the operand stack. Results of arithmetic subcomputations can thus be made available as operands of their nesting computation. For instance, the calculation of ~(grain-1) is handled by these instructions:</p><p>算术运算的操作数从操作数栈中弹出，运算结果被推回到操作数栈上。因此，算术子计算的结果可以作为嵌套计算的操作数使用。例如，<code>~(grain-1)</code>的计算由以下指令处理：</p><pre><code class="hljs asm">5 iload_2    // Push grain6 iconst_1   // Push int constant 17 isub       // Subtract; push result8 iconst_m1  // Push int constant -19 ixor       // Do XOR; push result</code></pre><p>First grain-1 is calculated using the contents of local variable 2 and an immediate int value 1. These operands are popped from the operand stack and their difference pushed back onto the operand stack. The difference is thus immediately available for use as one operand of the ixor instruction. (Recall that ~x &#x3D;&#x3D; -1^x.) Similarly, the result of the ixor instruction becomes an operand for the subsequent iand instruction.</p><p>首先使用本地变量2的内容和立即数<code>int</code>值1计算<code>grain-1</code>。这些操作数从操作数栈中弹出，它们的差值被推回到操作数栈上。因此，这个差值可以立即作为<code>ixor</code>指令的一个操作数使用。（回忆一下，<code>~x == -1^x</code>。）类似地，<code>ixor</code>指令的结果成为后续<code>iand</code>指令的一个操作数。</p><p>The code for the entire method follows:</p><p>整个方法的代码如下：</p><pre><code class="hljs asm">Method int align2grain(int,int)0  iload_11  iload_22  iadd3  iconst_14  isub5  iload_26  iconst_17  isub8  iconst_m19  ixor10 iand11 ireturn</code></pre><hr><h2 id="3-4-Accessing-the-Run-Time-Constant-Pool"><a href="#3-4-Accessing-the-Run-Time-Constant-Pool" class="headerlink" title="3.4 Accessing the Run-Time Constant Pool"></a>3.4 Accessing the Run-Time Constant Pool</h2><p>Many numeric constants, as well as objects, fields, and methods, are accessed via the run-time constant pool of the current class. Object access is considered later (§3.8). Data of types int, long, float, and double, as well as references to instances of class String, are managed using the ldc, ldc_w, and ldc2_w instructions.</p><p>许多数值常量、对象、字段和方法都是通过当前类的运行时常量池访问的。对象访问将在后面讨论（§3.8）。<code>int</code>、<code>long</code>、<code>float</code>和<code>double</code>类型的数据以及对<code>String</code>类实例的引用都是使用<code>ldc</code>、<code>ldc_w</code>和<code>ldc2_w</code>指令管理的。</p><p>The ldc and ldc_w instructions are used to access values in the run-time constant pool (including instances of class String) of types other than double and long. The ldc_w instruction is used in place of ldc only when there is a large number of run-time constant pool items and a larger index is needed to access an item. The ldc2_w instruction is used to access all values of types double and long; there is no non-wide variant.</p><p><code>ldc</code>和<code>ldc_w</code>指令用于访问运行时常量池中的值（包括<code>String</code>类实例），这些值的类型不是<code>double</code>和<code>long</code>。仅当运行时常量池项数量较多且需要较大的索引来访问某个项时，才使用<code>ldc_w</code>代替<code>ldc</code>。<code>ldc2_w</code>指令用于访问<code>double</code>和<code>long</code>类型的所有值；没有非宽版的变体。</p><p>Integral constants of types byte, char, or short, as well as small int values, may be compiled using the bipush, sipush, or iconst_&lt;i&gt; instructions (§3.2). Certain small floating-point constants may be compiled using the fconst_&lt;f&gt; and dconst_&lt;d&gt; instructions.</p><p><code>byte</code>、<code>char</code>或<code>short</code>类型的整数常量以及小的<code>int</code>值可以使用<code>bipush</code>、<code>sipush</code>或<code>iconst_&lt;i&gt;</code>指令编译（§3.2）。某些小的浮点数常量可以使用<code>fconst_&lt;f&gt;</code>和<code>dconst_&lt;d&gt;</code>指令编译。</p><p>In all of these cases, compilation is straightforward. For instance, the constants for:</p><p>在所有这些情况下，编译都是直接的。例如，以下方法的常量：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">useManyNumeric</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xffffffff</span>;    <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.2</span>;    ...<span class="hljs-keyword">do</span> some calculations...&#125;</code></pre><p>are set up as follows:</p><p>被设置如下：</p><pre><code class="hljs plaintext">Method void useManyNumeric()0  bipush 100    // Push small int constant with bipush2  istore_13  ldc #1        // Push large int constant (1000000) with ldc5  istore_26  lconst_1      // A tiny long value uses small fast lconst_17  lstore_38  ldc2_w #6     // Push long 0xffffffff (that is, an int -1)11 lstore 513 ldc2_w #8    // Push double constant 2.20000016 dstore 7...do those calculations...</code></pre><hr><h2 id="3-5-More-Control-Examples"><a href="#3-5-More-Control-Examples" class="headerlink" title="3.5 More Control Examples"></a>3.5 More Control Examples</h2><p>Compilation of for statements was shown in an earlier section (§3.2). Most of the Java programming language’s other control constructs (if-then-else, do, while, break, and continue) are also compiled in the obvious ways. The compilation of switch statements is handled in a separate section (§3.10), as are the compilation of exceptions (§3.12) and the compilation of finally clauses (§3.13).</p><p>前面章节（§3.2）展示了<code>for</code>语句的编译。Java编程语言的大多数其他控制结构（如<code>if-then-else</code>、<code>do</code>、<code>while</code>、<code>break</code>和<code>continue</code>）也以显而易见的方式编译。<code>switch</code>语句的编译将在单独的章节中讨论（§3.10），异常的编译（§3.12）和<code>finally</code>子句的编译（§3.13）也将分别处理。</p><p>As a further example, a while loop is compiled in an obvious way, although the specific control transfer instructions made available by the Java Virtual Machine vary by data type. As usual, there is more support for data of type int, for example:</p><p>作为进一步的示例，<code>while</code>循环以显而易见的方式编译，尽管Java虚拟机提供的特定控制转移指令因数据类型而异。通常情况下，<code>int</code>类型的数据支持更多，例如：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">whileInt</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) &#123;        i++;    &#125;&#125;</code></pre><p>is compiled to:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method void whileInt()0 iconst_01 istore_12 goto 85 iinc 1 18 iload_19 bipush 10011 if_icmplt 514 return</code></pre><p>Note that the test of the while statement (implemented using the if_icmplt instruction) is at the bottom of the Java Virtual Machine code for the loop. (This was also the case in the spin examples earlier.) The test being at the bottom of the loop forces the use of a goto instruction to get to the test prior to the first iteration of the loop. If that test fails, and the loop body is never entered, this extra instruction is wasted. However, while loops are typically used when their body is expected to be run, often for many iterations. For subsequent iterations, putting the test at the bottom of the loop saves a Java Virtual Machine instruction each time around the loop: if the test were at the top of the loop, the loop body would need a trailing goto instruction to get back to the top.</p><p>请注意，<code>while</code>语句的测试（使用<code>if_icmplt</code>指令实现）位于循环的Java虚拟机代码的底部。（在前面的<code>spin</code>示例中也是如此。）测试位于循环的底部，这迫使使用<code>goto</code>指令在循环的第一次迭代之前进入测试。如果测试失败，并且从未进入循环体，那么这条额外的指令将被浪费。然而，<code>while</code>循环通常在预计其循环体会运行时使用，通常是多次迭代。在后续的迭代中，将测试放在循环底部可以每次循环节省一个Java虚拟机指令：如果测试位于循环顶部，则循环体需要一个尾随<code>goto</code>指令来返回顶部。</p><p>Control constructs involving other data types are compiled in similar ways, but must use the instructions available for those data types. This leads to somewhat less efficient code because more Java Virtual Machine instructions are needed, for example:</p><p>涉及其他数据类型的控制结构以类似的方式编译，但必须使用适用于这些数据类型的指令。这导致代码效率较低，因为需要更多的Java虚拟机指令，例如：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">whileDouble</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">double</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100.1</span>) &#123;        i++;    &#125;&#125;</code></pre><p>is compiled to:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method void whileDouble()0 dconst_01 dstore_12 goto 95 dload_16 dconst_17 dadd8 dstore_19 dload_110 ldc2_w #413 dcmpg14 iflt 517 return</code></pre><p>Each floating-point type has two comparison instructions: fcmpl and fcmpg for type float, and dcmpl and dcmpg for type double. The variants differ only in their treatment of NaN. NaN is unordered (§2.3.2), so all floating-point comparisons fail if either of their operands is NaN. The compiler chooses the variant of the comparison instruction for the appropriate type that produces the same result whether the comparison fails on non-NaN values or encounters a NaN. For instance:</p><p>每种浮点类型都有两种比较指令：<code>fcmpl</code>和<code>fcmpg</code>用于<code>float</code>类型，<code>dcmpl</code>和<code>dcmpg</code>用于<code>double</code>类型。这些变体仅在处理<code>NaN</code>（非数字）方面有所不同。<code>NaN</code>是无序的（§2.3.2），因此如果操作数之一为<code>NaN</code>，则所有浮点比较都会失败。编译器为适当的类型选择比较指令的变体，使得无论比较失败于非<code>NaN</code>值还是遇到<code>NaN</code>，都能产生相同的结果。例如：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">lessThan100</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> &#123;    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">100.0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>compiles to:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method int lessThan100(double)0  dload_11  ldc2_w #44  dcmpg5  ifge 108  iconst_19  ireturn10 iconst_m111 ireturn</code></pre><p>If d is not NaN and is less than 100.0, the dcmpg instruction pushes an int -1 onto the operand stack, and the ifge instruction does not branch. Whether d is greater than 100.0 or is NaN, the dcmpg instruction pushes an int 1 onto the operand stack, and the ifge branches. If d is equal to 100.0, the dcmpg instruction pushes an int 0 onto the operand stack, and the ifge branches.</p><p>如果<code>d</code>不是<code>NaN</code>并且小于100.0，<code>dcmpg</code>指令将<code>int -1</code>推送到操作数栈上，并且<code>ifge</code>指令不会分支。无论<code>d</code>是否大于100.0或是<code>NaN</code>，<code>dcmpg</code>指令都会将<code>int 1</code>推送到操作数栈上，并且<code>ifge</code>指令将分支。如果<code>d</code>等于100.0，<code>dcmpg</code>指令将<code>int 0</code>推送到操作数栈上，并且<code>ifge</code>指令将分支。</p><p>The dcmpl instruction achieves the same effect if the comparison is reversed:</p><p>如果比较结果相反，<code>dcmpl</code>指令可以实现相同的效果：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">greaterThan100</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> &#123;    <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">100.0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>becomes:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method int greaterThan100(double)0 dload_11 ldc2_w #44 dcmpl5 ifle 108 iconst_19 ireturn10 iconst_m111 ireturn</code></pre><p>Once again, whether the comparison fails on a non-NaN value or because it is passed a NaN, the dcmpl instruction pushes an int value onto the operand stack that causes the ifle to branch. If both of the dcmp instructions did not exist, one of the example methods would have had to do more work to detect NaN.</p><p>再次强调，无论比较失败于非<code>NaN</code>值还是因为遇到<code>NaN</code>，<code>dcmpl</code>指令都会将一个<code>int</code>值推送到操作数栈上，导致<code>ifle</code>分支。如果没有这两个<code>dcmp</code>指令，示例方法之一将不得不进行更多工作来检测<code>NaN</code>。</p><hr><h2 id="3-6-Receiving-Arguments"><a href="#3-6-Receiving-Arguments" class="headerlink" title="3.6 Receiving Arguments"></a>3.6 Receiving Arguments</h2><p>If n arguments are passed to an instance method, they are received, by convention, in the local variables numbered 1 through n of the frame created for the new method invocation. The arguments are received in the order they were passed. For example:</p><p>如果将n个参数传递给实例方法，根据惯例，这些参数将被接收并存储在为新方法调用创建的栈帧的本地变量1到n中。参数的接收顺序与传递顺序一致。例如：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">addTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;    <span class="hljs-keyword">return</span> i + j;&#125;</code></pre><p>compiles to:</p><p>编译后的代码为：</p><pre><code class="hljs asm">Method int addTwo(int,int)0 iload_1   // Push value of local variable 1 (i)1 iload_2   // Push value of local variable 2 (j)2 iadd      // Add; leave int result on operand stack3 ireturn   // Return int result</code></pre><p>By convention, an instance method is passed a reference to its instance in local variable 0. In the Java programming language the instance is accessible via the this keyword.</p><p>按照惯例，实例方法在本地变量0中传递对其实例的引用。在Java编程语言中，该实例可以通过<code>this</code>关键字访问。</p><p>Class (static) methods do not have an instance, so for them this use of local variable 0 is unnecessary. A class method starts using local variables at index 0. If the addTwo method were a class method, its arguments would be passed in a similar way to the first version:</p><p>类（静态）方法没有实例，因此对于它们来说，本地变量0的使用是没有必要的。类方法从索引0开始使用本地变量。如果<code>addTwo</code>方法是一个类方法，其参数将以与第一个版本相似的方式传递：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addTwoStatic</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;    <span class="hljs-keyword">return</span> i + j;&#125;</code></pre><p>compiles to:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method int addTwoStatic(int,int)0 iload_01 iload_12 iadd3 ireturn</code></pre><p>The only difference is that the method arguments appear starting in local variable 0 rather than 1.</p><p>唯一的区别是方法参数从本地变量0开始，而不是从1开始。</p><hr><h2 id="3-7-Invoking-Methods"><a href="#3-7-Invoking-Methods" class="headerlink" title="3.7 Invoking Methods"></a>3.7 Invoking Methods</h2><p>The normal method invocation for a instance method dispatches on the run-time type of the object. (They are virtual, in C++ terms.) Such an invocation is implemented using the invokevirtual instruction, which takes as its argument an index to a run-time constant pool entry giving the internal form of the binary name of the class type of the object, the name of the method to invoke, and that method’s descriptor (§4.3.3). To invoke the addTwo method, defined earlier as an instance method, we might write:</p><p>实例方法的常规方法调用基于对象的运行时类型进行调度。（用C++的术语来说，它们是虚拟的。）这种调用是通过<code>invokevirtual</code>指令实现的，该指令将运行时常量池项的索引作为其参数，提供对象的类类型的二进制名称的内部形式、要调用的方法名称以及该方法的描述符（§4.3.3）。要调用前面定义的实例方法<code>addTwo</code>，我们可以这样写：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">add12and13</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> addTwo(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>);&#125;</code></pre><p>This compiles to:</p><p>编译后的代码为：</p><pre><code class="hljs asm">Method int add12and13()    0 aload_0                  // Push local variable 0 (this)1 bipush 12                // Push int constant 123 bipush 13                // Push int constant 135 invokevirtual #4         // Method Example.addtwo(II)I8 ireturn                  // Return int on top of operand stack;it is the int result of addTwo()</code></pre><p>The invocation is set up by first pushing a reference to the current instance, this, on to the operand stack. The method invocation’s arguments, int values 12 and 13, are then pushed. When the frame for the addTwo method is created, the arguments passed to the method become the initial values of the new frame’s local variables. That is, the reference for this and the two arguments, pushed onto the operand stack by the invoker, will become the initial values of local variables 0, 1, and 2 of the invoked method.</p><p>方法调用的设置首先通过将当前实例的引用<code>this</code>推送到操作数栈上。然后推送方法调用的参数，<code>int</code>值12和13。当为<code>addTwo</code>方法创建栈帧时，传递给该方法的参数成为新栈帧本地变量的初始值。也就是说，由调用者推送到操作数栈上的<code>this</code>引用和两个参数，将成为被调用方法的本地变量0、1和2的初始值。</p><p>Finally, addTwo is invoked. When it returns, its int return value is pushed onto the operand stack of the frame of the invoker, the add12and13 method. The return value is thus put in place to be immediately returned to the invoker of add12and13.</p><p>最后，调用<code>addTwo</code>。当它返回时，其<code>int</code>返回值被推送到调用者栈帧的操作数栈上，即<code>add12and13</code>方法的操作数栈。返回值因此被放置在适当位置，立即返回给<code>add12and13</code>的调用者。</p><p>The return from add12and13 is handled by the ireturn instruction of add12and13. The ireturn instruction takes the int value returned by addTwo, on the operand stack of the current frame, and pushes it onto the operand stack of the frame of the invoker. It then returns control to the invoker, making the invoker’s frame current. The Java Virtual Machine provides distinct return instructions for many of its numeric and reference data types, as well as a return instruction for methods with no return value. The same set of return instructions is used for all varieties of method invocations.</p><p>从<code>add12and13</code>返回由<code>add12and13</code>的<code>ireturn</code>指令处理。<code>ireturn</code>指令获取<code>addTwo</code>返回的<code>int</code>值，位于当前栈帧的操作数栈上，并将其推送到调用者栈帧的操作数栈上。然后它将控制权返回给调用者，使调用者的栈帧成为当前栈帧。Java虚拟机为其许多数值和引用数据类型提供了不同的返回指令，以及用于无返回值方法的返回指令。同一组返回指令用于所有类型的方法调用。</p><p>The operand of the invokevirtual instruction (in the example, the run-time constant pool index #4) is not the offset of the method in the class instance. The compiler does not know the internal layout of a class instance. Instead, it generates symbolic references to the methods of an instance, which are stored in the run-time constant pool. Those run-time constant pool items are resolved at run-time to determine the actual method location. The same is true for all other Java Virtual Machine instructions that access class instances.</p><p><code>invokevirtual</code>指令的操作数（在示例中为运行时常量池索引#4）不是类实例中方法的偏移量。编译器并不知道类实例的内部布局。相反，它生成对实例方法的符号引用，这些引用存储在运行时常量池中。这些运行时常量池项在运行时解析以确定实际的方法位置。所有其他访问类实例的Java虚拟机指令也是如此。</p><p>Invoking addTwoStatic, a class (static) variant of addTwo, is similar, as shown:</p><p>调用<code>addTwoStatic</code>，<code>addTwo</code>的类（静态）变体，与实例方法类似，如下所示：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">add12and13</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> addTwoStatic(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>);&#125;</code></pre><p>although a different Java Virtual Machine method invocation instruction is used:</p><p>尽管使用了不同的Java虚拟机方法调用指令：</p><pre><code class="hljs plaintext">Method int add12and13()0 bipush 122 bipush 134 invokestatic #3       // Method Example.addTwoStatic(II)I7 ireturn</code></pre><p>Compiling an invocation of a class (static) method is very much like compiling an invocation of an instance method, except this is not passed by the invoker. The method arguments will thus be received beginning with local variable 0 (§3.6). The invokestatic instruction is always used to invoke class methods.</p><p>编译类（静态）方法的调用与编译实例方法的调用非常相似，只不过<code>this</code>不会由调用者传递。因此，方法参数将从本地变量0开始接收（§3.6）。<code>invokestatic</code>指令始终用于调用类方法。</p><p>The invokespecial instruction must be used to invoke instance initialization methods (§3.8). It is also used when invoking methods in the superclass (super) and when invoking private methods. For instance, given classes Near and Far declared as:</p><p><code>invokespecial</code>指令必须用于调用实例初始化方法（§3.8）。它还用于调用超类（<code>super</code>）中的方法和私有方法。例如，定义了<code>Near</code>和<code>Far</code>类如下：</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Near</span> &#123;    <span class="hljs-type">int</span> it;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getItNear</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> getIt();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIt</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> it;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Far</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Near</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-title function_">getItFar</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getItNear();    &#125;&#125;</code></pre><p>the method Near.getItNear (which invokes a private method) becomes:</p><p><code>Near.getItNear</code>方法（调用了一个私有方法）编译后为：</p><pre><code class="hljs plaintext">Method int getItNear()0 aload_01 invokespecial #5      // Method Near.getIt()I4 ireturn</code></pre><p>The method Far.getItFar (which invokes a superclass method) becomes:</p><p><code>Far.getItFar</code>方法（调用了一个超类方法）编译后为：</p><pre><code class="hljs plaintext">Method int getItFar()0 aload_01 invokespecial #4      // Method Near.getItNear()I4 ireturn</code></pre><p>Note that methods called using the invokespecial instruction always pass this to the invoked method as its first argument. As usual, it is received in local variable 0.</p><p>请注意，使用<code>invokespecial</code>指令调用的方法始终将<code>this</code>作为其第一个参数传递给被调用方法。与往常一样，它在本地变量0中接收。</p><p>To invoke the target of a method handle, a compiler must form a method descriptor that records the actual argument and return types. A compiler may not perform method invocation conversions on the arguments; instead, it must push them on the stack according to their own unconverted types. The compiler arranges for a reference to the method handle object to be pushed on the stack before the arguments, as usual. The compiler emits an invokevirtual instruction that references a descriptor which describes the argument and return types. By special arrangement with method resolution (§5.4.3.3), an invokevirtual instruction which invokes the invokeExact or invoke methods of java.lang.invoke.MethodHandle will always link, provided the method descriptor is syntactically well-formed and the types named in the descriptor can be resolved.</p><p>要调用方法句柄的目标，编译器必须形成一个记录实际参数和返回类型的方法描述符。编译器不得对参数执行方法调用转换；相反，它必须根据其未转换的类型将它们推送到栈上。编译器安排在参数之前将方法句柄对象的引用推送到栈上，如常规操作一样。编译器发出一个<code>invokevirtual</code>指令，该指令引用一个描述参数和返回类型的描述符。通过与方法解析（§5.4.3.3）的特殊安排，调用<code>java.lang.invoke.MethodHandle</code>的<code>invokeExact</code>或<code>invoke</code>方法的<code>invokevirtual</code>指令将始终链接，前提是方法描述符在语法上是正确的，并且描述符中命名的类型可以解析。</p><hr><h2 id="3-8-Working-with-Class-Instances"><a href="#3-8-Working-with-Class-Instances" class="headerlink" title="3.8 Working with Class Instances"></a>3.8 Working with Class Instances</h2><p>Java Virtual Machine class instances are created using the Java Virtual Machine’s new instruction. Recall that at the level of the Java Virtual Machine, a constructor appears as a method with the compiler-supplied name &lt;init&gt;. This specially named method is known as the instance initialization method (§2.9). Multiple instance initialization methods, corresponding to multiple constructors, may exist for a given class. Once the class instance has been created and its instance variables, including those of the class and all of its superclasses, have been initialized to their default values, an instance initialization method of the new class instance is invoked. For example:</p><p>Java虚拟机类实例是使用Java虚拟机的<code>new</code>指令创建的。请记住，在Java虚拟机层面上，构造函数显示为一个带有编译器提供名称<code>&lt;init&gt;</code>的方法。这个特别命名的方法被称为实例初始化方法（§2.9）。对于给定类，可能存在多个实例初始化方法，对应多个构造函数。一旦类实例被创建，并且其实例变量（包括该类及其所有超类的实例变量）已被初始化为默认值，新类实例的实例初始化方法就会被调用。例如：</p><pre><code class="hljs java">Object <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();&#125;</code></pre><p>compiles to:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method java.lang.Object create()0 new #1             // Class java.lang.Object3 dup4 invokespecial #4   // Method java.lang.Object.&lt;init&gt;()V7 areturn</code></pre><p>Class instances are passed and returned (as reference types) very much like numeric values, although type reference has its own complement of instructions, for example:</p><p>类实例的传递和返回（作为引用类型）与数值非常相似，尽管引用类型有自己的一套指令，例如：</p><pre><code class="hljs java"><span class="hljs-type">int</span> i;      <span class="hljs-comment">// An instance variable</span>MyObj <span class="hljs-title function_">example</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">MyObj</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObj</span>();    <span class="hljs-keyword">return</span> silly(o);&#125;MyObj <span class="hljs-title function_">silly</span><span class="hljs-params">(MyObj o)</span> &#123;    <span class="hljs-keyword">if</span> (o != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> o;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> o;    &#125;&#125;</code></pre><p>becomes:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method MyObj example()0 new #2               // Class MyObj3 dup4 invokespecial #5     // Method MyObj.&lt;init&gt;()V7 astore_18 aload_09 aload_110 invokevirtual #4    // Method Example.silly(LMyObj;)LMyObj;13 areturnMethod MyObj silly(MyObj) 0 aload_1  1 ifnull 6  4 aload_15 areturn 6 aload_1 7 areturn</code></pre><p>The fields of a class instance (instance variables) are accessed using the getfield and putfield instructions. If i is an instance variable of type int, the methods setIt and getIt, defined as:</p><p>类实例的字段（实例变量）通过<code>getfield</code>和<code>putfield</code>指令访问。如果<code>i</code>是一个<code>int</code>类型的实例变量，定义的方法<code>setIt</code>和<code>getIt</code>如下：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setIt</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;    i = value;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">getIt</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> i;&#125;</code></pre><p>become:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method void setIt(int)0 aload_01 iload_12 putfield #4       // Field Example.i I5 returnMethod int getIt()0 aload_01 getfield #4       // Field Example.i I4 ireturn</code></pre><p>As with the operands of method invocation instructions, the operands of the putfield and getfield instructions (the run-time constant pool index #4) are not the offsets of the fields in the class instance. The compiler generates symbolic references to the fields of an instance, which are stored in the run-time constant pool. Those run-time constant pool items are resolved at run-time to determine the location of the field within the referenced object.</p><p>与方法调用指令的操作数一样，<code>putfield</code>和<code>getfield</code>指令的操作数（运行时常量池索引#4）不是类实例中字段的偏移量。编译器为实例的字段生成符号引用，这些引用存储在运行时常量池中。这些运行时常量池项在运行时解析以确定引用对象中字段的位置。</p><hr><h2 id="3-9-Arrays"><a href="#3-9-Arrays" class="headerlink" title="3.9 Arrays"></a>3.9 Arrays</h2><p>Java Virtual Machine arrays are also objects. Arrays are created and manipulated using a distinct set of instructions. The newarray instruction is used to create an array of a numeric type. The code:</p><p>Java虚拟机的数组也是对象。数组的创建和操作使用了一套不同的指令。<code>newarray</code>指令用于创建某种数值类型的数组。如下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createBuffer</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> buffer[];    <span class="hljs-type">int</span> <span class="hljs-variable">bufsz</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;    buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bufsz];    buffer[<span class="hljs-number">10</span>] = value;    value = buffer[<span class="hljs-number">11</span>];&#125;</code></pre><p>might be compiled to:</p><p>可能会被编译为：</p><pre><code class="hljs asm">Method void createBuffer()0  bipush 100    // Push int constant 100 (bufsz)2  istore_2      // Store bufsz in local variable 23  bipush 12     // Push int constant 12 (value)5  istore_3      // Store value in local variable 36  iload_2       // Push bufsz...7  newarray int  // ...and create new int array of that length9  astore_1      // Store new array in buffer10 aload_1       // Push buffer11 bipush 10     // Push int constant 1013 iload_3       // Push value14 iastore       // Store value at buffer[10]15 aload_1       // Push buffer16 bipush 11     // Push int constant 1118 iaload        // Push value at buffer[11]...19 istore_3      // ...and store it in value20 return</code></pre><p>The anewarray instruction is used to create a one-dimensional array of object references, for example:</p><p><code>anewarray</code>指令用于创建一个一维对象引用数组，例如：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createThreadArray</span><span class="hljs-params">()</span> &#123;    Thread threads[];    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[count];    threads[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();&#125;</code></pre><p>becomes:</p><p>编译后的代码为：</p><pre><code class="hljs plaintext">Method void createThreadArray()0 bipush 10             // Push int constant 102 istore_2              // Initialize count to that3 iload_2               // Push count, used by anewarray4 anewarray class #1    // Create new array of class Thread        7 astore_1              // Store new array in threads8 aload_1               // Push value of threads9 iconst_0              // Push int constant 010 new #1               // Create instance of class Thread13 dup                  // Make duplicate reference...14 invokespecial #5     // ...for Thread&#x27;s constructor; Method java.lang.Thread.&lt;init&gt;()V17 aastore              // Store new Thread in array at 018 return</code></pre><p>The anewarray instruction can also be used to create the first dimension of a multidimensional array. Alternatively, the multianewarray instruction can be used to create several dimensions at once. For example, the three-dimensional array:</p><p><code>anewarray</code>指令也可用于创建多维数组的第一维。或者，可以使用<code>multianewarray</code>指令一次性创建多个维度。例如，三维数组：</p><pre><code class="hljs java"><span class="hljs-type">int</span>[][][] create3DArray() &#123;    <span class="hljs-type">int</span> grid[][][];    grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>][];    <span class="hljs-keyword">return</span> grid;&#125;</code></pre><p>is created by:</p><p>可通过以下指令创建：</p><pre><code class="hljs plaintext">Method int create3DArray()[][][]0 bipush 10                   // Push int 10 (dimension one)2 iconst_5                    // Push int 5 (dimension two)3 multianewarray #1 dim #2    // Class [[[I, a three-dimensional;int array;only create the first two dimensions7 astore_1                    // Store new array...        8 aload_1                     // ...then prepare to return it9 areturn</code></pre><p>The first operand of the multianewarray instruction is the run-time constant pool index to the array class type to be created. The second is the number of dimensions of that array type to actually create. The multianewarray instruction can be used to create all the dimensions of the type, as the code for create3DArray shows. Note that the multidimensional array is just an object and so is loaded and returned by an aload_1 and areturn instruction, respectively. For information about array class names, see §4.4.1.</p><p><code>multianewarray</code>指令的第一个操作数是要创建的数组类类型的运行时常量池索引。第二个是该数组类型实际创建的维数。<code>multianewarray</code>指令可用于创建该类型的所有维度，正如<code>create3DArray</code>代码所示。注意，多维数组只是一个对象，因此分别通过<code>aload_1</code>和<code>areturn</code>指令加载和返回。有关数组类名称的信息，请参见§4.4.1。</p><p>All arrays have associated lengths, which are accessed via the <code>arraylength</code> instruction.</p><p>所有数组都有相关的长度，可以通过<code>arraylength</code>指令访问。</p><hr><h2 id="3-10-Compiling-Switches"><a href="#3-10-Compiling-Switches" class="headerlink" title="3.10 Compiling Switches"></a>3.10 Compiling Switches</h2><p>Compilation of switch statements uses the <code>tableswitch</code> and <code>lookupswitch</code> instructions. The <code>tableswitch</code> instruction is used when the cases of the switch can be efficiently represented as indices into a table of target offsets. The default target of the switch is used if the value of the expression of the switch falls outside the range of valid indices. For instance:</p><p>Switch语句的编译使用<code>tableswitch</code>和<code>lookupswitch</code>指令。当Switch的case可以有效地表示为目标偏移量表中的索引时，使用<code>tableswitch</code>指令。如果Switch表达式的值超出了有效索引范围，则使用Switch的默认目标。例如：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">chooseNear</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;    <span class="hljs-keyword">switch</span> (i) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span>;        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>compiles to:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-type">int</span> <span class="hljs-title function_">chooseNear</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><span class="hljs-number">0</span> iload_1<span class="hljs-number">1</span> tableswitch <span class="hljs-number">0</span> to <span class="hljs-number">2</span>:    <span class="hljs-number">0</span>: <span class="hljs-number">28</span>    <span class="hljs-number">1</span>: <span class="hljs-number">30</span>    <span class="hljs-number">2</span>: <span class="hljs-number">32</span><span class="hljs-keyword">default</span>:<span class="hljs-number">34</span><span class="hljs-number">28</span> iconst_0<span class="hljs-number">29</span> ireturn<span class="hljs-number">30</span> iconst_1<span class="hljs-number">31</span> ireturn<span class="hljs-number">32</span> iconst_2<span class="hljs-number">33</span> ireturn<span class="hljs-number">34</span> iconst_m1<span class="hljs-number">35</span> ireturn</code></pre><p>The Java Virtual Machine’s <code>tableswitch</code> and <code>lookupswitch</code> instructions operate only on <code>int</code> data. Because operations on <code>byte</code>, <code>char</code>, or <code>short</code> values are internally promoted to <code>int</code>, a switch whose expression evaluates to one of those types is compiled as though it evaluated to type <code>int</code>. If the <code>chooseNear</code> method had been written using type <code>short</code>, the same Java Virtual Machine instructions would have been generated as when using type <code>int</code>. Other numeric types must be narrowed to type <code>int</code> for use in a switch.</p><p><code>tableswitch</code>和<code>lookupswitch</code>指令只能操作<code>int</code>类型的数据。由于<code>byte</code>、<code>char</code>或<code>short</code>值的操作会被内部提升为<code>int</code>，因此，如果Switch的表达式计算为这些类型之一，它们会被编译为<code>int</code>类型。如果<code>chooseNear</code>方法是用<code>short</code>类型编写的，生成的Java虚拟机指令将与使用<code>int</code>类型时生成的指令相同。其他数值类型必须缩小为<code>int</code>类型才能在Switch中使用。</p><p>Where the cases of the switch are sparse, the table representation of the <code>tableswitch</code> instruction becomes inefficient in terms of space. The <code>lookupswitch</code> instruction may be used instead. The <code>lookupswitch</code> instruction pairs <code>int</code> keys (the values of the case labels) with target offsets in a table. When a <code>lookupswitch</code> instruction is executed, the value of the expression of the switch is compared against the keys in the table. If one of the keys matches the value of the expression, execution continues at the associated target offset. If no key matches, execution continues at the default target. For instance, the compiled code for:</p><p>当Switch的case稀疏时，<code>tableswitch</code>指令的表表示在空间方面变得低效。这时可以使用<code>lookupswitch</code>指令。<code>lookupswitch</code>指令将<code>int</code>键（case标签的值）与表中的目标偏移量配对。当执行<code>lookupswitch</code>指令时，Switch表达式的值会与表中的键进行比较。如果其中一个键与表达式的值匹配，执行会继续在相关的目标偏移量处。如果没有键匹配，执行会继续在默认目标处。例如，以下代码的编译：</p><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">chooseFar</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;    <span class="hljs-keyword">switch</span> (i) &#123;        <span class="hljs-keyword">case</span> -<span class="hljs-number">100</span>: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:  <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>;        <span class="hljs-keyword">default</span>:   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>looks just like the code for <code>chooseNear</code>, except for the <code>lookupswitch</code> instruction:</p><p>看起来与<code>chooseNear</code>的代码相似，除了使用了<code>lookupswitch</code>指令：</p><pre><code class="hljs java">Method <span class="hljs-type">int</span> <span class="hljs-title function_">chooseFar</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><span class="hljs-number">0</span> iload_1<span class="hljs-number">1</span> lookupswitch <span class="hljs-number">3</span>:    -<span class="hljs-number">100</span>: <span class="hljs-number">36</span>       <span class="hljs-number">0</span>: <span class="hljs-number">38</span>     <span class="hljs-number">100</span>: <span class="hljs-number">40</span> <span class="hljs-keyword">default</span>: <span class="hljs-number">42</span><span class="hljs-number">36</span> iconst_m1<span class="hljs-number">37</span> ireturn<span class="hljs-number">38</span> iconst_0<span class="hljs-number">39</span> ireturn<span class="hljs-number">40</span> iconst_1<span class="hljs-number">41</span> ireturn<span class="hljs-number">42</span> iconst_m1<span class="hljs-number">43</span> ireturn</code></pre><p>The Java Virtual Machine specifies that the table of the <code>lookupswitch</code> instruction must be sorted by key so that implementations may use searches more efficient than a linear scan. Even so, the <code>lookupswitch</code> instruction must search its keys for a match rather than simply perform a bounds check and index into a table like <code>tableswitch</code>. Thus, a <code>tableswitch</code> instruction is probably more efficient than a <code>lookupswitch</code> where space considerations permit a choice.</p><p>Java虚拟机规定，<code>lookupswitch</code>指令的表必须按键排序，以便实现可以使用比线性扫描更高效的搜索方法。尽管如此，<code>lookupswitch</code>指令必须在其键中搜索匹配，而不是像<code>tableswitch</code>那样简单地执行边界检查并索引到表中。因此，在空间允许的情况下，<code>tableswitch</code>指令可能比<code>lookupswitch</code>更高效。</p><hr><h2 id="3-11-Operations-on-the-Operand-Stack"><a href="#3-11-Operations-on-the-Operand-Stack" class="headerlink" title="3.11 Operations on the Operand Stack"></a>3.11 Operations on the Operand Stack</h2><p>The Java Virtual Machine has a large complement of instructions that manipulate the contents of the operand stack as untyped values. These are useful because of the Java Virtual Machine’s reliance on deft manipulation of its operand stack. For instance:</p><p>Java虚拟机有大量的指令可以将操作数栈中的内容作为无类型值进行操作。这些指令很有用，因为Java虚拟机依赖于对其操作数栈的灵活操作。例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> index++;&#125;<span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</code></pre><p>is compiled to:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-type">long</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> dup<span class="hljs-number">2</span> getfield #<span class="hljs-number">4</span><span class="hljs-number">5</span> dup2_x1<span class="hljs-number">6</span> lconst_1<span class="hljs-number">7</span> ladd<span class="hljs-number">8</span> putfield #<span class="hljs-number">4</span><span class="hljs-number">11</span> lreturn</code></pre><p>Note that the Java Virtual Machine never allows its operand stack manipulation instructions to modify or break up individual values on the operand stack.</p><p>需要注意的是，Java虚拟机不允许其操作数栈操作指令修改或分解操作数栈中的单个值。</p><hr><h2 id="3-12-Throwing-and-Handling-Exceptions"><a href="#3-12-Throwing-and-Handling-Exceptions" class="headerlink" title="3.12 Throwing and Handling Exceptions"></a>3.12 Throwing and Handling Exceptions</h2><p>Exceptions are thrown from programs using the <code>throw</code> keyword. Its compilation is simple:</p><p>程序使用<code>throw</code>关键字抛出异常。它的编译很简单：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">cantBeZero</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> TestExc &#123;    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestExc</span>();    &#125;&#125;</code></pre><p>becomes:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">cantBeZero</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><span class="hljs-number">0</span> iload_1<span class="hljs-number">1</span> ifne <span class="hljs-number">12</span><span class="hljs-number">4</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">1</span><span class="hljs-number">7</span> dup<span class="hljs-number">8</span> invokespecial #<span class="hljs-number">7</span><span class="hljs-number">11</span> athrow<span class="hljs-number">12</span> <span class="hljs-keyword">return</span></code></pre><p>Compilation of try-catch constructs is straightforward. For example:</p><p><code>try-catch</code>结构的编译很简单。例如：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">catchOne</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        tryItOut();    &#125; <span class="hljs-keyword">catch</span> (TestExc e) &#123;        handleExc(e);    &#125;&#125;</code></pre><p>is compiled as:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchOne</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">6</span><span class="hljs-number">4</span> <span class="hljs-keyword">return</span><span class="hljs-number">5</span> astore_1<span class="hljs-number">6</span> aload_0<span class="hljs-number">7</span> aload_1<span class="hljs-number">8</span> invokevirtual #<span class="hljs-number">5</span><span class="hljs-number">11</span> <span class="hljs-keyword">return</span>Exception table:From To Target<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre><p>Looking more closely, the try block is compiled just as it would be if the try were not present:</p><p>仔细看，<code>try</code>块的编译与没有<code>try</code>时是一样的：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchOne</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">6</span><span class="hljs-number">4</span> <span class="hljs-keyword">return</span></code></pre><p>If no exception is thrown during the execution of the try block, it behaves as though the try were not there: <code>tryItOut</code> is invoked and <code>catchOne</code> returns.</p><p>如果在执行<code>try</code>块期间没有抛出异常，它的行为就像没有<code>try</code>一样：调用<code>tryItOut</code>并返回<code>catchOne</code>。</p><p>Following the try block is the Java Virtual Machine code that implements the single catch clause:</p><p>在<code>try</code>块之后是实现单个<code>catch</code>子句的Java虚拟机代码：</p><pre><code class="hljs java"><span class="hljs-number">5</span> astore_1<span class="hljs-number">6</span> aload_0<span class="hljs-number">7</span> aload_1<span class="hljs-number">8</span> invokevirtual #<span class="hljs-number">5</span><span class="hljs-number">11</span> <span class="hljs-keyword">return</span>Exception table:From To Target<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre><p>The invocation of <code>handleExc</code>, the contents of the catch clause, is also compiled like a normal method invocation. However, the presence of a catch clause causes the compiler to generate an exception table entry (§2.10, §4.7.3). The exception table for the <code>catchOne</code> method has one entry corresponding to the one argument (an instance of class <code>TestExc</code>) that the catch clause of <code>catchOne</code> can handle. If some value that is an instance of <code>TestExc</code> is thrown during execution of the instructions between indices 0 and 4 in <code>catchOne</code>, control is transferred to the Java Virtual Machine code at index 5, which implements the block of the catch clause. If the value that is thrown is not an instance of <code>TestExc</code>, the catch clause of <code>catchOne</code> cannot handle it. Instead, the value is rethrown to the invoker of <code>catchOne</code>.</p><p><code>handleExc</code>的调用（即<code>catch</code>子句的内容）也像普通方法调用一样被编译。然而，<code>catch</code>子句的存在导致编译器生成一个异常表条目（§2.10，§4.7.3）。<code>catchOne</code>方法的异常表有一个条目，对应于<code>catchOne</code>的<code>catch</code>子句可以处理的参数（类<code>TestExc</code>的一个实例）。如果在<code>catchOne</code>中执行0到4索引之间的指令期间抛出了<code>TestExc</code>实例的某个值，控制将转移到索引5处的Java虚拟机代码，该代码实现<code>catch</code>子句的块。如果抛出的值不是<code>TestExc</code>的实例，<code>catchOne</code>的<code>catch</code>子句无法处理它，而是将该值重新抛出给<code>catchOne</code>的调用者。</p><p>A try may have multiple catch clauses:</p><p><code>try</code>语句可以有多个<code>catch</code>子句：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">catchTwo</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        tryItOut();    &#125; <span class="hljs-keyword">catch</span> (TestExc1 e) &#123;        handleExc(e);    &#125; <span class="hljs-keyword">catch</span> (TestExc2 e) &#123;        handleExc(e);    &#125;&#125;</code></pre><p>Multiple catch clauses of a given try statement are compiled by simply appending the Java Virtual Machine code for each catch clause one after the other and adding entries to the exception table, as shown:</p><p>对于给定的<code>try</code>语句的多个<code>catch</code>子句，编译器通过简单地将每个<code>catch</code>子句的Java虚拟机代码依次附加起来，并在异常表中添加条目，如下所示：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchTwo</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">5</span><span class="hljs-number">4</span> <span class="hljs-keyword">return</span><span class="hljs-number">5</span> astore_1<span class="hljs-number">6</span> aload_0<span class="hljs-number">7</span> aload_1<span class="hljs-number">8</span> invokevirtual #<span class="hljs-number">7</span><span class="hljs-number">11</span> <span class="hljs-keyword">return</span><span class="hljs-number">12</span> astore_1<span class="hljs-number">13</span> aload_0<span class="hljs-number">14</span> aload_1<span class="hljs-number">15</span> invokevirtual #<span class="hljs-number">7</span><span class="hljs-number">18</span> <span class="hljs-keyword">return</span>Exception table:From To Target<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">12</span></code></pre><p>If during the execution of the try clause (between indices 0 and 4) a value is thrown that matches the parameter of one or more of the catch clauses (the value is an instance of one or more of the parameters), the first (innermost) such catch clause is selected. Control is transferred to the Java Virtual Machine code for the block of that catch clause. If the value thrown does not match the parameter of any of the catch clauses of <code>catchTwo</code>, the Java Virtual Machine rethrows the value without invoking code in any catch clause of <code>catchTwo</code>.</p><p>如果在执行<code>try</code>子句（索引0到4之间）期间抛出一个值，该值与一个或多个<code>catch</code>子句的参数匹配（该值是一个或多个参数的实例），则选择第一个（最内层的）<code>catch</code>子句。控制转移到该<code>catch</code>子句块的Java虚拟机代码。如果抛出的值与<code>catchTwo</code>的任何<code>catch</code>子句的参数不匹配，Java虚拟机将重新抛出该值，而不会调用<code>catchTwo</code>中的任何<code>catch</code>子句的代码。</p><p>Nested try-catch statements are compiled very much like a try statement with multiple catch clauses:</p><p>嵌套的<code>try-catch</code>语句的编译方式与具有多个<code>catch</code>子句的<code>try</code>语句非常相似：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">nestedCatch</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">try</span> &#123;            tryItOut();        &#125; <span class="hljs-keyword">catch</span> (TestExc1 e) &#123;            handleExc1(e);        &#125;    &#125; <span class="hljs-keyword">catch</span> (TestExc2 e) &#123;        handleExc2(e);    &#125;&#125;</code></pre><p>becomes:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">nestedCatch</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">8</span><span class="hljs-number">4</span> <span class="hljs-keyword">return</span><span class="hljs-number">5</span> astore_1<span class="hljs-number">6</span> aload_0<span class="hljs-number">7</span> aload_1<span class="hljs-number">8</span> invokevirtual #<span class="hljs-number">7</span><span class="hljs-number">11</span> <span class="hljs-keyword">return</span><span class="hljs-number">12</span> astore_1<span class="hljs-number">13</span> aload_0<span class="hljs-number">14</span> aload_1<span class="hljs-number">15</span> invokevirtual #<span class="hljs-number">6</span><span class="hljs-number">18</span> <span class="hljs-keyword">return</span>Exception table:From To Target<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">0</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span></code></pre><p>The nesting of catch clauses is represented only in the exception table. The Java Virtual Machine does not enforce nesting of or any ordering of the exception table entries (§2.10). However, because try-catch constructs are structured, a compiler can always order the entries of the exception handler table such that, for any thrown exception and any program counter value in that method, the first exception handler that matches the thrown exception corresponds to the innermost matching catch clause.</p><p><code>catch</code>子句的嵌套只在异常表中表示。Java虚拟机不强制执行异常表条目的嵌套或任何顺序（§2.10）。然而，由于<code>try-catch</code>结构是结构化的，编译器总是可以对异常处理器表的条目进行排序，以便对于在该方法中抛出的任何异常和任何程序计数器值，第一个与抛出异常匹配的异常处理器对应于最内层的匹配<code>catch</code>子句。</p><p>For instance, if the invocation of <code>tryItOut</code> (at index 1) threw an instance of <code>TestExc1</code>, it would be handled by the catch clause that invokes <code>handleExc1</code>. This is so even though the exception occurs within the bounds of the outer catch clause (catching <code>TestExc2</code>) and even though that outer catch clause might otherwise have been able to handle the thrown value.</p><p>例如，如果<code>tryItOut</code>（在索引1处的调用）抛出了<code>TestExc1</code>的实例，它将由调用<code>handleExc1</code>的<code>catch</code>子句处理。这种情况即使发生在外部<code>catch</code>子句（捕获<code>TestExc2</code>）的范围内，也仍然适用，即使外部<code>catch</code>子句本来可以处理该抛出的值。</p><p>As a subtle point, note that the range of a catch clause is inclusive on the “from” end and exclusive on the “to” end (§4.7.3). Thus, the exception table entry for the catch clause catching <code>TestExc1</code> does not cover the return instruction at offset 4. However, the exception table entry for the catch clause catching <code>TestExc2</code> does cover the return instruction at offset 11. Return instructions within nested catch clauses are included in the range of instructions covered by nesting catch clauses.</p><p>需要注意的是，<code>catch</code>子句的范围在“from”端是包含的，在“to”端是不包含的（§4.7.3）。因此，捕获<code>TestExc1</code>的<code>catch</code>子句的异常表条目不覆盖偏移量为4的return指令。然而，捕获<code>TestExc2</code>的<code>catch</code>子句的异常表条目确实覆盖了偏移量为11的return指令。嵌套<code>catch</code>子句中的return指令包含在嵌套<code>catch</code>子句覆盖的指令范围内。</p><hr><h2 id="3-13-Compiling-finally"><a href="#3-13-Compiling-finally" class="headerlink" title="3.13 Compiling finally"></a>3.13 Compiling finally</h2><p>(This section assumes a compiler generates class files with version number 50.0 or below, so that the <code>jsr</code> instruction may be used. See also §4.10.2.5.)</p><p>（本节假设编译器生成版本号为50.0或以下的类文件，因此可以使用<code>jsr</code>指令。另见§4.10.2.5。）</p><p>Compilation of a try-finally statement is similar to that of try-catch. Prior to transferring control outside the try statement, whether that transfer is normal or abrupt, because an exception has been thrown, the finally clause must first be executed. For this simple example:</p><p><code>try-finally</code>语句的编译类似于<code>try-catch</code>。在将控制权转移到<code>try</code>语句之外之前，无论这种转移是正常的还是突然的（例如抛出异常），都必须首先执行<code>finally</code>子句。以下是一个简单的例子：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">tryFinally</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        tryItOut();    &#125; <span class="hljs-keyword">finally</span> &#123;        wrapItUp();    &#125;&#125;</code></pre><p>the compiled code is:</p><p>编译后的代码为：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryFinally</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">6</span><span class="hljs-number">4</span> jsr <span class="hljs-number">14</span><span class="hljs-number">7</span> <span class="hljs-keyword">return</span><span class="hljs-number">8</span> astore_1<span class="hljs-number">9</span> jsr <span class="hljs-number">14</span><span class="hljs-number">12</span> aload_1<span class="hljs-number">13</span> athrow<span class="hljs-number">14</span> astore_2<span class="hljs-number">15</span> aload_0<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">5</span><span class="hljs-number">19</span> ret <span class="hljs-number">2</span>Exception table:From To Target<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> any</code></pre><p>There are four ways for control to pass outside of the try statement: by falling through the bottom of that block, by returning, by executing a break or continue statement, or by raising an exception. If <code>tryItOut</code> returns without raising an exception, control is transferred to the finally block using a <code>jsr</code> instruction. The <code>jsr 14</code> instruction at index 4 makes a “subroutine call” to the code for the finally block at index 14 (the finally block is compiled as an embedded subroutine). When the finally block completes, the <code>ret 2</code> instruction returns control to the instruction following the <code>jsr</code> instruction at index 4.</p><p>有四种方式可以将控制权传递到<code>try</code>语句之外：通过块的底部正常退出、通过返回、通过执行<code>break</code>或<code>continue</code>语句，或通过引发异常。如果<code>tryItOut</code>在不引发异常的情况下返回，控制将通过<code>jsr</code>指令转移到<code>finally</code>块。索引4处的<code>jsr 14</code>指令对索引14处的<code>finally</code>块代码进行了“子程序调用”（<code>finally</code>块被编译为嵌入式子程序）。当<code>finally</code>块完成时，<code>ret 2</code>指令将控制权返回到索引4处<code>jsr</code>指令之后的指令。</p><p>In more detail, the subroutine call works as follows: The <code>jsr</code> instruction pushes the address of the following instruction (return at index 7) onto the operand stack before jumping. The <code>astore_2</code> instruction that is the jump target stores the address on the operand stack into local variable 2. The code for the finally block (in this case the <code>aload_0</code> and <code>invokevirtual</code> instructions) is run. Assuming execution of that code completes normally, the <code>ret</code> instruction retrieves the address from local variable 2 and resumes execution at that address. The return instruction is executed, and <code>tryFinally</code> returns normally.</p><p>更详细地说，子程序调用的工作原理如下：<code>jsr</code>指令在跳转之前将下一个指令的地址（索引7处的<code>return</code>）压入操作数栈。作为跳转目标的<code>astore_2</code>指令将操作数栈上的地址存储到局部变量2中。然后执行<code>finally</code>块的代码（在本例中是<code>aload_0</code>和<code>invokevirtual</code>指令）。假设该代码正常完成，<code>ret</code>指令会从局部变量2中检索地址，并在该地址恢复执行。接着执行<code>return</code>指令，<code>tryFinally</code>方法正常返回。</p><p>A try statement with a finally clause is compiled to have a special exception handler, one that can handle any exception thrown within the try statement. If <code>tryItOut</code> throws an exception, the exception table for <code>tryFinally</code> is searched for an appropriate exception handler. The special handler is found, causing execution to continue at index 8. The <code>astore_1</code> instruction at index 8 stores the thrown value into local variable 1. The following <code>jsr</code> instruction does a subroutine call to the code for the finally block. Assuming that code returns normally, the <code>aload_1</code> instruction at index 12 pushes the thrown value back onto the operand stack, and the following <code>athrow</code> instruction rethrows the value.</p><p>带有<code>finally</code>子句的<code>try</code>语句被编译为具有特殊异常处理程序的形式，这种处理程序可以处理<code>try</code>语句中抛出的任何异常。如果<code>tryItOut</code>抛出异常，会在<code>tryFinally</code>的异常表中搜索合适的异常处理程序。找到特殊处理程序后，执行会继续在索引8处进行。索引8处的<code>astore_1</code>指令将抛出的值存储到局部变量1中。接下来的<code>jsr</code>指令会对子程序进行调用，执行<code>finally</code>块的代码。假设该代码正常返回，索引12处的<code>aload_1</code>指令会将抛出的值重新压入操作数栈，随后<code>athrow</code>指令会重新抛出该值。</p><p>Compiling a try statement with both a catch clause and a finally clause is more complex:</p><p>编译带有<code>catch</code>和<code>finally</code>子句的<code>try</code>语句会更加复杂：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCatchFinally</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        tryItOut();    &#125; <span class="hljs-keyword">catch</span> (TestExc e) &#123;        handleExc(e);    &#125; <span class="hljs-keyword">finally</span> &#123;        wrapItUp();    &#125;&#125;</code></pre><p>becomes:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCatchFinally</span><span class="hljs-params">()</span><span class="hljs-number">0</span> aload_0<span class="hljs-number">1</span> invokevirtual #<span class="hljs-number">4</span><span class="hljs-number">4</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">16</span><span class="hljs-number">7</span> astore_3<span class="hljs-number">8</span> aload_0<span class="hljs-number">9</span> aload_3<span class="hljs-number">10</span> invokevirtual #<span class="hljs-number">6</span><span class="hljs-number">13</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">16</span><span class="hljs-number">16</span> jsr <span class="hljs-number">26</span><span class="hljs-number">19</span> <span class="hljs-keyword">return</span><span class="hljs-number">20</span> astore_1<span class="hljs-number">21</span> jsr <span class="hljs-number">26</span><span class="hljs-number">24</span> aload_1<span class="hljs-number">25</span> athrow<span class="hljs-number">26</span> astore_2<span class="hljs-number">27</span> aload_0<span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">5</span><span class="hljs-number">31</span> ret <span class="hljs-number">2</span>Exception table:From To Target<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><span class="hljs-number">0</span> <span class="hljs-number">16</span> <span class="hljs-number">20</span></code></pre><p>If the try statement completes normally, the <code>goto</code> instruction at index 4 jumps to the subroutine call for the finally block at index 16. The finally block at index 26 is executed, control returns to the return instruction at index 19, and <code>tryCatchFinally</code> returns normally.</p><p>如果<code>try</code>语句正常完成，索引4处的<code>goto</code>指令会跳转到索引16处<code>finally</code>块的子程序调用。索引26处的<code>finally</code>块被执行，控制权返回索引19处的<code>return</code>指令，<code>tryCatchFinally</code>方法正常返回。</p><p>If <code>tryItOut</code> throws an instance of <code>TestExc</code>, the first (innermost) applicable exception handler in the exception table is chosen to handle the exception. The code for that exception handler, beginning at index 7, passes the thrown value to <code>handleExc</code> and on its return makes the same subroutine call to the finally block at index 26 as in the normal case. If an exception is not thrown by <code>handleExc</code>, <code>tryCatchFinally</code> returns normally.</p><p>如果<code>tryItOut</code>抛出<code>TestExc</code>的实例，异常表中的第一个（最内层的）适用异常处理程序会被选择处理该异常。该异常处理程序的代码从索引7开始，将抛出的值传递给<code>handleExc</code>，并在返回时对索引26处的<code>finally</code>块进行与正常情况相同的子程序调用。如果<code>handleExc</code>没有抛出异常，<code>tryCatchFinally</code>方法正常返回。</p><p>If <code>tryItOut</code> throws a value that is not an instance of <code>TestExc</code> or if <code>handleExc</code> itself throws an exception, the condition is handled by the second entry in the exception table, which handles any value thrown between indices 0 and 16. That exception handler transfers control to index 20, where the thrown value is first stored in local variable 1. The code for the finally block at index 26 is called as a subroutine. If it returns, the thrown value is retrieved from local variable 1 and rethrown using the <code>athrow</code> instruction. If a new value is thrown during execution of the finally clause, the finally clause aborts, and <code>tryCatchFinally</code> returns abruptly, throwing the new value to its invoker.</p><p>如果<code>tryItOut</code>抛出的值不是<code>TestExc</code>的实例，或者<code>handleExc</code>本身抛出了异常，则由异常表中的第二个条目处理该情况，该条目处理在索引0到16之间抛出的任何值。该异常处理程序将控制权转移到索引20，在那里首先将抛出的值存储到局部变量1中。然后调用索引26处<code>finally</code>块的代码作为子程序。如果它返回，抛出的值会从局部变量1中检索出来，并使用<code>athrow</code>指令重新抛出。如果在<code>finally</code>子句的执行期间抛出了新值，<code>finally</code>子句会中止，并且<code>tryCatchFinally</code>会突然返回，将新值抛给其调用者。</p><hr><h2 id="3-14-Synchronization"><a href="#3-14-Synchronization" class="headerlink" title="3.14 Synchronization"></a>3.14 Synchronization</h2><p>Synchronization in the Java Virtual Machine is implemented by monitor entry and exit, either explicitly (by use of the <code>monitorenter</code> and <code>monitorexit</code> instructions) or implicitly (by the method invocation and return instructions).</p><p>在Java虚拟机中，同步是通过进入和退出监视器来实现的，可以显式地通过使用<code>monitorenter</code>和<code>monitorexit</code>指令，也可以隐式地通过方法调用和返回指令来实现。</p><p>For code written in the Java programming language, perhaps the most common form of synchronization is the <code>synchronized</code> method. A <code>synchronized</code> method is not normally implemented using <code>monitorenter</code> and <code>monitorexit</code>. Rather, it is simply distinguished in the run-time constant pool by the <code>ACC_SYNCHRONIZED</code> flag, which is checked by the method invocation instructions (§2.11.10).</p><p>对于用Java编写的代码，最常见的同步形式可能是<code>synchronized</code>方法。通常，同步方法不会使用<code>monitorenter</code>和<code>monitorexit</code>实现。相反，它只是通过运行时常量池中的<code>ACC_SYNCHRONIZED</code>标志来区分，方法调用指令会检查该标志（§2.11.10）。</p><p>The <code>monitorenter</code> and <code>monitorexit</code> instructions enable the compilation of <code>synchronized</code> statements. For example:</p><p><code>monitorenter</code>和<code>monitorexit</code>指令允许编译<code>synchronized</code>语句。例如：</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onlyMe</span><span class="hljs-params">(Foo f)</span> &#123;    <span class="hljs-keyword">synchronized</span>(f) &#123;        doSomething();    &#125;&#125;</code></pre><p>is compiled to:</p><p>编译为：</p><pre><code class="hljs java">Method <span class="hljs-keyword">void</span> <span class="hljs-title function_">onlyMe</span><span class="hljs-params">(Foo)</span><span class="hljs-number">0</span> aload_1<span class="hljs-number">1</span> dup<span class="hljs-number">2</span> astore_2<span class="hljs-number">3</span> monitorenter<span class="hljs-number">4</span> aload_0<span class="hljs-number">5</span> invokevirtual #<span class="hljs-number">5</span><span class="hljs-number">8</span> aload_2<span class="hljs-number">9</span> monitorexit<span class="hljs-number">10</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">18</span><span class="hljs-number">13</span> astore_3<span class="hljs-number">14</span> aload_2<span class="hljs-number">15</span> monitorexit<span class="hljs-number">16</span> aload_3<span class="hljs-number">17</span> athrow<span class="hljs-number">18</span> <span class="hljs-keyword">return</span>Exception table:From To Target<span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-number">13</span> any<span class="hljs-number">13</span> <span class="hljs-number">16</span> <span class="hljs-number">13</span> any</code></pre><p>The compiler ensures that at any method invocation completion, a <code>monitorexit</code> instruction will have been executed for each <code>monitorenter</code> instruction executed since the method invocation. This is the case whether the method invocation completes normally (§2.6.4) or abruptly (§2.6.5). To enforce proper pairing of <code>monitorenter</code> and <code>monitorexit</code> instructions on abrupt method invocation completion, the compiler generates exception handlers (§2.10) that will match any exception and whose associated code executes the necessary <code>monitorexit</code> instructions.</p><p>编译器确保在任何方法调用完成时，每个自方法调用以来执行的<code>monitorenter</code>指令都会有一个对应的<code>monitorexit</code>指令执行。这适用于方法调用无论是正常完成（§2.6.4）还是突然完成（§2.6.5）。为了在方法调用突然完成时强制执行<code>monitorenter</code>和<code>monitorexit</code>指令的正确配对，编译器生成异常处理程序（§2.10），这些处理程序将匹配任何异常，并执行必要的<code>monitorexit</code>指令。</p><hr><h2 id="3-15-Annotations"><a href="#3-15-Annotations" class="headerlink" title="3.15 Annotations"></a>3.15 Annotations</h2><p>The representation of annotations in class files is described in §4.7.16-§4.7.22. These sections make it clear how to represent annotations on declarations of classes, interfaces, fields, methods, method parameters, and type parameters, as well as annotations on types used in those declarations. Annotations on package declarations require additional rules, given here.</p><p>类文件中注解的表示在§4.7.16-§4.7.22中进行了描述。这些部分清楚地说明了如何表示类、接口、字段、方法、方法参数和类型参数声明上的注解，以及这些声明中使用的类型上的注解。包声明上的注解需要额外的规则，这里给出了这些规则。</p><p>When the compiler encounters an annotated package declaration that must be made available at run time, it emits a class file with the following properties:</p><p>当编译器遇到必须在运行时可用的带注解包声明时，它会生成具有以下属性的类文件：</p><ul><li><p>The class file represents an interface, that is, the <code>ACC_INTERFACE</code> and <code>ACC_ABSTRACT</code> flags of the <code>ClassFile</code> structure are set (§4.1).</p></li><li><p>If the class file version number is less than 50.0, then the ACC_SYNTHETIC flag is unset; if the class file version number is 50.0 or above, then the ACC_SYNTHETIC flag is set.</p></li><li><p>The interface has package access (JLS §6.6.1).</p></li><li><p>The interface’s name is the internal form (§4.2.1) of <code>package-name.package-info</code>.</p></li><li><p>The interface has no superinterfaces.</p></li><li><p>The interface’s only members are those implied by The Java Language Specification, Java SE 8 Edition (JLS §9.2).</p></li><li><p>The annotations on the package declaration are stored as <code>RuntimeVisibleAnnotations</code> and <code>RuntimeInvisibleAnnotations</code> attributes in the attributes table of the <code>ClassFile</code> structure.</p></li><li><p>类文件表示一个接口，即设置了<code>ClassFile</code>结构的<code>ACC_INTERFACE</code>和<code>ACC_ABSTRACT</code>标志（§4.1）。</p></li><li><p>如果类文件的版本号小于50.0，则<code>ACC_SYNTHETIC</code>标志未设置；如果类文件版本号为50.0或更高，则设置<code>ACC_SYNTHETIC</code>标志。</p></li><li><p>该接口具有包访问权限（JLS §6.6.1）。</p></li><li><p>该接口的名称是<code>package-name.package-info</code>的内部形式（§4.2.1）。</p></li><li><p>该接口没有超接口。</p></li><li><p>该接口的唯一成员是《Java语言规范，Java SE 8版》（JLS §9.2）中规定的那些。</p></li><li><p>包声明上的注解存储为<code>ClassFile</code>结构中属性表中的<code>RuntimeVisibleAnnotations</code>和<code>RuntimeInvisibleAnnotations</code>属性。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 官方文档翻译 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-spec-5. Loading, Linking, and Initializing</title>
      <link href="/2022/09/02/jvm-spec-5.%20Loading,%20Linking,%20and%20Initializing/"/>
      <url>/2022/09/02/jvm-spec-5.%20Loading,%20Linking,%20and%20Initializing/</url>
      
        <content type="html"><![CDATA[<p>The Java Virtual Machine dynamically loads, links, and initializes classes and interfaces. Loading is the process of finding the binary representation of a class or interface type with a particular name and creating a class or interface from that binary representation. Linking is the process of taking a class or interface and combining it into the run-time state of the Java Virtual Machine so that it can be executed. Initialization of a class or interface consists of executing the class or interface initialization method <code>&lt;clinit&gt;</code> (§2.9).</p><p>Java虚拟机动态地加载、链接和初始化类和接口。加载是找到具有特定名称的类或接口类型的二进制表示并从该二进制表示中创建一个类或接口的过程。链接是将类或接口整合到Java虚拟机的运行时状态中，以便能够执行。类或接口的初始化包括执行类或接口的初始化方法<code>&lt;clinit&gt;</code> (§2.9)。</p><p>In this chapter, §5.1 describes how the Java Virtual Machine derives symbolic references from the binary representation of a class or interface. §5.2 explains how the processes of loading, linking, and initialization are first initiated by the Java Virtual Machine. §5.3 specifies how binary representations of classes and interfaces are loaded by class loaders and how classes and interfaces are created. Linking is described in §5.4. §5.5 details how classes and interfaces are initialized. §5.6 introduces the notion of binding native methods. Finally, §5.7 describes when a Java Virtual Machine exits.</p><p>在本章中，§5.1描述了Java虚拟机如何从类或接口的二进制表示中派生符号引用。§5.2解释了Java虚拟机如何首先启动加载、链接和初始化的过程。§5.3规定了类加载器如何加载类和接口的二进制表示，以及如何创建类和接口。链接在§5.4中描述。§5.5详细说明了类和接口的初始化。§5.6介绍了绑定本地方法的概念。最后，§5.7描述了Java虚拟机何时退出。</p><hr><h2 id="5-1-The-Run-Time-Constant-Pool"><a href="#5-1-The-Run-Time-Constant-Pool" class="headerlink" title="5.1 The Run-Time Constant Pool"></a>5.1 The Run-Time Constant Pool</h2><p>The Java Virtual Machine maintains a per-type constant pool (§2.5.5), a run-time data structure that serves many of the purposes of the symbol table of a conventional programming language implementation.</p><p>Java虚拟机维护一个按类型划分的常量池 (§2.5.5)，它是一个运行时数据结构，起到了传统编程语言实现中符号表的许多功能。</p><p>The <code>constant_pool</code> table (§4.4) in the binary representation of a class or interface is used to construct the run-time constant pool upon class or interface creation (§5.3). All references in the run-time constant pool are initially symbolic.</p><p>在类或接口的创建过程中 (§5.3)，二进制表示中的<code>constant_pool</code>表 (§4.4) 被用来构建运行时常量池。运行时常量池中的所有引用最初都是符号引用。</p><p>The symbolic references in the run-time constant pool are derived from structures in the binary representation of the class or interface as follows:</p><p>运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，具体如下：</p><ul><li><p>A symbolic reference to a class or interface is derived from a <code>CONSTANT_Class_info</code> structure (§4.4.1) in the binary representation of a class or interface. Such a reference gives the name of the class or interface in the form returned by the <code>Class.getName</code> method, that is:</p><ul><li>For a non-array class or an interface, the name is the binary name (§4.2.1) of the class or interface.</li><li>For an array class of n dimensions, the name begins with n occurrences of the ASCII “[“ character followed by a representation of the element type:<ul><li>If the element type is a primitive type, it is represented by the corresponding field descriptor (§4.3.2).</li><li>Otherwise, if the element type is a reference type, it is represented by the ASCII “L” character followed by the binary name (§4.2.1) of the element type followed by the ASCII “;” character.</li></ul></li></ul></li><li><p>类或接口的符号引用是从类或接口二进制表示中的<code>CONSTANT_Class_info</code>结构 (§4.4.1) 派生的。此类引用提供了通过<code>Class.getName</code>方法返回的类或接口的名称，即：</p><ul><li>对于非数组类或接口，其名称是类或接口的二进制名称 (§4.2.1)。</li><li>对于n维数组类，其名称以n个ASCII\“[”字符开头，后跟元素类型的表示：<ul><li>如果元素类型是基本类型，则使用相应的字段描述符 (§4.3.2) 表示。</li><li>否则，如果元素类型是引用类型，则使用ASCII“L”字符，后跟元素类型的二进制名称 (§4.2.1)，再后跟ASCII“;”字符。</li></ul></li></ul></li></ul><p>Whenever this chapter refers to the name of a class or interface, it should be understood to be in the form returned by the <code>Class.getName</code> method.</p><p>本章中提到类或接口的名称时，应理解为以<code>Class.getName</code>方法返回的形式。</p><ul><li><p>A symbolic reference to a field of a class or an interface is derived from a <code>CONSTANT_Fieldref_info</code> structure (§4.4.2) in the binary representation of a class or interface. Such a reference gives the name and descriptor of the field, as well as a symbolic reference to the class or interface in which the field is to be found.</p></li><li><p>类或接口字段的符号引用是从类或接口二进制表示中的<code>CONSTANT_Fieldref_info</code>结构 (§4.4.2) 派生的。此类引用提供字段的名称和描述符，以及包含该字段的类或接口的符号引用。</p></li><li><p>A symbolic reference to a method of a class is derived from a <code>CONSTANT_Methodref_info</code> structure (§4.4.2) in the binary representation of a class or interface. Such a reference gives the name and descriptor of the method, as well as a symbolic reference to the class in which the method is to be found.</p></li><li><p>类方法的符号引用是从类或接口二进制表示中的<code>CONSTANT_Methodref_info</code>结构 (§4.4.2) 派生的。此类引用提供方法的名称和描述符，以及包含该方法的类的符号引用。</p></li><li><p>A symbolic reference to a method of an interface is derived from a <code>CONSTANT_InterfaceMethodref_info</code> structure (§4.4.2) in the binary representation of a class or interface. Such a reference gives the name and descriptor of the interface method, as well as a symbolic reference to the interface in which the method is to be found.</p></li><li><p>接口方法的符号引用是从类或接口二进制表示中的<code>CONSTANT_InterfaceMethodref_info</code>结构 (§4.4.2) 派生的。此类引用提供接口方法的名称和描述符，以及包含该方法的接口的符号引用。</p></li><li><p>A symbolic reference to a method handle is derived from a <code>CONSTANT_MethodHandle_info</code> structure (§4.4.8) in the binary representation of a class or interface. Such a reference gives a symbolic reference to a field of a class or interface, or a method of a class, or a method of an interface, depending on the kind of the method handle.</p></li><li><p>方法句柄的符号引用是从类或接口二进制表示中的<code>CONSTANT_MethodHandle_info</code>结构 (§4.4.8) 派生的。此类引用提供对类或接口的字段、类的方法或接口的方法的符号引用，具体取决于方法句柄的类型。</p></li><li><p>A symbolic reference to a method type is derived from a <code>CONSTANT_MethodType_info</code> structure (§4.4.9) in the binary representation of a class or interface. Such a reference gives a method descriptor (§4.3.3).</p></li><li><p>方法类型的符号引用是从类或接口二进制表示中的<code>CONSTANT_MethodType_info</code>结构 (§4.4.9) 派生的。此类引用提供方法描述符 (§4.3.3)。</p></li><li><p>A symbolic reference to a call site specifier is derived from a <code>CONSTANT_InvokeDynamic_info</code> structure (§4.4.10) in the binary representation of a class or interface. Such a reference gives:</p><ul><li>a symbolic reference to a method handle, which will serve as a bootstrap method for an <code>invokedynamic</code> instruction (§invokedynamic);</li><li>a sequence of symbolic references (to classes, method types, and method handles), string literals, and run-time constant values which will serve as static arguments to a bootstrap method;</li><li>a method name and method descriptor.</li></ul></li><li><p>调用站点说明符的符号引用是从类或接口二进制表示中的<code>CONSTANT_InvokeDynamic_info</code>结构 (§4.4.10) 派生的。此类引用提供：</p><ul><li>一个方法句柄的符号引用，该句柄将用作<code>invokedynamic</code>指令 (§invokedynamic) 的引导方法；</li><li>一系列符号引用（类、方法类型和方法句柄的符号引用）、字符串字面量和运行时常量值，这些将作为引导方法的静态参数；</li><li>方法名称和方法描述符。</li></ul></li></ul><p>In addition, certain run-time values which are not symbolic references are derived from items found in the <code>constant_pool</code> table:</p><p>此外，某些不是符号引用的运行时值是从<code>constant_pool</code>表中的项派生的：</p><ul><li><p>A string literal is a reference to an instance of class <code>String</code>, and is derived from a <code>CONSTANT_String_info</code> structure (§4.4.3) in the binary representation of a class or interface. The <code>CONSTANT_String_info</code> structure gives the sequence of Unicode code points constituting the string literal.</p></li><li><p>字符串字面量是对<code>String</code>类实例的引用，并且是从类或接口的二进制表示中的<code>CONSTANT_String_info</code>结构 (§4.4.3) 派生的。<code>CONSTANT_String_info</code>结构给出了组成字符串字面量的Unicode代码点序列。</p></li></ul><p>The Java programming language requires that identical string literals (that is, literals that contain the same sequence of code points) must refer to the same instance of class <code>String</code> (JLS §3.10.5). In addition, if the method <code>String.intern</code> is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal. Thus, the following expression must have the value true:<br><code>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;</code></p><p>Java编程语言要求相同的字符串字面量（即包含相同代码点序列的字面量）必须引用<code>String</code>类的同一实例 (JLS §3.10.5)。此外，如果对任何字符串调用<code>String.intern</code>方法，结果将是对同一类实例的引用，如果该字符串作为字面量出现则会返回该实例。因此，以下表达式的值必须为true：<br><code>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;</code></p><p>To derive a string literal, the Java Virtual Machine examines the sequence of code points given by the <code>CONSTANT_String_info</code> structure.</p><p>要派生字符串字面量，Java虚拟机会检查<code>CONSTANT_String_info</code>结构给出的代码点序列。</p><ul><li><p>If the method <code>String.intern</code> has previously been called on an instance of class <code>String</code> containing a sequence of Unicode code points identical to that given by the <code>CONSTANT_String_info</code> structure, then the result of string literal derivation is a reference to that same instance of class <code>String</code>.</p></li><li><p>如果<code>String</code>类实例上之前已调用过<code>String.intern</code>方法，并且该实例包含的Unicode代码点序列与<code>CONSTANT_String_info</code>结构给出的一致，则字符串字面量派生的结果是对该<code>String</code>类同一实例的引用。</p></li><li><p>Otherwise, a new instance of class <code>String</code> is created containing the sequence of Unicode code points given by the <code>CONSTANT_String_info</code> structure; a reference to that class instance is the result of string literal derivation. Finally, the <code>intern</code> method of the new <code>String</code> instance is invoked.</p></li><li><p>否则，将创建一个包含<code>CONSTANT_String_info</code>结构给出的Unicode代码点序列的<code>String</code>类新实例；对该类实例的引用是字符串字面量派生的结果。最后，调用新<code>String</code>实例的<code>intern</code>方法。</p></li></ul><hr><h2 id="5-2-Java-Virtual-Machine-Startup"><a href="#5-2-Java-Virtual-Machine-Startup" class="headerlink" title="5.2 Java Virtual Machine Startup"></a>5.2 Java Virtual Machine Startup</h2><p>The Java Virtual Machine starts up by creating an initial class, which is specified in an implementation-dependent manner, using the bootstrap class loader (§5.3.1). The Java Virtual Machine then links the initial class, initializes it, and invokes the public class method <code>void main(String[])</code>. The invocation of this method drives all further execution. Execution of the Java Virtual Machine instructions constituting the main method may cause linking (and consequently creation) of additional classes and interfaces, as well as invocation of additional methods.</p><p>Java虚拟机启动时，使用引导类加载器 (§5.3.1) 创建初始类，该初始类以实现依赖的方式指定。Java虚拟机随后链接初始类，初始化它，并调用公共类方法<code>void main(String[])</code>。此方法的调用驱动了所有进一步的执行。构成main方法的Java虚拟机指令的执行可能会导致其他类和接口的链接（从而创建），以及其他方法的调用。</p><p>In an implementation of the Java Virtual Machine, the initial class could be provided as a command line argument. Alternatively, the implementation could provide an initial class that sets up a class loader which in turn loads an application. Other choices of the initial class are possible so long as they are consistent with the specification given in the previous paragraph.</p><p>在Java虚拟机的实现中，初始类可以作为命令行参数提供。或者，实现可以提供一个初始类，该类设置一个类加载器，该加载器反过来加载应用程序。只要与前一段中给出的规范一致，初始类的其他选择也是可能的。</p><hr><h2 id="5-3-Creation-and-Loading"><a href="#5-3-Creation-and-Loading" class="headerlink" title="5.3 Creation and Loading"></a>5.3 Creation and Loading</h2><p>Creation of a class or interface C denoted by the name N consists of the construction in the method area of the Java Virtual Machine (§2.5.4) of an implementation-specific internal representation of C. Class or interface creation is triggered by another class or interface D, which references C through its run-time constant pool.</p><p>表示为名称N的类或接口C的创建包括在Java虚拟机 (§2.5.4) 的方法区中构建C的实现特定的内部表示。类或接口的创建是由另一个类或接口D触发的，D通过其运行时常量池引用C。</p><p>Class or interface creation may also be triggered by D invoking methods in certain Java SE platform class libraries (§2.12) such as reflection.</p><p>类或接口的创建还可能由D在某些Java SE平台类库中调用方法（例如反射）触发。</p><p>If C is not an array class, it is created by loading a binary representation of C (§4 (The class File Format)) using a class loader. Array classes do not have an external binary representation; they are created by the Java Virtual Machine rather than by a class loader.</p><p>如果C不是数组类，则通过使用类加载器加载C的二进制表示 (§4 (类文件格式)) 创建它。数组类没有外部二进制表示；它们是由Java虚拟机创建的，而不是由类加载器创建的。</p><p>There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders. Every user-defined class loader is an instance of a subclass of the abstract class <code>ClassLoader</code>. Applications employ user-defined class loaders in order to extend the manner in which the Java Virtual Machine dynamically loads and thereby creates classes. User-defined class loaders can be used to create classes that originate from user-defined sources. For example, a class could be downloaded across a network, generated on the fly, or extracted from an encrypted file.</p><p>有两种类加载器：Java虚拟机提供的引导类加载器和用户定义的类加载器。每个用户定义的类加载器都是抽象类<code>ClassLoader</code>子类的实例。应用程序使用用户定义的类加载器来扩展Java虚拟机动态加载并从而创建类的方式。用户定义的类加载器可用于创建源自用户定义源的类。例如，一个类可以通过网络下载，动态生成，或从加密文件中提取。</p><p>A class loader L may create C by defining it directly or by delegating to another class loader. If L creates C directly, we say that L defines C or, equivalently, that L is the defining loader of C.</p><p>类加载器L可以通过直接定义C或委托给另一个类加载器来创建C。如果L直接创建C，我们称L定义了C，或等同于说L是C的定义加载器。</p><p>When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class. If L creates C, either by defining it directly or by delegation, we say that L initiates loading of C or, equivalently, that L is an initiating loader of C.</p><p>当一个类加载器委托给另一个类加载器时，发起加载的加载器不一定是完成加载并定义类的加载器。如果L创建C，无论是直接定义还是通过委托，我们称L发起了C的加载，或等同于说L是C的发起加载器。</p><p>At run time, a class or interface is determined not by its name alone, but by a pair: its binary name (§4.2.1) and its defining class loader. Each such class or interface belongs to a single run-time package. The run-time package of a class or interface is determined by the package name and defining class loader of the class or interface.</p><p>在运行时，类或接口不仅由其名称确定，还由一对：其二进制名称 (§4.2.1) 和定义类加载器。每个此类类或接口都属于单一的运行时包。类或接口的运行时包由类或接口的包名称和定义类加载器确定。</p><p>The Java Virtual Machine uses one of three procedures to create class or interface C denoted by N:</p><p>Java虚拟机使用以下三种程序之一来创建表示为N的类或接口C：</p><ul><li><p>If N denotes a non-array class or an interface, one of the two following methods is used to load and thereby create C:</p><ul><li>If D was defined by the bootstrap class loader, then the bootstrap class loader initiates loading of C (§5.3.1).</li><li>If D was defined by a user-defined class loader, then that same user-defined class loader initiates loading of C (§5.3.2).</li></ul></li><li><p>如果N表示非数组类或接口，则使用以下两种方法之一来加载并从而创建C：</p><ul><li>如果D是由引导类加载器定义的，则由引导类加载器发起C的加载 (§5.3.1)。</li><li>如果D是由用户定义的类加载器定义的，则由同一个用户定义的类加载器发起C的加载 (§5.3.2)。</li></ul></li><li><p>Otherwise N denotes an array class. An array class is created directly by the Java Virtual Machine (§5.3.3), not by a class loader. However, the defining class loader of D is used in the process of creating array class C.</p></li><li><p>否则N表示数组类。数组类直接由Java虚拟机创建 (§5.3.3)，而不是由类加载器创建。但是，在创建数组类C的过程中使用了D的定义类加载器。</p></li></ul><p>If an error occurs during class loading, then an instance of a subclass of <code>LinkageError</code> must be thrown at a point in the program that (directly or indirectly) uses the class or interface being loaded.</p><p>如果在类加载过程中发生错误，则必须在程序中使用（直接或间接）正在加载的类或接口的地方抛出<code>LinkageError</code>子类的实例。</p><p>If the Java Virtual Machine ever attempts to load a class C during verification (§5.4.1) or resolution (§5.4.3) (but not initialization (§5.5)), and the class loader that is used to initiate loading of C throws an instance of <code>ClassNotFoundException</code>, then the Java Virtual Machine must throw an instance of <code>NoClassDefFoundError</code> whose cause is the instance of <code>ClassNotFoundException</code>.</p><p>如果Java虚拟机在验证 (§5.4.1) 或解析 (§5.4.3) （但不是初始化 (§5.5)）过程中尝试加载类C，并且用于发起C加载的类加载器抛出<code>ClassNotFoundException</code>的实例，则Java虚拟机必须抛出<code>NoClassDefFoundError</code>实例，其原因是<code>ClassNotFoundException</code>实例。</p><p>(A subtlety here is that recursive class loading to load superclasses is performed as part of resolution (§5.3.5, step 3). Therefore, a <code>ClassNotFoundException</code> that results from a class loader failing to load a superclass must be wrapped in a <code>NoClassDefFoundError</code>.)</p><p>（这里的一个微妙之处在于，加载超类的递归类加载作为解析 (§5.3.5, 第3步) 的一部分进行。因此，由类加载器无法加载超类而导致的<code>ClassNotFoundException</code>必须包装在<code>NoClassDefFoundError</code>中。）</p><p>A well-behaved class loader should maintain three properties:</p><p>一个表现良好的类加载器应该保持三个属性：</p><ul><li><p>Given the same name, a good class loader should always return the same <code>Class</code> object.</p></li><li><p>对于相同的名称，一个好的类加载器应始终返回相同的<code>Class</code>对象。</p></li><li><p>If a class loader L delegates loading of a class C to another loader L’, then for any type T that occurs as the direct superclass or a direct superinterface of C, or as the type of a field in C, or as the type of a formal parameter of a method or constructor in C, or as a return type of a method in C, L and L’ should return the same <code>Class</code> object.</p></li><li><p>如果类加载器L将类C的加载委托给另一个加载器L’，那么对于作为C的直接超类或直接超接口出现的任何类型T，或作为C中的字段类型，或作为C中方法或构造函数的形式参数类型，或作为C中方法的返回类型，L和L’应返回相同的<code>Class</code>对象。</p></li><li><p>If a user-defined classloader prefetches binary representations of classes and interfaces, or loads a group of related classes together, then it must reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.</p></li><li><p>如果用户定义的类加载器预先获取类和接口的二进制表示，或一起加载一组相关类，则它必须仅在程序中可能发生错误的点上反映加载错误，而不会因预先获取或组加载而产生错误。</p></li></ul><p>We will sometimes represent a class or interface using the notation <code>&lt;N, L&gt;</code>, where N denotes the name of the class or interface and L denotes the defining loader of the class or interface.</p><p>我们有时会使用符号 <code>&lt;N, L&gt;</code> 来表示一个类或接口，其中N表示类或接口的名称，L表示类或接口的定义加载器。</p><p>We will also represent a class or interface using the notation <code>N^Li</code>, where N denotes the name of the class or interface and Li denotes an initiating loader of the class or interface.</p><p>我们还将使用符号 <code>N^Li</code> 来表示一个类或接口，其中N表示类或接口的名称，Li表示类或接口的发起加载器。</p><hr><h3 id="5-3-1-Loading-Using-the-Bootstrap-Class-Loader"><a href="#5-3-1-Loading-Using-the-Bootstrap-Class-Loader" class="headerlink" title="5.3.1 Loading Using the Bootstrap Class Loader"></a>5.3.1 Loading Using the Bootstrap Class Loader</h3><p>The following steps are used to load and thereby create the non-array class or interface C denoted by N using the bootstrap class loader.</p><p>使用引导类加载器加载并从而创建非数组类或接口C的步骤如下：</p><ol><li><p>First, the Java Virtual Machine determines whether the bootstrap class loader has already been recorded as an initiating loader of a class or interface denoted by N. If so, this class or interface is C, and no class creation is necessary.</p></li><li><p>首先，Java虚拟机确定引导类加载器是否已被记录为由N表示的类或接口的发起加载器。如果是这样，这个类或接口就是C，不需要创建类。</p></li><li><p>Otherwise, the Java Virtual Machine passes the argument N to an invocation of a method on the bootstrap class loader to search for a purported representation of C in a platform-dependent manner. Typically, a class or interface will be represented using a file in a hierarchical file system, and the name of the class or interface will be encoded in the pathname of the file.</p></li><li><p>否则，Java虚拟机会将参数N传递给引导类加载器上的方法调用，以平台依赖的方式搜索C的假定表示。通常，类或接口将使用分层文件系统中的文件表示，并且类或接口的名称将编码在文件的路径名中。</p></li><li><p>Note that there is no guarantee that a purported representation found is valid or is a representation of C. This phase of loading must detect the following error:</p><ul><li>If no purported representation of C is found, loading throws an instance of <code>ClassNotFoundException</code>.</li></ul></li><li><p>请注意，找到的假定表示是否有效或是否为C的表示没有保证。加载的这个阶段必须检测以下错误：</p><ul><li>如果未找到C的假定表示，加载会抛出<code>ClassNotFoundException</code>实例。</li></ul></li><li><p>Then the Java Virtual Machine attempts to derive a class denoted by N using the bootstrap class loader from the purported representation using the algorithm found in §5.3.5. That class is C.</p></li><li><p>然后，Java虚拟机会尝试使用引导类加载器通过§5.3.5中找到的算法从假定表示中派生一个由N表示的类。那个类就是C。</p></li></ol><hr><h3 id="5-3-2-Loading-Using-a-User-defined-Class-Loader"><a href="#5-3-2-Loading-Using-a-User-defined-Class-Loader" class="headerlink" title="5.3.2 Loading Using a User-defined Class Loader"></a>5.3.2 Loading Using a User-defined Class Loader</h3><p>The following steps are used to load and thereby create the non-array class or interface C denoted by N using a user-defined class loader L.</p><p>使用用户定义的类加载器L加载并从而创建由N表示的非数组类或接口C的步骤如下：</p><ol><li><p>First, the Java Virtual Machine determines whether L has already been recorded as an initiating loader of a class or interface denoted by N. If so, this class or interface is C, and no class creation is necessary.</p></li><li><p>首先，Java虚拟机确定L是否已被记录为由N表示的类或接口的发起加载器。如果是这样，这个类或接口就是C，不需要创建类。</p></li><li><p>Otherwise, the Java Virtual Machine invokes <code>loadClass(N)</code> on L. The value returned by the invocation is the created class or interface C. The Java Virtual Machine then records that L is an initiating loader of C (§5.3.4). The remainder of this section describes this process in more detail.</p></li><li><p>否则，Java虚拟机在L上调用<code>loadClass(N)</code>。调用返回的值是创建的类或接口C。然后，Java虚拟机记录L是C的发起加载器 (§5.3.4)。本节的其余部分更详细地描述了这个过程。</p></li><li><p>When the <code>loadClass</code> method of the class loader L is invoked with the name N of a class or interface C to be loaded, L must perform one of the following two operations in order to load C:</p><ol><li>The class loader L can create an array of bytes representing C as the bytes of a <code>ClassFile</code> structure (§4.1); it then must invoke the method <code>defineClass</code> of class <code>ClassLoader</code>. Invoking <code>defineClass</code> causes the Java Virtual Machine to derive a class or interface denoted by N using L from the array of bytes using the algorithm found in §5.3.5.</li><li>The class loader L can delegate the loading of C to some other class loader L’. This is accomplished by passing the argument N directly or indirectly to an invocation of a method on L’ (typically the <code>loadClass</code> method). The result of the invocation is C.</li></ol></li><li><p>当类加载器L的<code>loadClass</code>方法被调用并指定要加载的类或接口C的名称N时，L必须执行以下两项操作之一以加载C：</p><ol><li>类加载器L可以创建表示C的字节数组作为<code>ClassFile</code>结构 (§4.1) 的字节；然后必须调用<code>ClassLoader</code>类的<code>defineClass</code>方法。调用<code>defineClass</code>会导致Java虚拟机使用L从字节数组中使用§5.3.5中找到的算法派生一个由N表示的类或接口。</li><li>类加载器L可以将C的加载委托给其他类加载器L’。这是通过将参数N直接或间接传递给L’上的方法调用（通常是<code>loadClass</code>方法）来完成的。调用的结果是C。</li></ol></li><li><p>In either (1) or (2), if the class loader L is unable to load a class or interface denoted by N for any reason, it must throw an instance of <code>ClassNotFoundException</code>.</p></li><li><p>在(1)或(2)中，如果类加载器L因任何原因无法加载由N表示的类或接口，则必须抛出<code>ClassNotFoundException</code>实例。</p></li></ol><p>Since JDK release 1.1, Oracle’s Java Virtual Machine implementation has invoked the <code>loadClass</code> method of a class loader in order to cause it to load a class or interface. The argument to <code>loadClass</code> is the name of the class or interface to be loaded. There is also a two-argument version of the <code>loadClass</code> method, where the second argument is a boolean that indicates whether the class or interface is to be linked or not. Only the two-argument version was supplied in JDK release 1.0.2, and Oracle’s Java Virtual Machine implementation relied on it to link the loaded class or interface. From JDK release 1.1 onward, Oracle’s Java Virtual Machine implementation links the class or interface directly, without relying on the class loader.</p><p>自JDK 1.1版本以来，Oracle的Java虚拟机实现已经调用类加载器的<code>loadClass</code>方法来促使它加载类或接口。<code>loadClass</code>的参数是要加载的类或接口的名称。还有一个带两个参数的<code>loadClass</code>方法版本，其中第二个参数是一个布尔值，指示类或接口是否要链接。JDK 1.0.2版本中只提供了带两个参数的版本，Oracle的Java虚拟机实现依赖它来链接加载的类或接口。从JDK 1.1版本开始，Oracle的Java虚拟机实现直接链接类或接口，而不依赖类加载器。</p><h3 id="5-3-3-Creating-Array-Classes"><a href="#5-3-3-Creating-Array-Classes" class="headerlink" title="5.3.3 Creating Array Classes"></a>5.3.3 Creating Array Classes</h3><p>The following steps are used to create the array class C denoted by N using class loader L. Class loader L may be either the bootstrap class loader or a user-defined class loader.</p><p>使用类加载器L创建由N表示的数组类C的步骤如下。类加载器L可以是引导类加载器或用户定义的类加载器。</p><ol><li><p>If L has already been recorded as an initiating loader of an array class with the same component type as N, that class is C, and no array class creation is necessary.</p></li><li><p>如果L已被记录为与N具有相同组件类型的数组类的发起加载器，则该类就是C，不需要创建数组类。</p></li><li><p>Otherwise, the following steps are performed to create C:</p><ol><li>If the component type is a reference type, the algorithm of this section (§5.3) is applied recursively using class loader L in order to load and thereby create the component type of C.</li><li>The Java Virtual Machine creates a new array class with the indicated component type and number of dimensions.</li></ol></li><li><p>否则，执行以下步骤以创建C：</p><ol><li>如果组件类型是引用类型，则使用类加载器L递归应用本节 (§5.3) 的算法以加载并从而创建C的组件类型。</li><li>Java虚拟机创建具有指定组件类型和维数的新数组类。</li></ol></li><li><p>If the component type is a reference type, C is marked as having been defined by the defining class loader of the component type. Otherwise, C is marked as having been defined by the bootstrap class loader.</p></li><li><p>如果组件类型是引用类型，则C标记为由组件类型的定义类加载器定义。否则，C标记为由引导类加载器定义。</p></li><li><p>In any case, the Java Virtual Machine then records that L is an initiating loader for C (§5.3.4).</p></li><li><p>无论如何，Java虚拟机随后记录L是C的发起加载器 (§5.3.4)。</p></li><li><p>If the component type is a reference type, the accessibility of the array class is determined by the accessibility of its component type. Otherwise, the accessibility of the array class is public.</p></li><li><p>如果组件类型是引用类型，数组类的可访问性由其组件类型的可访问性决定。否则，数组类的可访问性为公共。</p></li></ol><hr><h3 id="5-3-4-Loading-Constraints"><a href="#5-3-4-Loading-Constraints" class="headerlink" title="5.3.4 Loading Constraints"></a>5.3.4 Loading Constraints</h3><p>Ensuring type-safe linkage in the presence of class loaders requires special care. It is possible that when two different class loaders initiate loading of a class or interface denoted by N, the name N may denote a different class or interface in each loader.</p><p>在类加载器存在的情况下确保类型安全的链接需要特别小心。当两个不同的类加载器发起由N表示的类或接口的加载时，N可能在每个加载器中表示不同的类或接口。</p><p>When a class or interface C &#x3D; <code>&lt;N1, L1&gt;</code> makes a symbolic reference to a field or method of another class or interface D &#x3D; <code>&lt;N2, L2&gt;</code>, the symbolic reference includes a descriptor specifying the type of the field, or the return and argument types of the method. It is essential that any type name N mentioned in the field or method descriptor denote the same class or interface when loaded by L1 and when loaded by L2.</p><p>当类或接口C &#x3D; <code>&lt;N1, L1&gt;</code> 对另一个类或接口D &#x3D; <code>&lt;N2, L2&gt;</code> 的字段或方法进行符号引用时，符号引用包括指定字段类型或方法的返回和参数类型的描述符。至关重要的是，字段或方法描述符中提到的任何类型名N在L1加载和L2加载时表示相同的类或接口。</p><p>To ensure this, the Java Virtual Machine imposes loading constraints of the form <code>L1L2 N1 = N2</code> during preparation (§5.4.2) and resolution (§5.4.3). To enforce these constraints, the Java Virtual Machine will, at certain prescribed times (see §5.3.1, §5.3.2, §5.3.3, and §5.3.5), record that a particular loader is an initiating loader of a particular class. After recording that a loader is an initiating loader of a class, the Java Virtual Machine must immediately check to see if any loading constraints are violated. If so, the record is retracted, the Java Virtual Machine throws a <code>LinkageError</code>, and the loading operation that caused the recording to take place fails.</p><p>为确保这一点，Java虚拟机在准备 (§5.4.2) 和解析 (§5.4.3) 期间施加形式为 <code>L1L2 N1 = N2</code> 的加载约束。为了强制执行这些约束，Java虚拟机将在某些规定的时间点（见§5.3.1，§5.3.2，§5.3.3，和§5.3.5）记录特定加载器是特定类的发起加载器。记录加载器是类的发起加载器后，Java虚拟机必须立即检查是否违反了任何加载约束。如果是，记录将被撤回，Java虚拟机抛出<code>LinkageError</code>，并且导致记录发生的加载操作失败。</p><p>Similarly, after imposing a loading constraint (see §5.4.2, §5.4.3.2, §5.4.3.3, and §5.4.3.4), the Java Virtual Machine must immediately check to see if any loading constraints are violated. If so, the newly imposed loading constraint is retracted, the Java Virtual Machine throws a <code>LinkageError</code>, and the operation that caused the constraint to be imposed (either resolution or preparation, as the case may be) fails.</p><p>同样，在施加加载约束后（见§5.4.2，§5.4.3.2，§5.4.3.3和§5.4.3.4），Java虚拟机必须立即检查是否违反了任何加载约束。如果是，刚施加的加载约束将被撤回，Java虚拟机抛出<code>LinkageError</code>，并且导致施加该约束的操作（无论是解析还是准备）失败。</p><p>The situations described here are the only times at which the Java Virtual Machine checks whether any loading constraints have been violated. A loading constraint is violated if, and only if, all the following four conditions hold:</p><p>这里描述的情况是Java虚拟机检查是否违反任何加载约束的唯一时间。加载约束在且仅在以下四个条件全部成立时违反：</p><ol><li><p>There exists a loader L such that L has been recorded by the Java Virtual Machine as an initiating loader of a class C named N.</p></li><li><p>存在一个加载器L，该加载器已被Java虚拟机记录为名为N的类C的发起加载器。</p></li><li><p>There exists a loader L’ such that L’ has been recorded by the Java Virtual Machine as an initiating loader of a class C’ named N.</p></li><li><p>存在一个加载器L’，该加载器已被Java虚拟机记录为名为N的类C’的发起加载器。</p></li><li><p>The equivalence relation defined by the (transitive closure of the) set of imposed L1L2 constraints implies <code>N1 = N2</code>.</p></li><li><p>由施加的L1L2约束集合（的传递闭包）定义的等价关系暗示 <code>N1 = N2</code>。</p></li><li><p>C ≠ C’.</p></li><li><p>C ≠ C’。</p></li></ol><p>A full discussion of class loaders and type safety is beyond the scope of this specification.</p><p>关于类加载器和类型安全的全面讨论超出了本规范的范围。</p><p>For a more comprehensive discussion, readers are referred to <em>Dynamic Class Loading in the Java Virtual Machine</em> by Sheng Liang and Gilad Bracha (Proceedings of the 1998 ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications).</p><p>有关更全面的讨论，读者可以参考Sheng Liang和Gilad Bracha撰写的《Java虚拟机中的动态类加载》一文（发表于1998年ACM SIGPLAN面向对象编程系统、语言和应用程序会议论文集）。</p><hr><h3 id="5-3-5-Deriving-a-Class-from-a-class-File-Representation"><a href="#5-3-5-Deriving-a-Class-from-a-class-File-Representation" class="headerlink" title="5.3.5 Deriving a Class from a class File Representation"></a>5.3.5 Deriving a Class from a class File Representation</h3><p>The following steps are used to derive a <code>Class</code> object for the non-array class or interface C denoted by N using loader L from a purported representation in class file format.</p><p>以下步骤用于从类文件格式的假定表示中使用加载器L派生表示为N的非数组类或接口C的<code>Class</code>对象。</p><ol><li><p>First, the Java Virtual Machine determines whether it has already recorded that L is an initiating loader of a class or interface denoted by N. If so, this creation attempt is invalid and loading throws a <code>LinkageError</code>.</p></li><li><p>首先，Java虚拟机确定是否已经记录L是由N表示的类或接口的发起加载器。如果是这样，这次创建尝试无效，加载会抛出<code>LinkageError</code>。</p></li><li><p>Otherwise, the Java Virtual Machine attempts to parse the purported representation. However, the purported representation may not in fact be a valid representation of C.</p></li><li><p>否则，Java虚拟机会尝试解析假定表示。然而，假定表示可能实际上并不是C的有效表示。</p></li></ol><p>This phase of loading must detect the following errors:</p><p>加载的这个阶段必须检测以下错误：</p><ul><li><p>If the purported representation is not a <code>ClassFile</code> structure (§4.1, §4.8), loading throws an instance of <code>ClassFormatError</code>.</p></li><li><p>如果假定表示不是<code>ClassFile</code>结构 (§4.1, §4.8)，加载会抛出<code>ClassFormatError</code>实例。</p></li><li><p>Otherwise, if the purported representation is not of a supported major or minor version (§4.1), loading throws an instance of <code>UnsupportedClassVersionError</code>.</p></li><li><p>否则，如果假定表示不是受支持的主版本或次版本 (§4.1)，加载会抛出<code>UnsupportedClassVersionError</code>实例。</p></li><li><p>Otherwise, if the purported representation does not actually represent a class named N, loading throws an instance of <code>NoClassDefFoundError</code> or an instance of one of its subclasses.</p></li><li><p>否则，如果假定表示实际上并不表示名为N的类，加载会抛出<code>NoClassDefFoundError</code>实例或其子类的实例。</p></li></ul><ol start="3"><li><p>If C has a direct superclass, the symbolic reference from C to its direct superclass is resolved using the algorithm of §5.4.3.1. Note that if C is an interface it must have <code>Object</code> as its direct superclass, which must already have been loaded. Only <code>Object</code> has no direct superclass.</p></li><li><p>如果C有直接超类，则使用§5.4.3.1的算法解析C到其直接超类的符号引用。请注意，如果C是接口，则必须将<code>Object</code>作为其直接超类，并且必须已经加载。只有<code>Object</code>没有直接超类。</p></li></ol><p>Any exceptions that can be thrown due to class or interface resolution can be thrown as a result of this phase of loading. In addition, this phase of loading must detect the following errors:</p><p>由于类或接口解析而可能抛出的任何异常都可能作为加载的这个阶段的结果抛出。此外，加载的这个阶段必须检测以下错误：</p><ul><li><p>If the class or interface named as the direct superclass of C is in fact an interface, loading throws an <code>IncompatibleClassChangeError</code>.</p></li><li><p>如果C的直接超类命名的类或接口实际上是接口，加载会抛出<code>IncompatibleClassChangeError</code>。</p></li><li><p>Otherwise, if any of the superclasses of C is C itself, loading throws a <code>ClassCircularityError</code>.</p></li><li><p>否则，如果C的任何超类是C本身，加载会抛出<code>ClassCircularityError</code>。</p></li></ul><ol start="4"><li><p>If C has any direct superinterfaces, the symbolic references from C to its direct superinterfaces are resolved using the algorithm of §5.4.3.1.</p></li><li><p>如果C有任何直接超接口，则使用§5.4.3.1的算法解析C到其直接超接口的符号引用。</p></li></ol><p>Any exceptions that can be thrown due to class or interface resolution can be thrown as a result of this phase of loading. In addition, this phase of loading must detect the following errors:</p><p>由于类或接口解析而可能抛出的任何异常都可能作为加载的这个阶段的结果抛出。此外，加载的这个阶段必须检测以下错误：</p><ul><li><p>If any of the classes or interfaces named as direct superinterfaces of C is not in fact an interface, loading throws an <code>IncompatibleClassChangeError</code>.</p></li><li><p>如果C的直接超接口命名的类或接口实际上不是接口，加载会抛出<code>IncompatibleClassChangeError</code>。</p></li><li><p>Otherwise, if any of the superinterfaces of C is C itself, loading throws a <code>ClassCircularityError</code>.</p></li><li><p>否则，如果C的任何超接口是C本身，加载会抛出<code>ClassCircularityError</code>。</p></li></ul><ol start="5"><li><p>The Java Virtual Machine marks C as having L as its defining class loader and records that L is an initiating loader of C (§5.3.4).</p></li><li><p>Java虚拟机将C标记为由L作为其定义类加载器，并记录L是C的发起加载器 (§5.3.4)。</p></li></ol><hr><h2 id="5-4-Linking"><a href="#5-4-Linking" class="headerlink" title="5.4 Linking"></a>5.4 Linking</h2><p>Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p><p>链接类或接口涉及验证和准备该类或接口、其直接超类、其直接超接口和其元素类型（如果是数组类型），如果有必要的话。解析类或接口中的符号引用是链接的可选部分。</p><p>This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained:</p><p>本规范允许实现者在何时进行链接活动（并且由于递归，还包括加载）方面具有灵活性，前提是必须保持以下所有属性：</p><ol><li><p>A class or interface is completely loaded before it is linked.</p></li><li><p>类或接口在链接之前必须完全加载。</p></li><li><p>A class or interface is completely verified and prepared before it is initialized.</p></li><li><p>类或接口在初始化之前必须完全验证并准备。</p></li><li><p>Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.</p></li><li><p>在链接过程中检测到的错误会在程序中某个采取行动的点上抛出，该行动可能直接或间接地需要链接到涉及错误的类或接口。</p></li></ol><p>For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used (“lazy” or “late” resolution), or to resolve them all at once when the class is being verified (“eager” or “static” resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Whichever strategy is followed, any error detected during resolution must be thrown at a point in the program that (directly or indirectly) uses a symbolic reference to the class or interface.</p><p>例如，Java虚拟机实现可以选择在使用类或接口中的每个符号引用时单独解析它们（“惰性”或“延迟”解析），或者在验证类时一次性解析它们（“急切”或“静态”解析）。这意味着在某些实现中，解析过程可能在类或接口初始化之后继续进行。无论采用哪种策略，解析过程中检测到的任何错误必须在程序中使用符号引用类或接口的点上抛出。</p><p>Because linking involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>.</p><p>由于链接涉及分配新的数据结构，因此可能因<code>OutOfMemoryError</code>失败。</p><h3 id="5-4-1-Verification"><a href="#5-4-1-Verification" class="headerlink" title="5.4.1 Verification"></a>5.4.1 Verification</h3><p>Verification (§4.10) ensures that the binary representation of a class or interface is structurally correct (§4.9). Verification may cause additional classes and interfaces to be loaded (§5.3) but need not cause them to be verified or prepared.</p><p>验证 (§4.10) 确保类或接口的二进制表示在结构上是正确的 (§4.9)。验证可能会导致加载其他类和接口 (§5.3)，但不必对它们进行验证或准备。</p><p>If the binary representation of a class or interface does not satisfy the static or structural constraints listed in §4.9, then a <code>VerifyError</code> must be thrown at the point in the program that caused the class or interface to be verified.</p><p>如果类或接口的二进制表示不满足§4.9中列出的静态或结构约束，则必须在导致类或接口被验证的程序点上抛出<code>VerifyError</code>。</p><p>If an attempt by the Java Virtual Machine to verify a class or interface fails because an error is thrown that is an instance of <code>LinkageError</code> (or a subclass), then subsequent attempts to verify the class or interface always fail with the same error that was thrown as a result of the initial verification attempt.</p><p>如果Java虚拟机尝试验证类或接口失败，因为抛出了<code>LinkageError</code>（或其子类）的实例，则随后对该类或接口的验证尝试将始终因最初验证尝试抛出的相同错误而失败。</p><h3 id="5-4-2-Preparation"><a href="#5-4-2-Preparation" class="headerlink" title="5.4.2 Preparation"></a>5.4.2 Preparation</h3><p>Preparation involves creating the static fields for a class or interface and initializing such fields to their default values (§2.3, §2.4). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.</p><p>准备包括为类或接口创建静态字段并将这些字段初始化为其默认值 (§2.3, §2.4)。这不需要执行任何Java虚拟机代码；静态字段的显式初始化器作为初始化 (§5.5) 的一部分执行，而不是准备的一部分。</p><p>During preparation of a class or interface C, the Java Virtual Machine also imposes loading constraints (§5.3.4). Let L1 be the defining loader of C. For each method m declared in C that overrides (§5.4.5) a method declared in a superclass or superinterface <code>&lt;D, L2&gt;</code>, the Java Virtual Machine imposes the following loading constraints:</p><p>在准备类或接口C期间，Java虚拟机还施加加载约束 (§5.3.4)。设L1为C的定义加载器。对于C中声明的每个覆盖 (§5.4.5) 超类或超接口 <code>&lt;D, L2&gt;</code> 声明的方法m，Java虚拟机施加以下加载约束：</p><ol><li><p>Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, …, Tfn, then:</p></li><li><p>给定m的返回类型是Tr，m的形式参数类型是Tf1，…，Tfn，那么：</p></li></ol><ul><li><p>If Tr is not an array type, let Tr0 be Tr; otherwise, let Tr0 be the element type (§2.4) of Tr.</p></li><li><p>如果Tr不是数组类型，则设Tr0为Tr；否则，设Tr0为Tr的元素类型 (§2.4)。</p></li><li><p>For i &#x3D; 1 to n: If Tfi is not an array type, let Tfi0 be Tfi; otherwise, let Tfi0 be the element type (§2.4) of Tfi.</p></li><li><p>对于i &#x3D; 1到n：如果Tfi不是数组类型，则设Tfi0为Tfi；否则，设Tfi0为Tfi的元素类型 (§2.4)。</p></li><li><p>L1L2 Then Tr0 &#x3D; Tr and Tfi0 &#x3D; Tfi for i &#x3D; 1 to n.</p></li><li><p>L1L2 然后Tr0 &#x3D; Tr且Tfi0 &#x3D; Tfi，适用于i &#x3D; 1到n。</p></li></ul><p>Furthermore, if C implements a method m declared in a superinterface <code>&lt;I, L3&gt;</code> of C, but C does not itself declare the method m, then let <code>&lt;D, L2&gt;</code> be the superclass of C that declares the implementation of method m inherited by C. The Java Virtual Machine imposes the following constraints:</p><p>此外，如果C实现了超接口 <code>&lt;I, L3&gt;</code> 声明的方法m，但C本身并未声明该方法m，则设 <code>&lt;D, L2&gt;</code> 为C的超类，声明了C继承的方法m的实现。Java虚拟机施加以下约束：</p><ol><li><p>Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, …, Tfn, then:</p></li><li><p>给定m的返回类型是Tr，m的形式参数类型是Tf1，…，Tfn，那么：</p></li></ol><ul><li><p>If Tr is not an array type, let Tr0 be Tr; otherwise, let Tr0 be the element type (§2.4) of Tr.</p></li><li><p>如果Tr不是数组类型，则设Tr0为Tr；否则，设Tr0为Tr的元素类型 (§2.4)。</p></li><li><p>For i &#x3D; 1 to n: If Tfi is not an array type, let Tfi0 be Tfi; otherwise, let Tfi0 be the element type (§2.4) of Tfi.</p></li><li><p>对于i &#x3D; 1到n：如果Tfi不是数组类型，则设Tfi0为Tfi；否则，设Tfi0为Tfi的元素类型 (§2.4)。</p></li><li><p>L23 Then Tr0 &#x3D; Tr and Tfi0 &#x3D; Tfi for i &#x3D; 0 to n.</p></li><li><p>L23 然后Tr0 &#x3D; Tr且Tfi0 &#x3D; Tfi，适用于i &#x3D; 0到n。</p></li></ul><p>Preparation may occur at any time following creation but must be completed prior to initialization.</p><p>准备可能发生在创建之后的任何时间，但必须在初始化之前完成。</p><h3 id="5-4-3-Resolution"><a href="#5-4-3-Resolution" class="headerlink" title="5.4.3 Resolution"></a>5.4.3 Resolution</h3><p>The Java Virtual Machine instructions <code>anewarray</code>, <code>checkcast</code>, <code>getfield</code>, <code>getstatic</code>, <code>instanceof</code>, <code>invokedynamic</code>, <code>invokeinterface</code>, <code>invokespecial</code>, <code>invokestatic</code>, <code>invokevirtual</code>, <code>ldc</code>, <code>ldc_w</code>, <code>multianewarray</code>, <code>new</code>, <code>putfield</code>, and <code>putstatic</code> make symbolic references to the run-time constant pool. Execution of any of these instructions requires resolution of its symbolic reference.</p><p>Java虚拟机指令<code>anewarray</code>、<code>checkcast</code>、<code>getfield</code>、<code>getstatic</code>、<code>instanceof</code>、<code>invokedynamic</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokevirtual</code>、<code>ldc</code>、<code>ldc_w</code>、<code>multianewarray</code>、<code>new</code>、<code>putfield</code>和<code>putstatic</code>对运行时常量池进行了符号引用。执行任何这些指令都需要解析其符号引用。</p><p>Resolution is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>Resolution of the symbolic reference of one occurrence of an <code>invokedynamic</code> instruction does not imply that the same symbolic reference is considered resolved for any other <code>invokedynamic</code> instruction.</p><p>一次<code>invokedynamic</code>指令的符号引用解析并不意味着该符号引用在任何其他<code>invokedynamic</code>指令中都被认为已解析。</p><p>For all other instructions above, resolution of the symbolic reference of one occurrence of an instruction does imply that the same symbolic reference is considered resolved for any other non-<code>invokedynamic</code> instruction.</p><p>对于上述所有其他指令，一次指令的符号引用解析确实意味着该符号引用在任何其他非<code>invokedynamic</code>指令中都被认为已解析。</p><p>(The above text implies that the concrete value determined by resolution for a specific <code>invokedynamic</code> instruction is a call site object bound to that specific <code>invokedynamic</code> instruction.)</p><p>（上述文本暗示，解析为特定<code>invokedynamic</code>指令确定的具体值是绑定到该特定<code>invokedynamic</code>指令的调用站点对象。）</p><p>Resolution can be attempted on a symbolic reference that has already been resolved. An attempt to resolve a symbolic reference that has already successfully been resolved always succeeds trivially and always results in the same entity produced by the initial resolution of that reference.</p><p>解析可以尝试在已解析的符号引用上进行。尝试解析已经成功解析的符号引用总是轻而易举地成功，并且总是产生最初解析该引用时的相同实体。</p><p>If an error occurs during resolution of a symbolic reference, then an instance of <code>IncompatibleClassChangeError</code> (or a subclass) must be thrown at a point in the program that (directly or indirectly) uses the symbolic reference.</p><p>如果在解析符号引用期间发生错误，则必须在程序中使用（直接或间接）符号引用的点上抛出<code>IncompatibleClassChangeError</code>（或其子类）实例。</p><p>If an attempt by the Java Virtual Machine to resolve a symbolic reference fails because an error is thrown that is an instance of <code>LinkageError</code> (or a subclass), then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.</p><p>如果Java虚拟机尝试解析符号引用失败，因为抛出了<code>LinkageError</code>（或其子类）的实例，则随后对该引用的解析尝试将始终因最初解析尝试抛出的相同错误而失败。</p><p>A symbolic reference to a call site specifier by a specific <code>invokedynamic</code> instruction must not be resolved prior to execution of that instruction.</p><p>特定<code>invokedynamic</code>指令对调用站点说明符的符号引用不得在执行该指令之前解析。</p><p>In the case of failed resolution of an <code>invokedynamic</code> instruction, the bootstrap method is not re-executed on subsequent resolution attempts.</p><p>如果<code>invokedynamic</code>指令解析失败，则在随后的解析尝试中不会重新执行引导方法。</p><p>Certain of the instructions above require additional linking checks when resolving symbolic references. For instance, in order for a <code>getfield</code> instruction to successfully resolve the symbolic reference to the field on which it operates, it must not only complete the field resolution steps given in §5.4.3.2 but also check that the field is not static. If it is a static field, a linking exception must be thrown.</p><p>上述某些指令在解析符号引用时需要额外的链接检查。例如，为了使<code>getfield</code>指令成功解析它操作的字段的符号引用，它不仅必须完成§5.4.3.2中给出的字段解析步骤，还必须检查字段是否为静态。如果是静态字段，则必须抛出链接异常。</p><p>Notably, in order for an <code>invokedynamic</code> instruction to successfully resolve the symbolic reference to a call site specifier, the bootstrap method specified therein must complete normally and return a suitable call site object. If the bootstrap method completes abruptly or returns an unsuitable call site object, a linking exception must be thrown.</p><p>特别是，为了使<code>invokedynamic</code>指令成功解析调用站点说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出链接异常。</p><p>Linking exceptions generated by checks that are specific to the execution of a particular Java Virtual Machine instruction are given in the description of that instruction and are not covered in this general discussion of resolution. Note that such exceptions, although described as part of the execution of Java Virtual Machine instructions rather than resolution, are still properly considered failures of resolution.</p><p>由特定Java虚拟机指令执行特定检查生成的链接异常在该指令的描述中给出，并未包含在本一般解析讨论中。请注意，尽管这些异常作为Java虚拟机指令执行的一部分而非解析描述，但仍然被适当地认为是解析失败。</p><p>The following sections describe the process of resolving a symbolic reference in the run-time constant pool (§5.1) of a class or interface D. Details of resolution differ with the kind of symbolic reference to be resolved.</p><p>以下各节描述了在类或接口D的运行时常量池 (§5.1) 中解析符号引用的过程。解析的细节因符号引用的种类而异。</p><h4 id="5-4-3-1-Class-and-Interface-Resolution"><a href="#5-4-3-1-Class-and-Interface-Resolution" class="headerlink" title="5.4.3.1 Class and Interface Resolution"></a>5.4.3.1 Class and Interface Resolution</h4><p>To resolve an unresolved symbolic reference from D to a class or interface C denoted by N, the following steps are performed:</p><p>要解析D到由N表示的类或接口C的未解析符号引用，执行以下步骤：</p><ol><li><p>The defining class loader of D is used to create a class or interface denoted by N. This class or interface is C. The details of the process are given in §5.3.</p></li><li><p>使用D的定义类加载器创建由N表示的类或接口。该类或接口是C。该过程的细节见§5.3。</p></li></ol><p>Any exception that can be thrown as a result of failure of class or interface creation can thus be thrown as a result of failure of class and interface resolution.</p><p>由于类或接口创建失败而可能抛出的任何异常，因此也可能由于类和接口解析失败而抛出。</p><ol start="2"><li><p>If C is an array class and its element type is a reference type, then a symbolic reference to the class or interface representing the element type is resolved by invoking the algorithm in §5.4.3.1 recursively.</p></li><li><p>如果C是数组类并且其元素类型是引用类型，则通过递归调用§5.4.3.1中的算法解析表示元素类型的类或接口的符号引用。</p></li><li><p>Finally, access permissions to C are checked.</p></li><li><p>最后，检查对C的访问权限。</p></li></ol><ul><li><p>If C is not accessible (§5.4.4) to D, class or interface resolution throws an <code>IllegalAccessError</code>.</p></li><li><p>如果C对D不可访问 (§5.4.4)，类或接口解析会抛出<code>IllegalAccessError</code>。</p></li></ul><p>This condition can occur, for example, if C is a class that was originally declared to be public but was changed to be non-public after D was compiled.</p><p>例如，如果C是一个类，最初声明为公共的，但在D编译后更改为非公共的，则可能会发生这种情况。</p><p>If steps 1 and 2 succeed but step 3 fails, C is still valid and usable. Nevertheless, resolution fails, and D is prohibited from accessing C.</p><p>如果步骤1和2成功，但步骤3失败，则C仍然有效且可用。然而，解析失败，并且禁止D访问C。</p><h4 id="5-4-3-2-Field-Resolution"><a href="#5-4-3-2-Field-Resolution" class="headerlink" title="5.4.3.2 Field Resolution"></a>5.4.3.2 Field Resolution</h4><p>To resolve an unresolved symbolic reference from <em>D</em> to a field in a class or interface<br><em>C</em>, the symbolic reference to <em>C</em> given by the field reference must first be resolved<br>(§5.4.3.1). Therefore, any exception that can be thrown as a result of failure of<br>resolution of a class or interface reference can be thrown as a result of failure of<br>field resolution. If the reference to <em>C</em> can be successfully resolved, an exception<br>relating to the failure of resolution of the field reference itself can be thrown.</p><p>要解析类或接口D对类或接口C中字段的未解析符号引用，首先必须解析字段引用所给定的对 C 的符号引用（§5.4.3.1）。因此，解析类或接口引用失败可能引发的任何异常，也可以在字段解析失败时抛出。如果对C的引用能够成功解析，那么可能会抛出与字段引用解析失败相关的异常。如果C的引用可以成功解析，则可能抛出与字段引用解析失败相关的异常。</p><p>When resolving a field reference, field resolution first attempts to look up the referenced field in C and its superclasses:</p><p>在解析字段引用时，字段解析首先尝试在C及其超类中查找引用的字段：</p><ol><li><p>If C declares a field with the name and descriptor specified by the field reference, field lookup succeeds. The declared field is the result of the field lookup.</p></li><li><p>如果C声明了一个具有字段引用指定的名称和描述符的字段，则字段查找成功。声明的字段是字段查找的结果。</p></li><li><p>Otherwise, field lookup is applied recursively to the direct superinterfaces of the specified class or interface C.</p></li><li><p>否则，字段查找递归地应用于指定类或接口C的直接超接口。</p></li><li><p>Otherwise, if C has a superclass S, field lookup is applied recursively to S.</p></li><li><p>否则，如果C有一个超类S，字段查找递归地应用于S。</p></li><li><p>Otherwise, field lookup fails.</p></li><li><p>否则，字段查找失败。</p></li></ol><p>Then:</p><p>接着：</p><ul><li><p>If field lookup fails, field resolution throws a <code>NoSuchFieldError</code>.</p></li><li><p>如果字段查找失败，字段解析会抛出<code>NoSuchFieldError</code>。</p></li><li><p>Otherwise, if field lookup succeeds but the referenced field is not accessible (§5.4.4) to D, field resolution throws an <code>IllegalAccessError</code>.</p></li><li><p>否则，如果字段查找成功，但对D不可访问 (§5.4.4)，字段解析会抛出<code>IllegalAccessError</code>。</p></li><li><p>Otherwise, let <code>&lt;E, L1&gt;</code> be the class or interface in which the referenced field is actually declared and let <code>L2</code> be the defining loader of D.</p></li><li><p>否则，设 <code>&lt;E, L1&gt;</code> 为实际声明引用字段的类或接口，设 <code>L2</code> 为D的定义加载器。</p></li></ul><p>Given that the type of the referenced field is <code>Tf</code>, let <code>Tf0</code> be <code>Tf</code> if <code>Tf</code> is not an array type, and let <code>Tf0</code> be the element type (§2.4) of <code>Tf</code> otherwise.</p><p>假定引用字段的类型为<code>Tf</code>，则如果<code>Tf</code>不是数组类型，则设<code>Tf0</code>为<code>Tf</code>，否则设<code>Tf0</code>为<code>Tf</code>的元素类型 (§2.4)。</p><p>The Java Virtual Machine must impose the loading constraint that <code>L1L2 Tf0 = Tf</code> (§5.3.4).</p><p>Java虚拟机必须施加加载约束 <code>L1L2 Tf0 = Tf</code> (§5.3.4)。</p><h4 id="5-4-3-3-Method-Resolution"><a href="#5-4-3-3-Method-Resolution" class="headerlink" title="5.4.3.3 Method Resolution"></a>5.4.3.3 Method Resolution</h4><p>To resolve an unresolved symbolic reference from D to a method in a class C, the symbolic reference to C given by the method reference is first resolved (§5.4.3.1). Therefore, any exception that can be thrown as a result of failure of resolution of a class reference can be thrown as a result of failure of method resolution. If the reference to C can be successfully resolved, exceptions relating to the resolution of the method reference itself can be thrown.</p><p>要解析D到类C中的方法的未解析符号引用，首先要解析方法引用提供的C的符号引用 (§5.4.3.1)。因此，由于类引用解析失败而可能抛出的任何异常也可能由于方法解析失败而抛出。如果C的引用能够成功解析，则可能抛出与方法引用解析本身有关的异常。</p><p>When resolving a method reference:</p><p>在解析方法引用时：</p><ol><li><p>If C is an interface, method resolution throws an <code>IncompatibleClassChangeError</code>.</p></li><li><p>如果C是一个接口，方法解析会抛出<code>IncompatibleClassChangeError</code>。</p></li><li><p>Otherwise, method resolution attempts to locate the referenced method in C and its superclasses:</p></li><li><p>否则，方法解析尝试在C及其超类中定位引用的方法：</p></li></ol><ul><li><p>If C declares exactly one method with the name specified by the method reference, and the declaration is a signature polymorphic method (§2.9), then method lookup succeeds. All the class names mentioned in the descriptor are resolved (§5.4.3.1).</p></li><li><p>如果C声明了一个与方法引用指定的名称完全一致的方法，并且该声明是签名多态方法 (§2.9)，则方法查找成功。描述符中提到的所有类名都会被解析 (§5.4.3.1)。</p></li><li><p>The resolved method is the signature polymorphic method declaration. It is not necessary for C to declare a method with the descriptor specified by the method reference.</p></li><li><p>解析出来的方法就是签名多态方法声明。C不需要声明与方法引用指定的描述符一致的方法。</p></li><li><p>Otherwise, if C declares a method with the name and descriptor specified by the method reference, method lookup succeeds.</p></li><li><p>否则，如果C声明了一个具有方法引用指定的名称和描述符的方法，方法查找成功。</p></li><li><p>Otherwise, if C has a superclass, step 2 of method resolution is recursively invoked on the direct superclass of C.</p></li><li><p>否则，如果C有一个超类，则在C的直接超类上递归调用方法解析的第2步。</p></li></ul><ol start="3"><li><p>Otherwise, method resolution attempts to locate the referenced method in the superinterfaces of the specified class C:</p></li><li><p>否则，方法解析尝试在指定类C的超接口中定位引用的方法：</p></li></ol><ul><li><p>If the maximally-specific superinterface methods of C for the name and descriptor specified by the method reference include exactly one method that does not have its <code>ACC_ABSTRACT</code> flag set, then this method is chosen and method lookup succeeds.</p></li><li><p>如果C的超接口中具有方法引用指定的名称和描述符的最具体的方法中恰好有一个没有设置<code>ACC_ABSTRACT</code>标志的方法，则选择此方法并且方法查找成功。</p></li><li><p>Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set, one of these is arbitrarily chosen and method lookup succeeds.</p></li><li><p>否则，如果C的任何超接口声明了一个具有方法引用指定的名称和描述符且没有设置<code>ACC_PRIVATE</code>或<code>ACC_STATIC</code>标志的方法，则从这些方法中任意选择一个，方法查找成功。</p></li><li><p>Otherwise, method lookup fails.</p></li><li><p>否则，方法查找失败。</p></li></ul><p>A maximally-specific superinterface method of a class or interface C for a particular method name and descriptor is any method for which all of the following are true:</p><p>对于类或接口C的特定方法名称和描述符，最具体的超接口方法是满足以下所有条件的任何方法：</p><ol><li><p>The method is declared in a superinterface (direct or indirect) of C.</p></li><li><p>该方法声明在C的超接口（直接或间接）中。</p></li><li><p>The method is declared with the specified name and descriptor.</p></li><li><p>该方法以指定的名称和描述符声明。</p></li><li><p>The method has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set.</p></li><li><p>该方法没有设置<code>ACC_PRIVATE</code>或<code>ACC_STATIC</code>标志。</p></li><li><p>Where the method is declared in interface I, there exists no other maximally-specific superinterface method of C with the specified name and descriptor that is declared in a subinterface of I.</p></li><li><p>当方法在接口I中声明时，C没有其他具有指定名称和描述符并且在I的子接口中声明的最具体的超接口方法。</p></li></ol><p>The result of method resolution is determined by whether method lookup succeeds or fails:</p><p>方法解析的结果取决于方法查找的成功或失败：</p><ul><li><p>If method lookup fails, method resolution throws a <code>NoSuchMethodError</code>.</p></li><li><p>如果方法查找失败，方法解析会抛出<code>NoSuchMethodError</code>。</p></li><li><p>Otherwise, if method lookup succeeds and the referenced method is not accessible (§5.4.4) to D, method resolution throws an <code>IllegalAccessError</code>.</p></li><li><p>否则，如果方法查找成功，但对D不可访问 (§5.4.4)，方法解析会抛出<code>IllegalAccessError</code>。</p></li><li><p>Otherwise, let <code>&lt;E, L1&gt;</code> be the class or interface in which the referenced method m is actually declared, and let <code>L2</code> be the defining loader of D.</p></li><li><p>否则，设 <code>&lt;E, L1&gt;</code> 为实际声明引用方法m的类或接口，设 <code>L2</code> 为D的定义加载器。</p></li></ul><p>Given that the return type of m is <code>Tr</code>, and that the formal parameter types of m are <code>Tf1, ..., Tfn</code>, then:</p><p>给定m的返回类型是<code>Tr</code>，m的形式参数类型是<code>Tf1, ..., Tfn</code>，那么：</p><ul><li><p>If <code>Tr</code> is not an array type, let <code>Tr0</code> be <code>Tr</code>; otherwise, let <code>Tr0</code> be the element type (§2.4) of <code>Tr</code>.</p></li><li><p>如果<code>Tr</code>不是数组类型，则设<code>Tr0</code>为<code>Tr</code>；否则，设<code>Tr0</code>为<code>Tr</code>的元素类型 (§2.4)。</p></li><li><p>For i &#x3D; 1 to n: If <code>Tfi</code> is not an array type, let <code>Tfi0</code> be <code>Tfi</code>; otherwise, let <code>Tfi0</code> be the element type (§2.4) of <code>Tfi</code>.</p></li><li><p>对于i &#x3D; 1到n：如果<code>Tfi</code>不是数组类型，则设<code>Tfi0</code>为<code>Tfi</code>；否则，设<code>Tfi0</code>为<code>Tfi</code>的元素类型 (§2.4)。</p></li><li><p>The Java Virtual Machine must impose the loading constraints <code>L1L2 Tr0 = Tr</code> and <code>L1L2 Tfi0 = Tfi</code> for i &#x3D; 0 to n (§5.3.4).</p></li><li><p>Java虚拟机必须施加加载约束 <code>L1L2 Tr0 = Tr</code> 和 <code>L1L2 Tfi0 = Tfi</code>，适用于i &#x3D; 0到n (§5.3.4)。</p></li></ul><p>When resolution searches for a method in the class’s superinterfaces, the best outcome is to identify a maximally-specific non-abstract method. It is possible that this method will be chosen by method selection, so it is desirable to add class loader constraints for it.</p><p>当解析在类的超接口中查找方法时，最好的结果是确定一个最具体的非抽象方法。可能会选择此方法进行方法选择，因此为它添加类加载器约束是可取的。</p><p>Otherwise, the result is nondeterministic. This is not new: The Java® Virtual Machine Specification has never identified exactly which method is chosen, and how “ties” should be broken. Prior to Java SE 8, this was mostly an unobservable distinction. However, beginning with Java SE 8, the set of interface methods is more heterogeneous, so care must be taken to avoid problems with nondeterministic behavior. Thus:</p><p>否则，结果是非确定性的。这并不新鲜：Java®虚拟机规范从未明确指出究竟选择了哪个方法，以及如何“打破平局”。在Java SE 8之前，这大多是一个不可观察的区别。然而，从Java SE 8开始，接口方法的集合更加异质，因此必须小心避免非确定性行为的问题。因此：</p><ol><li><p>Superinterface methods that are private and static are ignored by resolution. This is consistent with the Java programming language, where such interface methods are not inherited.</p></li><li><p>私有和静态的超接口方法在解析时被忽略。这与Java编程语言一致，在Java中，这些接口方法不会被继承。</p></li><li><p>Any behavior controlled by the resolved method should not depend on whether the method is abstract or not.</p></li><li><p>由解析方法控制的任何行为都不应依赖于方法是否是抽象的。</p></li></ol><p>Note that if the result of resolution is an abstract method, the referenced class C may be non-abstract. Requiring C to be abstract would conflict with the nondeterministic choice of superinterface methods. Instead, resolution assumes that the runtime class of the invoked object has a concrete implementation of the method.</p><p>请注意，如果解析的结果是一个抽象方法，则引用的类C可能是非抽象的。要求C是抽象的将与超接口方法的非确定性选择相冲突。相反，解析假定被调用对象的运行时类具有该方法的具体实现。</p><h4 id="5-4-3-4-Interface-Method-Resolution"><a href="#5-4-3-4-Interface-Method-Resolution" class="headerlink" title="5.4.3.4 Interface Method Resolution"></a>5.4.3.4 Interface Method Resolution</h4><p>To resolve an unresolved symbolic reference from D to an interface method in an interface C, the symbolic reference to C given by the interface method reference is first resolved (§5.4.3.1). Therefore, any exception that can be thrown as a result of failure of resolution of an interface reference can be thrown as a result of failure of interface method resolution. If the reference to C can be successfully resolved, exceptions relating to the resolution of the interface method reference itself can be thrown.</p><p>要解析D到接口C中的接口方法的未解析符号引用，首先要解析接口方法引用提供的C的符号引用 (§5.4.3.1)。因此，由于接口引用解析失败而可能抛出的任何异常也可能由于接口方法解析失败而抛出。如果C的引用能够成功解析，则可能抛出与接口方法引用解析本身有关的异常。</p><p>When resolving an interface method reference:</p><p>在解析接口方法引用时：</p><ol><li><p>If C is not an interface, interface method resolution throws an <code>IncompatibleClassChangeError</code>.</p></li><li><p>如果C不是接口，接口方法解析会抛出<code>IncompatibleClassChangeError</code>。</p></li><li><p>Otherwise, if C declares a method with the name and descriptor specified by the interface method reference, method lookup succeeds.</p></li><li><p>否则，如果C声明了一个具有接口方法引用指定的名称和描述符的方法，方法查找成功。</p></li><li><p>Otherwise, if the class <code>Object</code> declares a method with the name and descriptor specified by the interface method reference, which has its <code>ACC_PUBLIC</code> flag set and does not have its <code>ACC_STATIC</code> flag set, method lookup succeeds.</p></li><li><p>否则，如果类<code>Object</code>声明了一个具有接口方法引用指定的名称和描述符的方法，并且该方法设置了<code>ACC_PUBLIC</code>标志但没有设置<code>ACC_STATIC</code>标志，方法查找成功。</p></li><li><p>Otherwise, if the maximally-specific superinterface methods (§5.4.3.3) of C for the name and descriptor specified by the method reference include exactly one method that does not have its <code>ACC_ABSTRACT</code> flag set, then this method is chosen and method lookup succeeds.</p></li><li><p>否则，如果C的超接口中具有方法引用指定的名称和描述符的最具体的方法中恰好有一个没有设置<code>ACC_ABSTRACT</code>标志的方法，则选择此方法并且方法查找成功。</p></li><li><p>Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set, one of these is arbitrarily chosen and method lookup succeeds.</p></li><li><p>否则，如果C的任何超接口声明了一个具有方法引用指定的名称和描述符且没有设置<code>ACC_PRIVATE</code>或<code>ACC_STATIC</code>标志的方法，则从这些方法中任意选择一个，方法查找成功。</p></li><li><p>Otherwise, method lookup fails.</p></li><li><p>否则，方法查找失败。</p></li></ol><p>The result of interface method resolution is determined by whether method lookup succeeds or fails:</p><p>接口方法解析的结果取决于方法查找的成功或失败：</p><ul><li><p>If method lookup fails, interface method resolution throws a <code>NoSuchMethodError</code>.</p></li><li><p>如果方法查找失败，接口方法解析会抛出<code>NoSuchMethodError</code>。</p></li><li><p>If method lookup succeeds and the referenced method is not accessible (§5.4.4) to D, interface method resolution throws an <code>IllegalAccessError</code>.</p></li><li><p>如果方法查找成功，但对D不可访问 (§5.4.4)，接口方法解析会抛出<code>IllegalAccessError</code>。</p></li><li><p>Otherwise, let <code>&lt;E, L1&gt;</code> be the class or interface in which the referenced interface method m is actually declared, and let <code>L2</code> be the defining loader of D.</p></li><li><p>否则，设 <code>&lt;E, L1&gt;</code> 为实际声明引用接口方法m的类或接口，设 <code>L2</code> 为D的定义加载器。</p></li></ul><p>Given that the return type of m is <code>Tr</code>, and that the formal parameter types of m are <code>Tf1, ..., Tfn</code>, then:</p><p>给定m的返回类型是<code>Tr</code>，m的形式参数类型是<code>Tf1, ..., Tfn</code>，那么：</p><ul><li><p>If <code>Tr</code> is not an array type, let <code>Tr0</code> be <code>Tr</code>; otherwise, let <code>Tr0</code> be the element type (§2.4) of <code>Tr</code>.</p></li><li><p>如果<code>Tr</code>不是数组类型，则设<code>Tr0</code>为<code>Tr</code>；否则，设<code>Tr0</code>为<code>Tr</code>的元素类型 (§2.4)。</p></li><li><p>For i &#x3D; 1 to n: If <code>Tfi</code> is not an array type, let <code>Tfi0</code> be <code>Tfi</code>; otherwise, let <code>Tfi0</code> be the element type (§2.4) of <code>Tfi</code>.</p></li><li><p>对于i &#x3D; 1到n：如果<code>Tfi</code>不是数组类型，则设<code>Tfi0</code>为<code>Tfi</code>；否则，设<code>Tfi0</code>为<code>Tfi</code>的元素类型 (§2.4)。</p></li><li><p>The Java Virtual Machine must impose the loading constraints <code>L1L2 Tr0 = Tr</code> and <code>L1L2 Tfi0 = Tfi</code> for i &#x3D; 0 to n (§5.3.4).</p></li><li><p>Java虚拟机必须施加加载约束 <code>L1L2 Tr0 = Tr</code> 和 <code>L1L2 Tfi0 = Tfi</code>，适用于i &#x3D; 0到n (§5.3.4)。</p></li></ul><p>The clause about accessibility is necessary because interface method resolution may pick a private method of interface C. (Prior to Java SE 8, the result of interface method resolution could be a non-public method of class <code>Object</code> or a static method of class <code>Object</code>; such results were not consistent with the inheritance model of the Java programming language, and are disallowed in Java SE 8 and above.)</p><p>关于可访问性的条款是必要的，因为接口方法解析可能会选择接口C的私有方法。（在Java SE 8之前，接口方法解析的结果可能是类<code>Object</code>的非公共方法或类<code>Object</code>的静态方法；这些结果与Java编程语言的继承模型不一致，在Java SE 8及以上版本中是不允许的。）</p><h4 id="5-4-3-5-Method-Type-and-Method-Handle-Resolution"><a href="#5-4-3-5-Method-Type-and-Method-Handle-Resolution" class="headerlink" title="5.4.3.5 Method Type and Method Handle Resolution"></a>5.4.3.5 Method Type and Method Handle Resolution</h4><p>To resolve an unresolved symbolic reference to a method type, it is as if resolution occurs of unresolved symbolic references to classes and interfaces (§5.4.3.1) whose names correspond to the types given in the method descriptor (§4.3.3).</p><p>要解析对方法类型的未解析符号引用，仿佛解析了与方法描述符 (§4.3.3) 中给出的类型对应的类和接口的未解析符号引用 (§5.4.3.1)。</p><p>Any exception that can be thrown as a result of failure of resolution of a class reference can thus be thrown as a result of failure of method type resolution.</p><p>因此，由于类引用解析失败而可能抛出的任何异常也可能由于方法类型解析失败而抛出。</p><p>The result of successful method type resolution is a reference to an instance of <code>java.lang.invoke.MethodType</code> which represents the method descriptor.</p><p>成功的解析方法类型的结果是对<code>java.lang.invoke.MethodType</code>实例的引用，该实例表示方法描述符。</p><p>Method type resolution occurs regardless of whether the runtime constant pool actually contains symbolic references to classes and interfaces indicated in the method descriptor. Also, the resolution is deemed to occur on unresolved symbolic references, so a failure to resolve one method type will not necessarily lead to a later failure to resolve another method type with the same textual method descriptor, if suitable classes and interfaces can be loaded by the later time.</p><p>无论运行时常量池是否实际包含方法描述符中指示的类和接口的符号引用，方法类型解析都会发生。此外，解析被认为发生在未解析的符号引用上，因此解析一种方法类型的失败不会必然导致稍后解析具有相同文本方法描述符的另一种方法类型失败，如果稍后可以加载适当的类和接口。</p><p>Resolution of an unresolved symbolic reference to a method handle is more complicated. Each method handle resolved by the Java Virtual Machine has an equivalent instruction sequence called its bytecode behavior, indicated by the method handle’s kind. The integer values and descriptions of the nine kinds of method handle are given in Table 5.4.3.5-A.</p><p>解析方法句柄的未解析符号引用更加复杂。由Java虚拟机解析的每个方法句柄都有一个等效的指令序列，称为其字节码行为，由方法句柄的种类指示。九种方法句柄的整数值和描述见表5.4.3.5-A。</p><p>Symbolic references by an instruction sequence to fields or methods are indicated by <code>C.x:T</code>, where x and T are the name and descriptor (§4.3.2, §4.3.3) of the field or method, and C is the class or interface in which the field or method is to be found.</p><p>指令序列对字段或方法的符号引用由 <code>C.x:T</code> 表示，其中x和T是字段或方法的名称和描述符 (§4.3.2, §4.3.3)，C是要找到字段或方法的类或接口。</p><p><strong>Table 5.4.3.5-A. Bytecode Behaviors for Method Handles</strong></p><table><thead><tr><th>Kind</th><th>Description</th><th>Interpretation</th></tr></thead><tbody><tr><td>1</td><td><code>REF_getField</code></td><td><code>getfield C.f:T</code></td></tr><tr><td>2</td><td><code>REF_getStatic</code></td><td><code>getstatic C.f:T</code></td></tr><tr><td>3</td><td><code>REF_putField</code></td><td><code>putfield C.f:T</code></td></tr><tr><td>4</td><td><code>REF_putStatic</code></td><td><code>putstatic C.f:T</code></td></tr><tr><td>5</td><td><code>REF_invokeVirtual</code></td><td><code>invokevirtual C.m:(A*)T</code></td></tr><tr><td>6</td><td><code>REF_invokeStatic</code></td><td><code>invokestatic C.m:(A*)T</code></td></tr><tr><td>7</td><td><code>REF_invokeSpecial</code></td><td><code>invokespecial C.m:(A*)T</code></td></tr><tr><td>8</td><td><code>REF_newInvokeSpecial</code></td><td><code>new C; dup; invokespecial C.&lt;init&gt;:(A*)V</code></td></tr><tr><td>9</td><td><code>REF_invokeInterface</code></td><td><code>invokeinterface C.m:(A*)T</code></td></tr></tbody></table><p>Let MH be the symbolic reference to a method handle (§5.1) being resolved. Then:</p><p>设MH为正在解析的方法句柄 (§5.1) 的符号引用。那么：</p><ul><li><p>Let R be the symbolic reference to the field or method contained within MH. (R is derived from the <code>CONSTANT_Fieldref</code>, <code>CONSTANT_Methodref</code>, or <code>CONSTANT_InterfaceMethodref</code> structure referred to by the <code>reference_index</code> item of the <code>CONSTANT_MethodHandle</code> from which MH is derived.)</p></li><li><p>设R为MH中包含的字段或方法的符号引用。（R派生自<code>CONSTANT_Fieldref</code>、<code>CONSTANT_Methodref</code>或<code>CONSTANT_InterfaceMethodref</code>结构，引用由MH派生的<code>CONSTANT_MethodHandle</code>的<code>reference_index</code>项。）</p></li><li><p>Let T be the type of the field referenced by R, or the return type of the method referenced by R. Let A* be the sequence (perhaps empty) of parameter types of the method referenced by R.</p></li><li><p>设T为R引用的字段的类型，或R引用的方法的返回类型。设A*为R引用的方法的参数类型序列（可能为空）。</p></li><li><p>(T and A* are derived from the <code>CONSTANT_NameAndType</code> structure referred to by the <code>name_and_type_index</code> item in the <code>CONSTANT_Fieldref</code>, <code>CONSTANT_Methodref</code>, or <code>CONSTANT_InterfaceMethodref</code> structure from which R is derived.)</p></li><li><p>（T和A*派生自<code>CONSTANT_NameAndType</code>结构，引用由R派生的<code>CONSTANT_Fieldref</code>、<code>CONSTANT_Methodref</code>或<code>CONSTANT_InterfaceMethodref</code>结构中的<code>name_and_type_index</code>项。）</p></li></ul><p>To resolve MH, all symbolic references to classes, interfaces, fields, and methods in MH’s bytecode behavior are resolved, using the following three steps:</p><p>要解析MH，必须解析MH字节码行为中的所有符号引用，包括类、接口、字段和方法，使用以下三步：</p><ol><li><p>First, R is resolved.</p></li><li><p>首先，解析R。</p></li><li><p>Second, resolution occurs as if of unresolved symbolic references to classes and interfaces whose names correspond to each type in A*, and to the type T, in that order.</p></li><li><p>其次，解析仿佛未解析的符号引用，依次对应A*中的每种类型和类型T的类和接口的名称。</p></li><li><p>Third, a reference to an instance of <code>java.lang.invoke.MethodType</code> is obtained as if by resolution of an unresolved symbolic reference to a method type that contains the method descriptor specified in <strong>Table 5.4.3.5-B</strong> for the kind of MH.</p></li><li><p>第三，通过解析未解析的符号引用获得对<code>java.lang.invoke.MethodType</code>实例的引用，仿佛该引用包含表5.4.3.5-B中指定的与MH类型相对应的方法描述符。</p></li></ol><p>It is as if the symbolic reference to a method handle contains a symbolic reference to the method type that the resolved method handle will eventually have. The detailed structure of the method type is obtained by inspecting <strong>Table 5.4.3.5-B</strong>.</p><p>仿佛方法句柄的符号引用包含对解析后的方法句柄最终将具有的方法类型的符号引用。通过检查表5.4.3.5-B获取方法类型的详细结构。</p><p><strong>Table 5.4.3.5-B. Method Descriptors for Method Handles</strong></p><table><thead><tr><th>Kind</th><th>Description</th><th>Method descriptor</th></tr></thead><tbody><tr><td>1</td><td><code>REF_getField</code></td><td><code>(C)T</code></td></tr><tr><td>2</td><td><code>REF_getStatic</code></td><td><code>()T</code></td></tr><tr><td>3</td><td><code>REF_putField</code></td><td><code>(C,T)V</code></td></tr><tr><td>4</td><td><code>REF_putStatic</code></td><td><code>(T)V</code></td></tr><tr><td>5</td><td><code>REF_invokeVirtual</code></td><td><code>(C,A*)T</code></td></tr><tr><td>6</td><td><code>REF_invokeStatic</code></td><td><code>(A*)T</code></td></tr><tr><td>7</td><td><code>REF_invokeSpecial</code></td><td><code>(C,A*)T</code></td></tr><tr><td>8</td><td><code>REF_newInvokeSpecial</code></td><td><code>(A*)C</code></td></tr><tr><td>9</td><td><code>REF_invokeInterface</code></td><td><code>(C,A*)T</code></td></tr></tbody></table><p>In each step, any exception that can be thrown as a result of failure of resolution of a class or interface or field or method reference can be thrown as a result of failure of method handle resolution.</p><p>在每一步中，由于类、接口、字段或方法引用解析失败而可能抛出的任何异常也可能由于方法句柄解析失败而抛出。</p><p>The intent is that resolving a method handle can be done in exactly the same circumstances that the Java Virtual Machine would successfully resolve the symbolic references in the bytecode behavior. In particular, method handles to private and protected members can be created in exactly those classes for which the corresponding normal accesses are legal.</p><p>目的是，在Java虚拟机成功解析字节码行为中的符号引用的情况下，可以在完全相同的情况下解析方法句柄。特别是，可以在对相应的正常访问合法的类中创建对私有和受保护成员的方法句柄。</p><h4 id="5-4-3-6-Call-Site-Specifier-Resolution"><a href="#5-4-3-6-Call-Site-Specifier-Resolution" class="headerlink" title="5.4.3.6 Call Site Specifier Resolution"></a>5.4.3.6 Call Site Specifier Resolution</h4><p>To resolve an unresolved symbolic reference to a call site specifier involves three steps:</p><p>解析对调用站点说明符的未解析符号引用涉及三步：</p><ol><li><p>A call site specifier gives a symbolic reference to a method handle which is to serve as the bootstrap method for a dynamic call site (§4.7.23). The method handle is resolved to obtain a reference to an instance of <code>java.lang.invoke.MethodHandle</code> (§5.4.3.5).</p></li><li><p>调用站点说明符提供了一个方法句柄的符号引用，该句柄将作为动态调用站点的引导方法 (§4.7.23)。解析方法句柄以获得对<code>java.lang.invoke.MethodHandle</code>实例的引用 (§5.4.3.5)。</p></li><li><p>A call site specifier gives a method descriptor, <code>TD</code>. A reference to an instance of <code>java.lang.invoke.MethodType</code> is obtained as if by resolution of a symbolic reference to a method type with the same parameter and return types as <code>TD</code> (§5.4.3.5).</p></li><li><p>调用站点说明符提供了一个方法描述符<code>TD</code>。解析一个符号引用，以仿佛解析具有与<code>TD</code>相同参数和返回类型的方法类型的符号引用，从而获得对<code>java.lang.invoke.MethodType</code>实例的引用 (§5.4.3.5)。</p></li><li><p>A call site specifier gives zero or more static arguments, which communicate application-specific metadata to the bootstrap method. Any static arguments which are symbolic references to classes, method handles, or method types are resolved, as if by invocation of the <code>ldc</code> instruction (§ldc), to obtain references to <code>Class</code> objects, <code>java.lang.invoke.MethodHandle</code> objects, and <code>java.lang.invoke.MethodType</code> objects respectively. Any static arguments that are string literals are used to obtain references to <code>String</code> objects.</p></li><li><p>调用站点说明符提供了零个或多个静态参数，这些参数将应用程序特定的元数据传递给引导方法。任何作为类、方法句柄或方法类型的符号引用的静态参数都被解析，仿佛通过调用<code>ldc</code>指令 (§ldc)，分别获得对<code>Class</code>对象、<code>java.lang.invoke.MethodHandle</code>对象和<code>java.lang.invoke.MethodType</code>对象的引用。任何作为字符串字面量的静态参数都用于获得对<code>String</code>对象的引用。</p></li></ol><p>The result of call site specifier resolution is a tuple consisting of:</p><p>调用站点说明符解析的结果是一个元组，包含以下内容：</p><ol><li><p>The reference to an instance of <code>java.lang.invoke.MethodHandle</code>,</p></li><li><p>对<code>java.lang.invoke.MethodHandle</code>实例的引用，</p></li><li><p>The reference to an instance of <code>java.lang.invoke.MethodType</code>,</p></li><li><p>对<code>java.lang.invoke.MethodType</code>实例的引用，</p></li><li><p>The references to instances of <code>Class</code>, <code>java.lang.invoke.MethodHandle</code>, <code>java.lang.invoke.MethodType</code>, and <code>String</code>.</p></li><li><p>对<code>Class</code>、<code>java.lang.invoke.MethodHandle</code>、<code>java.lang.invoke.MethodType</code>和<code>String</code>实例的引用。</p></li></ol><p>During resolution of the symbolic reference to the method handle in the call site specifier, or resolution of the symbolic reference to the method type for the method descriptor in the call site specifier, or resolution of a symbolic reference to any static argument, any of the exceptions pertaining to method type or method handle resolution may be thrown (§5.4.3.5).</p><p>在解析对调用站点说明符中方法句柄的符号引用期间，或解析对调用站点说明符中方法描述符的方法类型的符号引用期间，或解析对任何静态参数的符号引用期间，可能会抛出与方法类型或方法句柄解析相关的任何异常 (§5.4.3.5)。</p><h3 id="5-4-4-Access-Control"><a href="#5-4-4-Access-Control" class="headerlink" title="5.4.4 Access Control"></a>5.4.4 Access Control</h3><p>A class or interface C is accessible to a class or interface D if and only if either of the following is true:</p><p>类或接口C对类或接口D是可访问的，当且仅当以下条件之一为真：</p><ol><li><p>C is public.</p></li><li><p>C是公共的。</p></li><li><p>C and D are members of the same runtime package (§5.3).</p></li><li><p>C和D属于同一个运行时包 (§5.3)。</p></li></ol><p>A field or method R is accessible to a class or interface D if and only if any of the following is true:</p><p>字段或方法R对类或接口D是可访问的，当且仅当以下条件之一为真：</p><ol><li><p>R is public.</p></li><li><p>R是公共的。</p></li><li><p>R is protected and is declared in a class C, and D is either a subclass of C or C itself. Furthermore, if R is not static, then the symbolic reference to R must contain a symbolic reference to a class T, such that T is either a subclass of D, a superclass of D, or D itself.</p></li><li><p>R是受保护的，并且声明在类C中，并且D要么是C的子类，要么是C本身。此外，如果R不是静态的，则R的符号引用必须包含对类T的符号引用，T要么是D的子类，要么是D的超类，要么是D本身。</p></li><li><p>R is either protected or has default access (that is, neither public nor protected nor private), and is declared by a class in the same runtime package as D.</p></li><li><p>R是受保护的，或者具有默认访问权限（即，既不是公共的，也不是受保护的，也不是私有的），并且由与D在同一个运行时包中的类声明。</p></li><li><p>R is private and is declared in D.</p></li><li><p>R是私有的，并且在D中声明。</p></li></ol><p>This discussion of access control omits a related restriction on the target of a protected field access or method invocation (the target must be of class D or a subtype of D). That requirement is checked as part of the verification process (§4.10.1.8); it is not part of link-time access control.</p><p>对于受保护字段访问或方法调用的目标，这一访问控制的讨论省略了相关的限制（目标必须是D类或D的子类型）。该要求作为验证过程的一部分进行检查 (§4.10.1.8)；它不是链接时访问控制的一部分。</p><h3 id="5-4-5-Overriding"><a href="#5-4-5-Overriding" class="headerlink" title="5.4.5 Overriding"></a>5.4.5 Overriding</h3><p>An instance method m declared in class C overrides another instance method m_CA declared in class A if and only if either m_C is the same as m_CA, or all of the following are true:</p><p>类C中声明的实例方法m_C覆盖类A中声明的另一个实例方法m_CA，当且仅当m_C与m_CA相同，或者以下所有条件为真：</p><ol><li><p>C is a subclass of A.</p></li><li><p>C是A的子类。</p></li><li><p>m_C has the same name and descriptor as m_CA.</p></li><li><p>m_C与m_CA具有相同的名称和描述符。</p></li><li><p>m_C is not marked <code>ACC_PRIVATE</code>.</p></li><li><p>m_C未标记为<code>ACC_PRIVATE</code>。</p></li><li><p>One of the following is true:</p></li><li><p>以下之一为真：</p></li></ol><ul><li><p>m_CA is marked <code>ACC_PUBLIC</code>; or is marked <code>ACC_PROTECTED</code>; or is marked neither <code>ACC_PUBLIC</code> nor <code>ACC_PROTECTED</code> nor <code>ACC_PRIVATE</code> and A belongs to the same runtime package as C.</p></li><li><p>m_CA标记为<code>ACC_PUBLIC</code>；或者标记为<code>ACC_PROTECTED</code>；或者未标记为<code>ACC_PUBLIC</code>、<code>ACC_PROTECTED</code>或<code>ACC_PRIVATE</code>，并且A与C属于同一运行时包。</p></li><li><p>m_C overrides a method m’_CA (m’_CA distinct from m_C and m_CA) such that m’_CA overrides m_CA.</p></li><li><p>m_C覆盖了方法m’_CA（m’_CA不同于m_C和m_CA），使得m’_CA覆盖m_CA。</p></li></ul><hr><h2 id="5-5-Initialization"><a href="#5-5-Initialization" class="headerlink" title="5.5 Initialization"></a>5.5 Initialization</h2><p>Initialization of a class or interface consists of executing its class or interface initialization method (§2.9).</p><p>类或接口的初始化包括执行其类或接口初始化方法 (§2.9)。</p><p>A class or interface C may be initialized only as a result of:</p><p>类或接口C只能作为以下结果之一进行初始化：</p><ol><li><p>The execution of any one of the Java Virtual Machine instructions <code>new</code>, <code>getstatic</code>, <code>putstatic</code>, or <code>invokestatic</code> that references C (§new, §getstatic, §putstatic, §invokestatic). These instructions reference a class or interface directly or indirectly through either a field reference or a method reference.</p></li><li><p>执行引用C的任何一个Java虚拟机指令<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>（§new、§getstatic、§putstatic、§invokestatic）。这些指令通过字段引用或方法引用直接或间接地引用类或接口。</p></li></ol><ul><li><p>Upon execution of a <code>new</code> instruction, the referenced class is initialized if it has not been initialized already.</p></li><li><p>执行<code>new</code>指令时，如果引用的类尚未初始化，则初始化它。</p></li><li><p>Upon execution of a <code>getstatic</code>, <code>putstatic</code>, or <code>invokestatic</code> instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already.</p></li><li><p>执行<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>指令时，如果声明了解析字段或方法的类或接口尚未初始化，则初始化它。</p></li></ul><ol start="2"><li><p>The first invocation of a <code>java.lang.invoke.MethodHandle</code> instance which was the result of method handle resolution (§5.4.3.5) for a method handle of kind 2 (<code>REF_getStatic</code>), 4 (<code>REF_putStatic</code>), 6 (<code>REF_invokeStatic</code>), or 8 (<code>REF_newInvokeSpecial</code>).</p></li><li><p>第一次调用<code>java.lang.invoke.MethodHandle</code>实例，该实例是方法句柄解析的结果 (§5.4.3.5)，用于类型2 (<code>REF_getStatic</code>)、4 (<code>REF_putStatic</code>)、6 (<code>REF_invokeStatic</code>) 或8 (<code>REF_newInvokeSpecial</code>) 的方法句柄。</p></li></ol><ul><li><p>This implies that the class of a bootstrap method is initialized when the bootstrap method is invoked for an <code>invokedynamic</code> instruction (§invokedynamic), as part of the continuing resolution of the call site specifier.</p></li><li><p>这意味着当引导方法为<code>invokedynamic</code>指令 (§invokedynamic) 调用时，引导方法的类会初始化，作为继续解析调用站点说明符的一部分。</p></li></ul><ol start="3"><li><p>Invocation of certain reflective methods in the class library (§2.12), for example, in class <code>Class</code> or in package <code>java.lang.reflect</code>.</p></li><li><p>调用类库中的某些反射方法 (§2.12)，例如在<code>Class</code>类中或在<code>java.lang.reflect</code>包中。</p></li><li><p>If C is a class, the initialization of one of its subclasses.</p></li><li><p>如果C是一个类，则初始化其子类之一。</p></li><li><p>If C is an interface that declares a non-abstract, non-static method, the initialization of a class that implements C directly or indirectly.</p></li><li><p>如果C是声明了非抽象、非静态方法的接口，则初始化直接或间接实现C的类。</p></li><li><p>If C is a class, its designation as the initial class at Java Virtual Machine startup (§5.2).</p></li><li><p>如果C是一个类，则在Java虚拟机启动时指定为初始类 (§5.2)。</p></li></ol><p>Prior to initialization, a class or interface must be linked, that is, verified, prepared, and optionally resolved.</p><p>在初始化之前，类或接口必须链接，即验证、准备，并可选地解析。</p><p>Because the Java Virtual Machine is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time. There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface. The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure. It assumes that the <code>Class</code> object has already been verified and prepared, and that the <code>Class</code> object contains state that indicates one of four situations:</p><p>由于Java虚拟机是多线程的，因此类或接口的初始化需要仔细同步，因为其他线程可能会尝试同时初始化相同的类或接口。也有可能作为类或接口初始化的一部分递归地请求类或接口的初始化。Java虚拟机的实现负责通过使用以下过程处理同步和递归初始化。假定<code>Class</code>对象已经过验证和准备，并且<code>Class</code>对象包含指示以下四种情况之一的状态：</p><ol><li><p>This <code>Class</code> object is verified and prepared but not initialized.</p></li><li><p>该<code>Class</code>对象已验证和准备，但尚未初始化。</p></li><li><p>This <code>Class</code> object is being initialized by some particular thread.</p></li><li><p>该<code>Class</code>对象正在由某个特定线程初始化。</p></li><li><p>This <code>Class</code> object is fully initialized and ready for use.</p></li><li><p>该<code>Class</code>对象已完全初始化并可供使用。</p></li><li><p>This <code>Class</code> object is in an erroneous state, perhaps because initialization was attempted and failed.</p></li><li><p>该<code>Class</code>对象处于错误状态，可能是因为初始化尝试失败。</p></li></ol><p>For each class or interface C, there is a unique initialization lock <code>LC</code>. The mapping from C to <code>LC</code> is left to the discretion of the Java Virtual Machine implementation. For example, <code>LC</code> could be the <code>Class</code> object for C, or the monitor associated with that <code>Class</code> object. The procedure for initializing C is then as follows:</p><p>对于每个类或接口C，存在一个唯一的初始化锁<code>LC</code>。从C到<code>LC</code>的映射由Java虚拟机实现自行决定。例如，<code>LC</code>可以是C的<code>Class</code>对象，也可以是与该<code>Class</code>对象相关联的监视器。初始化C的过程如下：</p><ol><li><p>Synchronize on the initialization lock, <code>LC</code>, for C. This involves waiting until the current thread can acquire <code>LC</code>.</p></li><li><p>在C的初始化锁<code>LC</code>上进行同步。这涉及等待当前线程可以获取<code>LC</code>。</p></li><li><p>If the <code>Class</code> object for C indicates that initialization is in progress for C by some other thread, then release <code>LC</code> and block the current thread until informed that the in-progress initialization has completed, at which time repeat this procedure.</p></li><li><p>如果C的<code>Class</code>对象指示其他线程正在进行C的初始化，则释放<code>LC</code>并阻塞当前线程，直到通知初始化已完成为止，此时重复此过程。</p></li></ol><ul><li><p>Thread interrupt status is unaffected by execution of the initialization procedure.</p></li><li><p>初始化过程的执行不会影响线程中断状态。</p></li></ul><ol start="3"><li><p>If the <code>Class</code> object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization. Release <code>LC</code> and complete normally.</p></li><li><p>如果C的<code>Class</code>对象指示当前线程正在进行C的初始化，则这必须是递归初始化请求。释放<code>LC</code>并正常完成。</p></li><li><p>If the <code>Class</code> object for C indicates that C has already been initialized, then no further action is required. Release <code>LC</code> and complete normally.</p></li><li><p>如果C的<code>Class</code>对象指示C已经初始化，则不需要进一步操作。释放<code>LC</code>并正常完成。</p></li><li><p>If the <code>Class</code> object for C is in an erroneous state, then initialization is not possible. Release <code>LC</code> and throw a <code>NoClassDefFoundError</code>.</p></li><li><p>如果C的<code>Class</code>对象处于错误状态，则无法初始化。释放<code>LC</code>并抛出<code>NoClassDefFoundError</code>。</p></li><li><p>Otherwise, record the fact that initialization of the <code>Class</code> object for C is in progress by the current thread, and release <code>LC</code>.</p></li><li><p>否则，记录当前线程正在进行C的<code>Class</code>对象的初始化，并释放<code>LC</code>。</p></li></ol><ul><li><p>Then, initialize each final static field of C with the constant value in its <code>ConstantValue</code> attribute (§4.7.2), in the order the fields appear in the <code>ClassFile</code> structure.</p></li><li><p>然后，按字段在<code>ClassFile</code>结构中出现的顺序，用其<code>ConstantValue</code>属性中的常量值 (§4.7.2) 初始化C的每个最终静态字段。</p></li></ul><ol start="7"><li><p>Next, if C is a class rather than an interface, and its superclass has not yet been initialized, then let <code>SC</code> be its superclass and let <code>SI1, ..., SIn</code> be all superinterfaces of C (whether direct or indirect) that declare at least one non-abstract, non-static method. The order of superinterfaces is given by a recursive enumeration over the superinterface hierarchy of each interface directly implemented by C. For each interface I directly implemented by C (in the order of the <code>interfaces</code> array of C), the enumeration recurs on I’s superinterfaces (in the order of the <code>interfaces</code> array of I) before returning I.</p></li><li><p>接下来，如果C是一个类而不是接口，并且它的超类尚未初始化，则设<code>SC</code>为其超类，设<code>SI1, ..., SIn</code>为C的所有超接口（无论是直接的还是间接的），它们声明了至少一个非抽象的非静态方法。超接口的顺序由C直接实现的每个接口的超接口层次结构的递归枚举给出。对于C直接实现的每个接口I（按C的<code>interfaces</code>数组的顺序），枚举在I的超接口上递归（按I的<code>interfaces</code>数组的顺序）然后返回I。</p></li></ol><ul><li><p>For each <code>S</code> in the list <code>[ SC, SI1, ..., SIn ]</code>, recursively perform this entire procedure for <code>S</code>. If necessary, verify and prepare <code>S</code> first.</p></li><li><p>对于列表 <code>[ SC, SI1, ..., SIn ]</code> 中的每个 <code>S</code>，递归地为 <code>S</code> 执行整个过程。如果必要，先验证并准备 <code>S</code>。</p></li><li><p>If the initialization of <code>S</code> completes abruptly because of a thrown exception, then acquire <code>LC</code>, label the <code>Class</code> object for C as erroneous, notify all waiting threads, release <code>LC</code>, and complete abruptly, throwing the same exception that resulted from initializing <code>SC</code>.</p></li><li><p>如果<code>S</code>的初始化由于抛出异常而突然完成，则获取<code>LC</code>，将C的<code>Class</code>对象标记为错误，通知所有等待的线程，释放<code>LC</code>并突然完成，抛出与初始化<code>SC</code>相同的异常。</p></li></ul><ol start="8"><li><p>Next, determine whether assertions are enabled for C by querying its defining class loader.</p></li><li><p>接下来，通过查询其定义类加载器确定是否为C启用了断言。</p></li><li><p>Next, execute the class or interface initialization method of C.</p></li><li><p>接下来，执行C的类或接口初始化方法。</p></li><li><p>If the execution of the class or interface initialization method completes normally, then acquire <code>LC</code>, label the <code>Class</code> object for C as fully initialized, notify all waiting threads, release <code>LC</code>, and complete this procedure normally.</p></li><li><p>如果类或接口初始化方法的执行正常完成，则获取<code>LC</code>，将C的<code>Class</code>对象标记为完全初始化，通知所有等待的线程，释放<code>LC</code>并正常完成此过程。</p></li><li><p>Otherwise, the class or interface initialization method must have completed abruptly by throwing some exception <code>E</code>. If the class of <code>E</code> is not <code>Error</code> or one of its subclasses, then create a new instance of the class <code>ExceptionInInitializerError</code> with <code>E</code> as the argument, and use this object in place of <code>E</code> in the following step. If a new instance of <code>ExceptionInInitializerError</code> cannot be created because an <code>OutOfMemoryError</code> occurs, then use an <code>OutOfMemoryError</code> object in place of <code>E</code>.</p></li><li><p>否则，类或接口初始化方法必须通过抛出某个异常<code>E</code>突然完成。如果<code>E</code>的类不是<code>Error</code>或其子类之一，则使用<code>E</code>作为参数创建一个新的<code>ExceptionInInitializerError</code>类的实例，并在以下步骤中使用此对象代替<code>E</code>。如果由于发生<code>OutOfMemoryError</code>而无法创建<code>ExceptionInInitializerError</code>的实例，则使用<code>OutOfMemoryError</code>对象代替<code>E</code>。</p></li><li><p>Acquire <code>LC</code>, label the <code>Class</code> object for C as erroneous, notify all waiting threads, release <code>LC</code>, and complete this procedure abruptly with reason <code>E</code> or its replacement as determined in the previous step.</p></li><li><p>获取<code>LC</code>，将C的<code>Class</code>对象标记为错误，通知所有等待的线程，释放<code>LC</code>并突然完成此过程，原因是<code>E</code>或在前一步骤中确定的替换。</p></li></ol><p>A Java Virtual Machine implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step 4&#x2F;5) when it can determine that the initialization of the class has already completed, provided that, in terms of the Java memory model, all happens-before orderings (JLS §17.4.5) that would exist if the lock were acquired, still exist when the optimization is performed.</p><p>Java虚拟机实现可以通过在步骤1中省略锁获取（在步骤4&#x2F;5中省略释放）来优化此过程，当它可以确定类的初始化已经完成时，前提是，根据Java内存模型，如果获取了锁，所有会存在的发生先于顺序（JLS §17.4.5）在优化执行时仍然存在。</p><hr><h2 id="5-6-Binding-Native-Method-Implementations"><a href="#5-6-Binding-Native-Method-Implementations" class="headerlink" title="5.6 Binding Native Method Implementations"></a>5.6 Binding Native Method Implementations</h2><p>Binding is the process by which a function written in a language other than the Java programming language and implementing a native method is integrated into the Java Virtual Machine so that it can be executed. Although this process is traditionally referred to as linking, the term binding is used in the specification to avoid confusion with linking of classes or interfaces by the Java Virtual Machine.</p><p>绑定是指将用非Java编程语言编写并实现本地方法的函数集成到Java虚拟机中，使其可以执行的过程。尽管这个过程传统上称为链接，但在规范中使用绑定一词是为了避免与Java虚拟机对类或接口的链接混淆。</p><hr><h2 id="5-7-Java-Virtual-Machine-Exit"><a href="#5-7-Java-Virtual-Machine-Exit" class="headerlink" title="5.7 Java Virtual Machine Exit"></a>5.7 Java Virtual Machine Exit</h2><p>The Java Virtual Machine exits when some thread invokes the <code>exit</code> method of class <code>Runtime</code> or class <code>System</code>, or the <code>halt</code> method of class <code>Runtime</code>, and the exit or halt operation is permitted by the security manager.</p><p>当某个线程调用<code>Runtime</code>类或<code>System</code>类的<code>exit</code>方法，或<code>Runtime</code>类的<code>halt</code>方法，并且安全管理器允许退出或停止操作时，Java虚拟机退出。</p><p>In addition, the JNI (Java Native Interface) Specification describes termination of the Java Virtual Machine when the JNI Invocation API is used to load and unload the Java Virtual Machine.</p><p>此外，JNI（Java本地接口）规范描述了在使用JNI调用API加载和卸载Java虚拟机时Java虚拟机的终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 官方文档翻译 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-spec-1. Introduction</title>
      <link href="/2022/09/01/jvm-spec-1.%20Introduction/"/>
      <url>/2022/09/01/jvm-spec-1.%20Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-A-Bit-of-History（一些历史）"><a href="#1-1-A-Bit-of-History（一些历史）" class="headerlink" title="1.1 A Bit of History（一些历史）"></a>1.1 A Bit of History（一些历史）</h2><p>The Java® programming language is a general-purpose, concurrent, object-oriented language. Its syntax is similar to C and C++, but it omits many of the features that make C and C++ complex, confusing, and unsafe. The Java platform was initially developed to address the problems of building software for networked consumer devices. It was designed to support multiple host architectures and to allow secure delivery of software components. To meet these requirements, compiled code had to survive transport across networks, operate on any client, and assure the client that it was safe to run.</p><p>Java编程语言是一种通用的、并发的、面向对象的语言。它的语法类似于C和C++，但省去了许多使C和C++变得复杂、混乱和不安全的特性。Java平台最初开发是为了应对为联网设备构建软件时遇到的问题。它的设计目标是支持多种主机架构，并允许安全地交付软件组件。为了满足这些要求，编译后的代码必须能够在网络上传输、生存，并在任何客户端上运行，同时确保客户端运行时是安全的。</p><p>The popularization of the World Wide Web made these attributes much more interesting. Web browsers enabled millions of people to surf the Net and access media-rich content in simple ways. At last there was a medium where what you saw and heard was essentially the same regardless of the machine you were using and whether it was connected to a fast network or a slow modem.</p><p>万维网的普及使这些特性变得更加有趣。Web浏览器使数百万人能够以简单的方式上网并访问媒体丰富的内容。最终，无论你使用的是什么机器，也无论它连接的是快速网络还是慢速调制解调器，你所看到和听到的内容本质上都是一样的。</p><p>Web enthusiasts soon discovered that the content supported by the Web’s HTML document format was too limited. HTML extensions, such as forms, only highlighted those limitations, while making it clear that no browser could include all the features users wanted. Extensibility was the answer.</p><p>网络爱好者很快发现，Web的HTML文档格式支持的内容过于有限。HTML扩展，例如表单，仅仅突出了这些限制，并且显而易见，没有任何浏览器能够包含用户想要的所有功能。可扩展性是答案。</p><p>The HotJava browser first showcased the interesting properties of the Java programming language and platform by making it possible to embed programs inside HTML pages. Programs are transparently downloaded into the browser along with the HTML pages in which they appear. Before being accepted by the browser, programs are carefully checked to make sure they are safe. Like HTML pages, compiled programs are network- and host-independent. The programs behave the same way regardless of where they come from or what kind of machine they are being loaded into and run on.</p><p>HotJava浏览器首次展示了Java编程语言和平台的有趣特性，使得可以将程序嵌入到HTML页面中。程序随着它们所在的HTML页面一起透明地下载到浏览器中。在被浏览器接受之前，程序会被仔细检查以确保它们是安全的。与HTML页面一样，编译后的程序是网络和主机无关的。这些程序无论来源何处，或被加载到何种机器上运行，行为方式都是相同的。</p><hr><h2 id="1-2-The-Java-Virtual-Machine（Java虚拟机）"><a href="#1-2-The-Java-Virtual-Machine（Java虚拟机）" class="headerlink" title="1.2 The Java Virtual Machine（Java虚拟机）"></a>1.2 The Java Virtual Machine（Java虚拟机）</h2><p>The Java Virtual Machine is the cornerstone of the Java platform. It is the component of the technology responsible for its hardware- and operating system-independence, the small size of its compiled code, and its ability to protect users from malicious programs.</p><p>Java虚拟机是Java平台的基石。它是负责实现技术的硬件和操作系统独立性、编译代码的小尺寸以及保护用户免受恶意程序侵害的组件。</p><p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.</p><p>Java虚拟机是一种抽象的计算机。与实际的计算机一样，它有一套指令集，并在运行时操作各种内存区域。使用虚拟机来实现编程语言是相当常见的做法；最著名的虚拟机可能是UCSD Pascal的P-Code机。</p><p>The first prototype implementation of the Java Virtual Machine, done at Sun Microsystems, Inc., emulated the Java Virtual Machine instruction set in software hosted by a handheld device that resembled a contemporary Personal Digital Assistant (PDA). Oracle’s current implementations emulate the Java Virtual Machine on mobile, desktop and server devices, but the Java Virtual Machine does not assume any particular implementation technology, host hardware, or host operating system. It is not inherently interpreted, but can just as well be implemented by compiling its instruction set to that of a silicon CPU. It may also be implemented in microcode or directly in silicon.</p><p>Java虚拟机的第一个原型实现是在Sun Microsystems, Inc.完成的，它在一个类似当代个人数字助理（PDA）的手持设备上模拟了Java虚拟机的指令集。Oracle目前的实现版本在移动设备、桌面设备和服务器设备上模拟了Java虚拟机，但Java虚拟机并不假设任何特定的实现技术、主机硬件或主机操作系统。它并非天生就是解释执行的，但也可以通过将其指令集编译成硅基CPU的指令集来实现。它还可以通过微代码或直接在硅片上实现。</p><p>The Java Virtual Machine knows nothing of the Java programming language, only of a particular binary format, the class file format. A class file contains Java Virtual Machine instructions (or bytecodes) and a symbol table, as well as other ancillary information.</p><p>Java虚拟机对Java编程语言一无所知，它只了解一种特定的二进制格式，即类文件格式。类文件包含Java虚拟机指令（或字节码）和符号表，以及其他辅助信息。</p><p>For the sake of security, the Java Virtual Machine imposes strong syntactic and structural constraints on the code in a class file. <strong>However, any language with functionality that can be expressed in terms of a valid class file can be hosted by the Java Virtual Machine.</strong> Attracted by a generally available, machine-independent platform, implementors of other languages can turn to the Java Virtual Machine as a delivery vehicle for their languages.</p><p>为了安全起见，Java虚拟机对类文件中的代码施加了强烈的语法和结构约束。<strong>然而，任何功能可以用有效类文件来表达的语言都可以由Java虚拟机托管。</strong> 由于Java虚拟机是一个广泛可用的、与机器无关的平台，其他语言的实现者可以将Java虚拟机作为他们语言的交付工具。</p><hr><h2 id="1-3-Organization-of-the-Specification（规范文档的组织结构）"><a href="#1-3-Organization-of-the-Specification（规范文档的组织结构）" class="headerlink" title="1.3 Organization of the Specification（规范文档的组织结构）"></a>1.3 Organization of the Specification（规范文档的组织结构）</h2><p>Chapter 2 gives an overview of the Java Virtual Machine architecture.</p><p>第2章概述了Java虚拟机架构。</p><p>Chapter 3 introduces compilation of code written in the Java programming language into the instruction set of the Java Virtual Machine.</p><p>第3章介绍了将用Java编程语言编写的代码编译为Java虚拟机指令集。</p><p>Chapter 4 specifies the class file format, the hardware- and operating system-independent binary format used to represent compiled classes and interfaces.</p><p>第4章规定了类文件格式，这是一种用于表示编译后的类和接口的硬件和操作系统无关的二进制格式。</p><p>Chapter 5 specifies the start-up of the Java Virtual Machine and the loading, linking, and initialization of classes and interfaces.</p><p>第5章规定了Java虚拟机的启动以及类和接口的加载、链接和初始化。</p><p>Chapter 6 specifies the instruction set of the Java Virtual Machine, presenting the instructions in alphabetical order of opcode mnemonics.</p><p>第6章规定了Java虚拟机的指令集，并按操作码助记符的字母顺序排列指令。</p><p>Chapter 7 gives a table of Java Virtual Machine opcode mnemonics indexed by opcode value.</p><p>第7章提供了按操作码值索引的Java虚拟机操作码助记符表。</p><p>In the Second Edition of The Java® Virtual Machine Specification, Chapter 2 gave an overview of the Java programming language that was intended to support the specification of the Java Virtual Machine but was not itself a part of the specification. In The Java Virtual Machine Specification, Java SE 8 Edition, the reader is referred to The Java Language Specification, Java SE 8 Edition for information about the Java programming language. References of the form: (JLS §x.y) indicate where this is necessary.</p><p>在第二版《Java®虚拟机规范》中，第2章概述了Java编程语言，该语言旨在支持Java虚拟机规范，但它本身并不是规范的一部分。在《Java虚拟机规范，Java SE 8版》中，读者可参考《Java语言规范，Java SE 8版》以获取有关Java编程语言的信息。格式为（JLS §x.y）的引用表明何处需要参考。</p><p>In the Second Edition of The Java® Virtual Machine Specification, Chapter 8 detailed the low-level actions that explained the interaction of Java Virtual Machine threads with a shared main memory. In The Java Virtual Machine Specification, Java SE 8 Edition, the reader is referred to Chapter 17 of The Java Language Specification, Java SE 8 Edition for information about threads and locks. Chapter 17 reflects The Java Memory Model and Thread Specification produced by the JSR 133 Expert Group.</p><p>在第二版《Java®虚拟机规范》中，第8章详细描述了解释Java虚拟机线程与共享主存交互的低级操作。在《Java虚拟机规范，Java SE 8版》中，读者可参考《Java语言规范，Java SE 8版》的第17章以获取有关线程和锁的信息。第17章反映了JSR 133专家组编写的Java内存模型和线程规范。</p><hr><h2 id="1-4-Notation（标注）"><a href="#1-4-Notation（标注）" class="headerlink" title="1.4 Notation（标注）"></a>1.4 Notation（标注）</h2><p>Throughout this specification we refer to classes and interfaces drawn from the Java SE platform API. Whenever we refer to a class or interface (other than those declared in an example) using a single identifier N, the intended reference is to the class or interface named N in the package java.lang. We use the fully qualified name for classes or interfaces from packages other than java.lang.</p><p>在本规范中，我们提到的类和接口均来自Java SE平台API。每当我们使用单个标识符N引用一个类或接口（示例中声明的除外）时，其引用指向的是java.lang包中名为N的类或接口。对于来自java.lang之外的包的类或接口，我们使用全限定名称。</p><p>Whenever we refer to a class or interface that is declared in the package java or any of its subpackages, the intended reference is to that class or interface as loaded by the bootstrap class loader (§5.3.1).</p><p>每当我们引用在java包或其任何子包中声明的类或接口时，其引用指向的是由引导类加载器（§5.3.1）加载的该类或接口。</p><p>Whenever we refer to a subpackage of a package named java, the intended reference is to that subpackage as determined by the bootstrap class loader.</p><p>每当我们引用名为java的包的子包时，其引用指向的是由引导类加载器确定的该子包。</p><p>The use of fonts in this specification is as follows:</p><p>本规范中字体的使用如下：</p><ul><li><p>A fixed width font is used for Java Virtual Machine data types, exceptions, errors, class file structures, Prolog code, and Java code fragments.</p></li><li><p>固定宽度字体用于Java虚拟机数据类型、异常、错误、类文件结构、Prolog代码和Java代码片段。</p></li><li><p>Italic is used for Java Virtual Machine “assembly language”, its opcodes and operands, as well as items in the Java Virtual Machine’s run-time data areas. It is also used to introduce new terms and simply for emphasis.</p></li><li><p>斜体用于Java虚拟机的“汇编语言”、其操作码和操作数，以及Java虚拟机的运行时数据区中的项目。它也用于引入新术语和简单的强调。</p></li></ul><p>Non-normative information, designed to clarify the specification, is given in smaller, indented text.</p><p>非规范性信息，用于澄清规范，以较小的、缩进的文本形式给出。</p><p>This is non-normative information. It provides intuition, rationale, advice, examples, etc.</p><p>这是非规范性信息。它提供直觉、基本原理、建议、示例等。</p><hr><h2 id="1-5-Feedback（反馈）"><a href="#1-5-Feedback（反馈）" class="headerlink" title="1.5 Feedback（反馈）"></a>1.5 Feedback（反馈）</h2><p>Readers are invited to report technical errors and ambiguities in The Java® Virtual Machine Specification to <a href="mailto:jls-jvms-spec-comments@openjdk.java.net">jls-jvms-spec-comments@openjdk.java.net</a>.</p><p>邀请读者将《Java®虚拟机规范》中的技术错误和含糊之处报告至<a href="mailto:jls-jvms-spec-comments@openjdk.java.net">jls-jvms-spec-comments@openjdk.java.net</a>。</p><p>Questions concerning the generation and manipulation of class files by javac (the reference compiler for the Java programming language) may be sent to <a href="mailto:compiler-dev@openjdk.java.net">compiler-dev@openjdk.java.net</a>.</p><p>有关javac（Java编程语言的参考编译器）生成和操作类文件的问题可以发送至<a href="mailto:compiler-dev@openjdk.java.net">compiler-dev@openjdk.java.net</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 官方文档翻译 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-spec-2. The Structure of the Java Virtual Machine</title>
      <link href="/2022/09/01/jvm-spec-2.%20The%20Structure%20of%20the%20Java%20Virtual%20Machine/"/>
      <url>/2022/09/01/jvm-spec-2.%20The%20Structure%20of%20the%20Java%20Virtual%20Machine/</url>
      
        <content type="html"><![CDATA[<p>This document specifies an abstract machine. It does not describe any particular implementation of the Java Virtual Machine.</p><p>本文档指定了一个抽象机器，并未描述Java虚拟机的任何特定实现。</p><p>To implement the Java Virtual Machine correctly, you need only be able to read the class file format and correctly perform the operations specified therein. Implementation details that are not part of the Java Virtual Machine’s specification would unnecessarily constrain the creativity of implementors. For example, the memory layout of run-time data areas, the garbage-collection algorithm used, and any internal optimization of the Java Virtual Machine instructions (for example, translating them into machine code) are left to the discretion of the implementor.</p><p>为了正确实现Java虚拟机，您只需能够读取类文件格式并正确执行其中指定的操作。那些不属于Java虚拟机规范的实现细节将不必要地限制实现者的创造力。例如，运行时数据区的内存布局、使用的垃圾回收算法，以及Java虚拟机指令的任何内部优化（例如将其翻译为机器代码）都由实现者自行决定。</p><p>All references to Unicode in this specification are given with respect to The Unicode Standard, Version 6.0.0, available at <a href="http://www.unicode.org/">http://www.unicode.org/</a>.</p><p>本文档中提到的所有Unicode引用均基于《Unicode标准》第6.0.0版，你可以在<a href="http://www.unicode.org/">http://www.unicode.org/</a>获取。</p><hr><h2 id="2-1-The-class-File-Format（class文件格式）"><a href="#2-1-The-class-File-Format（class文件格式）" class="headerlink" title="2.1 The class File Format（class文件格式）"></a>2.1 The class File Format（class文件格式）</h2><p>Compiled code to be executed by the Java Virtual Machine is represented using a hardware- and operating system-independent binary format, typically (but not necessarily) stored in a file, known as the class file format. The class file format precisely defines the representation of a class or interface, including details such as byte ordering that might be taken for granted in a platform-specific object file format.</p><p>由Java虚拟机执行的编译代码使用一种与硬件和操作系统无关的二进制格式表示，这种格式通常（但不一定）存储在一个文件中，称为类文件格式。类文件格式精确地定义了类或接口的表示方式，包括诸如字节顺序等在特定平台的对象文件格式中可能被默认的细节。</p><p>Chapter 4, “The class File Format”, covers the class file format in detail.</p><p>第四章，“The class File Format”，详细介绍了类文件格式。</p><hr><h2 id="2-2-Data-Types（数据类型）"><a href="#2-2-Data-Types（数据类型）" class="headerlink" title="2.2 Data Types（数据类型）"></a>2.2 Data Types（数据类型）</h2><p>Like the Java programming language, the Java Virtual Machine operates on two kinds of types: <strong>primitive types and reference types</strong>. There are, correspondingly, two kinds of values that can be stored in variables, passed as arguments, returned by methods, and operated upon: <strong>primitive values and reference values</strong>.</p><p>与Java编程语言类似，Java虚拟机处理两种类型：<strong>原始类型（<em>primitive types</em>）和引用类型（<em>reference types</em>）</strong>。相应地，也有两种值可以存储在变量中、作为参数传递、由方法返回以及进行操作：<strong>原始值（<em>primitive values</em>）和引用值（<em>reference values</em>）</strong>。</p><p>The Java Virtual Machine expects that nearly all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Java Virtual Machine itself. Values of primitive types need not be tagged or otherwise be inspectable to determine their types at run time, or to be distinguished from values of reference types. Instead, the instruction set of the Java Virtual Machine distinguishes its operand types using instructions intended to operate on values of specific types. For instance, iadd, ladd, fadd, and dadd are all Java Virtual Machine instructions that add two numeric values and produce numeric results, but each is specialized for its operand type: int, long, float, and double, respectively. For a summary of type support in the Java Virtual Machine instruction set, see §2.11.1.</p><p>Java虚拟机假设几乎所有的类型检查在运行时之前都已经完成，通常由编译器来进行，而不需要由Java虚拟机本身完成。原始类型的值不需要在运行时进行标记或其他方式检查其类型，或者将它们与引用类型的值区分开来。相反，Java虚拟机的指令集通过专门用于特定类型值的指令来区分其操作数类型。例如，<code>iadd</code>、<code>ladd</code>、<code>fadd</code>和<code>dadd</code>都是Java虚拟机指令，这些指令用于将两个数值相加并产生数值结果，但它们各自专门用于其操作数类型：<code>int</code>、<code>long</code>、<code>float</code>和<code>double</code>。关于Java虚拟机指令集中类型支持的总结，请参见§2.11.1。</p><p>The Java Virtual Machine contains explicit support for objects. An object is either a dynamically allocated class instance or an array. A reference to an object is considered to have Java Virtual Machine type reference. Values of type reference can be thought of as pointers to objects. More than one reference to an object may exist. Objects are always operated on, passed, and tested via values of type reference.</p><p>Java虚拟机包含对对象的明确支持。对象要么是动态分配的类实例，要么是数组。对对象的引用被认为具有Java虚拟机的引用类型。引用类型的值可以被看作是指向对象的指针。多个引用可能指向同一个对象。对象总是通过引用类型的值进行操作、传递和测试。</p><hr><h2 id="2-3-Primitive-Types-and-Values（基本数据类型和值）"><a href="#2-3-Primitive-Types-and-Values（基本数据类型和值）" class="headerlink" title="2.3 Primitive Types and Values（基本数据类型和值）"></a>2.3 Primitive Types and Values（基本数据类型和值）</h2><p>The primitive data types supported by the Java Virtual Machine are the numeric types, the boolean type (§2.3.4), and the returnAddress type (§2.3.3).</p><p>Java虚拟机支持的基本数据类型包括数值类型、布尔类型（见第2.3.4节）和返回地址类型（见第2.3.3节）。</p><p>The numeric types consist of the integral types (§2.3.1) and the floating-point types (§2.3.2).  </p><p>数值类型包括整型（见第2.3.1节）和浮点型（见第2.3.2节）。</p><p>The integral types are:</p><ul><li>byte, whose values are 8-bit signed two’s-complement integers, and whose default value is zero  </li><li>short, whose values are 16-bit signed two’s-complement integers, and whose default value is zero  </li><li>int, whose values are 32-bit signed two’s-complement integers, and whose default value is zero  </li><li>long, whose values are 64-bit signed two’s-complement integers, and whose default value is zero  </li><li>char, whose values are 16-bit unsigned integers representing Unicode code points in the Basic Multilingual Plane, encoded with UTF-16, and whose default value is the null code point (‘\u0000’)</li></ul><p>整型包括：</p><ul><li><code>byte</code>：值为8位有符号二进制补码整数，默认值为0。</li><li><code>short</code>：值为16位有符号二进制补码整数，默认值为0。</li><li><code>int</code>：值为32位有符号二进制补码整数，默认值为0。</li><li><code>long</code>：值为64位有符号二进制补码整数，默认值为0。</li><li><code>char</code>：值为16位无符号整数，表示基本多语言平面的Unicode代码点，以UTF-16编码，默认值为空代码点(‘\u0000’)。</li></ul><p>The floating-point types are:</p><ul><li>float, whose values are elements of the float value set or, where supported, the float-extended-exponent value set, and whose default value is positive zero</li><li>double, whose values are elements of the double value set or, where supported, the double-extended-exponent value set, and whose default value is positive zero</li></ul><p>浮点型包括：</p><ul><li><code>float</code>：值为<code>float</code>值集中的元素或在支持的情况下为<code>float-extended-exponent</code>值集中的元素，默认值为正零。</li><li><code>double</code>：值为<code>double</code>值集中的元素或在支持的情况下为<code>double-extended-exponent</code>值集中的元素，默认值为正零。</li></ul><p>The values of the boolean type encode the truth values true and false, and the default value is false.</p><p>布尔类型的值编码了真和假的真值，默认值为假。</p><p>The First Edition of The Java® Virtual Machine Specification did not consider boolean to be a Java Virtual Machine type. However, boolean values do have limited support in the Java Virtual Machine. The Second Edition of The Java® Virtual Machine Specification clarified the issue by treating boolean as a type.</p><p>Java虚拟机规范的第一版没有考虑将布尔类型作为Java虚拟机类型。然而，布尔值在Java虚拟机中有一定的支持。Java虚拟机规范的第二版通过将布尔类型作为一种类型来澄清了这个问题。</p><p>The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions. Of the primitive types, only the returnAddress type is not directly associated with a Java programming language type.</p><p>返回地址类型的值是指向Java虚拟机指令操作码的指针。在基本类型中，只有返回地址类型没有直接与Java编程语言的类型关联。</p><h3 id="2-3-1-Integral-Types-and-Values（整型和值）"><a href="#2-3-1-Integral-Types-and-Values（整型和值）" class="headerlink" title="2.3.1 Integral Types and Values（整型和值）"></a>2.3.1 Integral Types and Values（整型和值）</h3><p>The values of the integral types of the Java Virtual Machine are:</p><ul><li>For byte, from -128 to 127 (-2^7 to 2^7 - 1), inclusive</li><li>For short, from -32768 to 32767 (-2^15 to 2^15 - 1), inclusive</li><li>For int, from -2147483648 to 2147483647 (-2^31 to 2^31 - 1), inclusive</li><li>For long, from -9223372036854775808 to 9223372036854775807 (-2^63 to 2^63 - 1), inclusive</li><li>For char, from 0 to 65535 inclusive</li></ul><p>Java虚拟机的整型值包括：</p><ul><li><code>byte</code>：范围从-128到127（-2^7到2^7 - 1），包含在内。</li><li><code>short</code>：范围从-32768到32767（-2^15到2^15 - 1），包含在内。</li><li><code>int</code>：范围从-2147483648到2147483647（-2^31到2^31 - 1），包含在内。</li><li><code>long</code>：范围从-9223372036854775808到9223372036854775807（-2^63到2^63 - 1），包含在内。</li><li><code>char</code>：范围从0到65535，包含在内。</li></ul><h3 id="2-3-2-Floating-Point-Types-Value-Sets-and-Values（浮点型，浮点值集和值）"><a href="#2-3-2-Floating-Point-Types-Value-Sets-and-Values（浮点型，浮点值集和值）" class="headerlink" title="2.3.2 Floating-Point Types, Value Sets, and Values（浮点型，浮点值集和值）"></a>2.3.2 Floating-Point Types, Value Sets, and Values（浮点型，浮点值集和值）</h3><p>The floating-point types are float and double, which are conceptually associated with the 32-bit single-precision and 64-bit double-precision format IEEE 754 values and operations as specified in IEEE Standard for Binary Floating-Point Arithmetic (ANSI&#x2F;IEEE Std. 754-1985, New York).</p><p>浮点类型包括<code>float</code>和<code>double</code>，它们在概念上与IEEE 754标准中规定的32位单精度和64位双精度格式的值和操作相关。</p><p>The IEEE 754 standard includes not only positive and negative sign-magnitude numbers, but also positive and negative zeros, positive and negative infinities, and a special Not-a-Number value (hereafter abbreviated as “NaN”). The NaN value is used to represent the result of certain invalid operations such as dividing zero by zero.</p><p>IEEE 754标准不仅包括正负符号-幅度数字，还包括正负零、正负无穷大，以及特殊的非数字（NaN）值。NaN值用于表示某些无效操作的结果，例如零除以零。</p><p>Every implementation of the Java Virtual Machine is required to support two standard sets of floating-point values, called the float value set and the double value set. In addition, an implementation of the Java Virtual Machine may, at its option, support either or both of two extended-exponent floating-point value sets, called the float-extended-exponent value set and the double-extended-exponent value set. These extended-exponent value sets may, under certain circumstances, be used instead of the standard value sets to represent the values of type float or double.</p><p>每个Java虚拟机实现都需要支持两种标准浮点值集，称为<code>float</code>值集和<code>double</code>值集。此外，Java虚拟机的实现可以选择支持一种或两种扩展指数浮点值集，分别称为<code>float-extended-exponent</code>值集和<code>double-extended-exponent</code>值集。在某些情况下，这些扩展指数值集可以代替标准值集来表示类型<code>float</code>或<code>double</code>的值。</p><p>The finite nonzero values of any floating-point value set can all be expressed in the form s ⋅ m ⋅ 2^(e - N + 1), where s is +1 or -1, m is a positive integer less than 2^N, and e is an integer between E_min &#x3D; -(2^K-1-2) and E_max &#x3D; 2^K-1-1, inclusive, and where N and K are parameters that depend on the value set. Some values can be represented in this form in more than one way; for example, supposing that a value v in a value set might be represented in this form using certain values for s, m, and e, then if it happened that m were even and e were less than 2^K-1, one could halve m and increase e by 1 to produce a second representation for the same value v. A representation in this form is called normalized if m ≥ 2^N-1; otherwise the representation is said to be denormalized. If a value in a value set cannot be represented in such a way that m ≥ 2^N-1, then the value is said to be a denormalized value, because it has no normalized representation.</p><p>任何浮点值集的有限非零值都可以表示为<code>s ⋅ m ⋅ 2^(e - N + 1)</code>，其中<code>s</code>为+1或-1，<code>m</code>为小于2^N的正整数，<code>e</code>为E_min &#x3D; -(2^K-1-2)和E_max &#x3D; 2^K-1-1之间的整数，且N和K是取决于值集的参数。一些值可以以多种方式表示在此形式中；例如，假设值集中的某个值v可以使用特定的s、m和e值表示，那么如果m为偶数且e小于2^K-1，可以将m减半并将e加1，以生成相同值v的第二种表示形式。如果m ≥ 2^N-1，则此形式的表示称为规范化；否则，表示被称为非规范化。如果一个值集中的值无法以m ≥ 2^N-1的方式表示，则该值被称为非规范化值，因为它没有规范化表示。</p><p>The constraints on the parameters N and K (and on the derived parameters E_min and E_max) for the two required and two optional floating-point value sets are summarized in Table 2.3.2-A.  </p><p>表2.3.2-A总结了两个必需和两个可选浮点值集的参数N和K（以及导出的参数E_min和E_max）的约束。</p><p>Table 2.3.2-A. Floating-point value set parameters</p><table><thead><tr><th>Parameter</th><th>float</th><th>float-extended-exponent</th><th>double</th><th>double-extended-exponent</th></tr></thead><tbody><tr><td>N</td><td>24</td><td>24</td><td>53</td><td>53</td></tr><tr><td>K</td><td>8</td><td>≥ 11</td><td>11</td><td>≥ 15</td></tr><tr><td>E_max</td><td>+127</td><td>≥ +1023</td><td>+1023</td><td>≥ +16383</td></tr><tr><td>E_min</td><td>-126</td><td>≤ -1022</td><td>-1022</td><td>≤ -16382</td></tr></tbody></table><p>Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant K, whose value is constrained by Table 2.3.2-A; this value K in turn dictates the values for E_min and E_max.</p><p>如果一个实现支持一种或两种扩展指数值集，那么对于每种支持的扩展指数值集，都有一个特定的实现依赖常量K，其值受表2.3.2-A的约束；这个K值又决定了E_min和E_max的值。</p><p>Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also the five values positive zero, negative zero, positive infinity, negative infinity, and NaN.</p><p>四个值集中的每一个不仅包括上面提到的有限非零值，还包括五个值：正零、负零、正无穷大、负无穷大和NaN。</p><p>Note that the constraints in Table 2.3.2-A are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set. Likewise, each element of the double value set is necessarily also an element of the double-extended-exponent value set. Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.</p><p>注意，表2.3.2-A中的约束设计为使float值集中的每个元素都必然也是float-extended-exponent值集、double值集和double-extended-exponent值集中的元素。同样，double值集中的每个元素也必然是double-extended-exponent值集中的元素。每个扩展指数值集的指数值范围都比对应的标准值集更大，但并没有更高的精度。</p><p>The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard, except that there is only one NaN value (IEEE 754 specifies 2^24-2 distinct NaN values). The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard, except that there is only one NaN value (IEEE 754 specifies 2^53-2 distinct NaN values). Note, however, that the elements of the float-extended-exponent and double-extended-exponent value sets defined here do not correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively. This specification does not mandate a specific representation for the values of the floating-point value sets except where floating-point values must be represented in the class file format (§4.4.4, §4.4.5).</p><p>float值集中的元素完全是可以使用IEEE 754标准中定义的单精度浮点格式表示的值，除了只有一个NaN值（IEEE 754指定了2^24-2个不同的NaN值）。double值集中的元素完全是可以使用IEEE 754标准中定义的双精度浮点格式表示的值，除了只有一个NaN值（IEEE 754指定了2^53-2个不同的NaN值）。然而，注意这里定义的float-extended-exponent和double-extended-exponent值集中的元素并不对应于可以使用IEEE 754单扩展和双扩展格式表示的值。此规范并未规定浮点值集的特定表示，除非浮点值必须在类文件格式中表示（§4.4.4，§4.4.5）。</p><p>The float, float-extended-exponent, double, and double-extended-exponent value sets are not types. It is always correct for an implementation of the Java Virtual Machine to use an element of the float value set to represent a value of type float; however, it may be permissible in certain contexts for an implementation to use an element of the float-extended-exponent value set instead. Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type double; however, it may be permissible in certain contexts for an implementation to use an element of the double-extended-exponent value set instead.</p><p><code>float</code>、<code>float-extended-exponent</code>、<code>double</code>和<code>double-extended-exponent</code>值集不是类型。对于Java虚拟机的实现来说，使用<code>float</code>值集中的元素来表示类型为<code>float</code>的值总是正确的；然而，在某些情况下，允许实现使用<code>float-extended-exponent</code>值集中的元素来代替。同样，使用<code>double</code>值集中的元素来表示类型为<code>double</code>的值总是正确的；然而，在某些情况下，允许实现使用<code>double-extended-exponent</code>值集中的元素来代替。</p><p>Except for NaNs, values of the floating-point value sets are ordered. When arranged from smallest to largest, they are negative infinity, negative finite values, positive and negative zero, positive finite values, and positive infinity.</p><p>除了NaN以外，浮点值集中的值是有序的。当从最小到最大排列时，它们依次是负无穷大、负有限值、正负零、正有限值和正无穷大。</p><p>Floating-point positive zero and floating-point negative zero compare as equal, but there are other operations that can distinguish them; for example, dividing 1.0 by 0.0 produces positive infinity, but dividing 1.0 by -0.0 produces negative infinity.</p><p>浮点正零和浮点负零比较时相等，但有其他操作可以区分它们；例如，1.0除以0.0会产生正无穷大，但1.0除以-0.0会产生负无穷大。</p><p>NaNs are unordered, so numerical comparisons and tests for numerical equality have the value false if either or both of their operands are NaN. In particular, a test for numerical equality of a value against itself has the value false if and only if the value is NaN. A test for numerical inequality has the value true if either operand is NaN.</p><p>NaN是无序的，因此如果操作数之一或两个都是NaN，则数值比较和数值相等的测试结果为false。特别地，如果值是NaN，那么对自身的数值相等测试的结果为false，且只有在值是NaN时结果为false。如果任一操作数是NaN，则数值不等测试的结果为true。</p><h3 id="2-3-3-The-returnAddress-Type-and-Values（返回地址类型和值）"><a href="#2-3-3-The-returnAddress-Type-and-Values（返回地址类型和值）" class="headerlink" title="2.3.3 The returnAddress Type and Values（返回地址类型和值）"></a>2.3.3 The returnAddress Type and Values（返回地址类型和值）</h3><p>The returnAddress type is used by the Java Virtual Machine’s jsr, ret, and jsr_w instructions (§jsr, §ret, §jsr_w). The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions. Unlike the numeric primitive types, the returnAddress type does not correspond to any Java programming language type and cannot be modified by the running program.</p><p>返回地址类型由Java虚拟机的<code>jsr</code>、<code>ret</code>和<code>jsr_w</code>指令使用（§jsr，§ret，§jsr_w）。返回地址类型的值是指向Java虚拟机指令操作码的指针。与数值原始类型不同，返回地址类型不对应于任何Java编程语言类型，并且不能由运行的程序修改。</p><h3 id="2-3-4-The-boolean-Type（布尔类型）"><a href="#2-3-4-The-boolean-Type（布尔类型）" class="headerlink" title="2.3.4 The boolean Type（布尔类型）"></a>2.3.4 The boolean Type（布尔类型）</h3><p>Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.  </p><p>尽管Java虚拟机定义了布尔类型，但它对布尔类型的支持非常有限。Java虚拟机没有专门用于操作布尔值的指令。相反，Java编程语言中操作布尔值的表达式被编译为使用Java虚拟机的<code>int</code>数据类型的值。</p><p>The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore).  </p><p>Java虚拟机直接支持布尔数组。它的<code>newarray</code>指令（§newarray）允许创建布尔数组。布尔类型的数组通过字节数组指令<code>baload</code>和<code>bastore</code>（§baload，§bastore）进行访问和修改。</p><p>In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element.  </p><p>在Oracle的Java虚拟机实现中，Java编程语言中的布尔数组被编码为Java虚拟机的字节数组，每个布尔元素使用8位。</p><p>The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int, the compilers must use the same encoding.  </p><p>Java虚拟机使用1编码布尔数组组件来表示true，使用0来表示false。当Java编程语言的布尔值被编译器映射到Java虚拟机的<code>int</code>类型值时，编译器必须使用相同的编码。  </p><hr><h3 id="2-4-Reference-Types-and-Values（引用类型和值集）"><a href="#2-4-Reference-Types-and-Values（引用类型和值集）" class="headerlink" title="2.4 Reference Types and Values（引用类型和值集）"></a>2.4 Reference Types and Values（引用类型和值集）</h3><p>There are three kinds of reference types: class types, array types, and interface types. Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.  </p><p>有三种引用类型：类类型、数组类型和接口类型。它们的值分别是对动态创建的类实例、数组或实现接口的类实例或数组的引用。  </p><p>An array type consists of a component type with a single dimension (whose length is not given by the type). The component type of an array type may itself be an array type. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the element type of the array type. The element type of an array type is necessarily either a primitive type, or a class type, or an interface type.  </p><p>数组类型由具有单一维度的组件类型组成（其长度不是由类型给出的）。数组类型的组件类型本身也可以是数组类型。如果从任何数组类型开始，考虑其组件类型，然后（如果那也是数组类型）考虑该类型的组件类型，依此类推，最终必须到达一个不是数组类型的组件类型；这被称为数组类型的元素类型。数组类型的元素类型必须是基本类型、类类型或接口类型。  </p><p>A reference value may also be the special null reference, a reference to no object, which will be denoted here by null. The null reference initially has no run-time type, but may be cast to any type. The default value of a reference type is null.  </p><p>引用值还可以是特殊的<code>null</code>引用，即对无对象的引用，这里将其表示为<code>null</code>。<code>null</code>引用最初没有运行时类型，但可以转换为任何类型。引用类型的默认值是<code>null</code>。  </p><p>This specification does not mandate a concrete value encoding null.  </p><p>此规范并未规定具体的<code>null</code>值编码。  </p><hr><h2 id="2-5-Run-Time-Data-Areas（运行时数据区域）"><a href="#2-5-Run-Time-Data-Areas（运行时数据区域）" class="headerlink" title="2.5 Run-Time Data Areas（运行时数据区域）"></a>2.5 Run-Time Data Areas（运行时数据区域）</h2><p>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits.  </p><p>Java虚拟机定义了在程序执行期间使用的各种运行时数据区。这些数据区中的一些是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才被销毁。其他数据区是每个线程的。每个线程的数据区是在线程创建时创建的，并在线程退出时销毁。  </p><h3 id="2-5-1-The-pc-Register（pc寄存器）"><a href="#2-5-1-The-pc-Register（pc寄存器）" class="headerlink" title="2.5.1 The pc Register（pc寄存器）"></a>2.5.1 The pc Register（pc寄存器）</h3><p>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine’s pc register is undefined. The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.  </p><p>Java虚拟机可以同时支持多个执行线程（JLS §17）。每个Java虚拟机线程都有自己的pc（程序计数器）寄存器。在任何时候，每个Java虚拟机线程都在执行一个方法的代码，即该线程的当前方法（§2.6）。如果该方法不是本机方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行的方法是本机方法，则Java虚拟机的pc寄存器的值未定义。Java虚拟机的pc寄存器足够宽，可以在特定平台上容纳一个<code>returnAddress</code>或本地指针。  </p><h3 id="2-5-2-Java-Virtual-Machine-Stacks（Java虚拟机栈）"><a href="#2-5-2-Java-Virtual-Machine-Stacks（Java虚拟机栈）" class="headerlink" title="2.5.2 Java Virtual Machine Stacks（Java虚拟机栈）"></a>2.5.2 Java Virtual Machine Stacks（Java虚拟机栈）</h3><p>Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread. A Java Virtual Machine stack stores frames (§2.6). A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated. The memory for a Java Virtual Machine stack does not need to be contiguous.  </p><p>每个Java虚拟机线程都有一个私有的Java虚拟机栈，该栈与线程同时创建。Java虚拟机栈存储帧（§2.6）。Java虚拟机栈类似于传统语言（如C）的栈：它保存局部变量和部分结果，并在方法调用和返回中发挥作用。由于Java虚拟机栈除了推入和弹出帧之外，永远不会直接操作，因此帧可能在堆上分配。Java虚拟机栈的内存不需要是连续的。  </p><p>In the First Edition of The Java® Virtual Machine Specification, the Java Virtual Machine stack was known as the Java stack.  </p><p>在《Java®虚拟机规范》的第一版中，Java虚拟机栈被称为Java栈。  </p><p>This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.  </p><p>此规范允许Java虚拟机栈具有固定大小，或者根据计算需求动态扩展和收缩。如果Java虚拟机栈的大小是固定的，那么每个Java虚拟机栈的大小可以在创建该栈时独立选择。  </p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as, in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.  </p><p>Java虚拟机的实现可以提供给程序员或用户对Java虚拟机栈初始大小的控制，以及在动态扩展或收缩的情况下，对最大和最小大小的控制。 </p><p>The following exceptional conditions are associated with Java Virtual Machine stacks:  </p><ul><li><p>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.  </p></li><li><p>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.</p></li></ul><p>以下异常条件与Java虚拟机栈相关：  </p><ul><li>如果线程中的计算需要比允许的更大的Java虚拟机栈，Java虚拟机会抛出<code>StackOverflowError</code>。  </li><li>如果Java虚拟机栈可以动态扩展，并且尝试扩展但无法提供足够的内存以实现扩展，或者无法提供足够的内存来为新线程创建初始Java虚拟机栈，Java虚拟机会抛出<code>OutOfMemoryError</code>。</li></ul><h3 id="2-5-3-Heap（堆）"><a href="#2-5-3-Heap（堆）" class="headerlink" title="2.5.3 Heap（堆）"></a>2.5.3 Heap（堆）</h3><p>The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.<br>Java虚拟机具有一个堆，该堆在所有Java虚拟机线程之间共享。堆是所有类实例和数组的内存分配的运行时数据区。  </p><p>The heap is created on virtual machine start-up. Heap storage for objects is reclaimed by an automatic storage management system (known as a garbage collector); objects are never explicitly deallocated. The Java Virtual Machine assumes no particular type of automatic storage management system, and the storage management technique may be chosen according to the implementor’s system requirements. The heap may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger heap becomes unnecessary. The memory for the heap does not need to be contiguous.  </p><p>堆是在虚拟机启动时创建的。对象的堆存储由自动存储管理系统（称为垃圾回收器）回收；对象从不被显式释放。Java虚拟机不假设任何特定类型的自动存储管理系统，存储管理技术可以根据实现者的系统要求选择。堆可以是固定大小的，也可以根据计算需求扩展，如果不再需要更大的堆，还可以收缩。堆的内存不需要是连续的。  </p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the heap, as well as, if the heap can be dynamically expanded or contracted, control over the maximum and minimum heap size.  </p><p>Java虚拟机的实现可以提供给程序员或用户对堆初始大小的控制，以及如果堆可以动态扩展或收缩的情况下，对最大和最小堆大小的控制。  </p><p>The following exceptional condition is associated with the heap:  </p><ul><li>If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an OutOfMemoryError.</li></ul><p>以下异常条件与堆相关：  </p><ul><li>如果计算需要比自动存储管理系统可以提供的更多的堆，Java虚拟机会抛出<code>OutOfMemoryError</code>。</li></ul><h3 id="2-5-4-Method-Area（方法区）"><a href="#2-5-4-Method-Area（方法区）" class="headerlink" title="2.5.4 Method Area（方法区）"></a>2.5.4 Method Area（方法区）</h3><p>The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.  </p><p>Java虚拟机具有一个方法区，该方法区在所有Java虚拟机线程之间共享。方法区类似于传统语言的编译代码存储区或类似于操作系统进程中的“文本”段。它存储按类划分的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法（§2.9）。  </p><p>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.  </p><p>方法区在虚拟机启动时创建。尽管方法区在逻辑上是堆的一部分，但简单的实现可以选择不对其进行垃圾回收或压缩。此规范不强制规定方法区的位置或用于管理编译代码的策略。方法区可以是固定大小的，也可以根据计算需求扩展，如果不再需要更大的方法区，还可以收缩。方法区的内存不需要是连续的。  </p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.  </p><p>Java虚拟机的实现可以提供给程序员或用户对方法区初始大小的控制，以及在方法区大小可变的情况下，对最大和最小方法区大小的控制。  </p><p>The following exceptional condition is associated with the method area:  </p><ul><li>If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.</li></ul><p>以下异常条件与方法区相关：  </p><ul><li>如果方法区中的内存无法提供以满足分配请求，Java虚拟机会抛出<code>OutOfMemoryError</code>。</li></ul><h3 id="2-5-5-Run-Time-Constant-Pool（运行时常量池）"><a href="#2-5-5-Run-Time-Constant-Pool（运行时常量池）" class="headerlink" title="2.5.5 Run-Time Constant Pool（运行时常量池）"></a>2.5.5 Run-Time Constant Pool（运行时常量池）</h3><p>A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file (§4.4). It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time. The run-time constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.  </p><p>运行时常量池是每个类或接口在运行时的常量池表（<code>constant_pool</code>）在类文件（§4.4）中的运行时表示。它包含几种类型的常量，从编译时已知的数值字面量到必须在运行时解析的方法和字段引用。运行时常量池的功能类似于传统编程语言的符号表，尽管它包含的数据范围比典型的符号表更广泛。  </p><p>Each run-time constant pool is allocated from the Java Virtual Machine’s method area (§2.5.4). The run-time constant pool for a class or interface is constructed when the class or interface is created (§5.3) by the Java Virtual Machine.  </p><p>每个运行时常量池都从Java虚拟机的方法区（<code>method area</code>，§2.5.4）中分配。类或接口的运行时常量池是在该类或接口被Java虚拟机创建时（§5.3）构建的。  </p><p>The following exceptional condition is associated with the construction of the run-time constant pool for a class or interface:  </p><ul><li>When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul><p>以下异常情况与类或接口的运行时常量池构建相关：  </p><ul><li>在创建类或接口时，如果运行时常量池的构建需要的内存超过了Java虚拟机的方法区中可用的内存，Java虚拟机会抛出<code>OutOfMemoryError</code>错误。</li></ul><p>See §5 (Loading, Linking, and Initializing) for information about the construction of the run-time constant pool.  </p><p>关于运行时常量池的构建，请参见§5（加载、链接和初始化）。  </p><h3 id="2-5-6-Native-Method-Stacks（本地方法栈）"><a href="#2-5-6-Native-Method-Stacks（本地方法栈）" class="headerlink" title="2.5.6 Native Method Stacks（本地方法栈）"></a>2.5.6 Native Method Stacks（本地方法栈）</h3><p>An implementation of the Java Virtual Machine may use conventional stacks, colloquially called “C stacks,” to support native methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter for the Java Virtual Machine’s instruction set in a language such as C. Java Virtual Machine implementations that cannot load native methods and that do not themselves rely on conventional stacks need not supply native method stacks. If supplied, native method stacks are typically allocated per thread when each thread is created.  </p><p>Java虚拟机的实现可以使用常规栈（通常称为“C栈”）来支持本地方法（用非Java编程语言编写的方法）。本地方法栈还可以用于以C语言等实现的Java虚拟机指令集解释器。如果Java虚拟机的实现不能加载本地方法，并且本身也不依赖常规栈，则不需要提供本地方法栈。如果提供，本地方法栈通常会在每个线程创建时为每个线程分配。  </p><p>This specification permits native method stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the native method stacks are of a fixed size, the size of each native method stack may be chosen independently when that stack is created.  </p><p>本规范允许本地方法栈的大小可以是固定的，也可以根据计算需求动态扩展和收缩。如果本地方法栈是固定大小的，则每个本地方法栈的大小可以在栈创建时独立选择。  </p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the native method stacks, as well as, in the case of varying-size native method stacks, control over the maximum and minimum method stack sizes.  </p><p>Java虚拟机的实现可以让程序员或用户控制本地方法栈的初始大小，以及在可变大小的本地方法栈的情况下，控制最大和最小栈大小。  </p><p>The following exceptional conditions are associated with native method stacks:  </p><ul><li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.  </li><li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul><p>以下异常情况与本地方法栈相关：  </p><ul><li>如果线程中的计算需要比允许的更大的本地方法栈，Java虚拟机会抛出<code>StackOverflowError</code>错误。 </li><li>如果本地方法栈可以动态扩展，并且尝试扩展时内存不足，或者为新线程创建初始本地方法栈时内存不足，Java虚拟机会抛出<code>OutOfMemoryError</code>错误。</li></ul><hr><h2 id="2-6-Frames（帧）"><a href="#2-6-Frames（帧）" class="headerlink" title="2.6 Frames（帧）"></a>2.6 Frames（帧）</h2><p>A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.   </p><p>帧用于存储数据和部分结果，以及执行动态链接、返回方法的值和分发异常。  </p><p>A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame. Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the runtime constant pool (§2.5.5) of the class of the current method.  </p><p>每次调用方法时都会创建一个新的帧。当方法调用完成时，无论该完成是正常的还是异常的（抛出未捕获的异常），帧都会被销毁。帧是从创建该帧的线程的Java虚拟机堆栈（§2.5.2）中分配的。每个帧都有自己的局部变量数组（§2.6.1）、自己的操作数堆栈（§2.6.2），以及对当前方法所属类的运行时常量池（§2.5.5）的引用。  </p><p>A frame may be extended with additional implementation-specific information, such as debugging information.</p><p>帧可以通过额外的实现特定信息进行扩展，例如调试信息。</p><p>The sizes of the local variable array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame (§4.7.3). Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.</p><p>局部变量数组和操作数堆栈的大小在编译时确定，并随与帧相关联的方法代码一起提供（§4.7.3）。因此，帧数据结构的大小仅取决于Java虚拟机的实现，且这些结构的内存可以在方法调用时同时分配。</p><p>Only one frame, the frame for the executing method, is active at any point in a given thread of control. This frame is referred to as the current frame, and its method is known as the current method. The class in which the current method is defined is the current class. Operations on local variables and the operand stack are typically with reference to the current frame.</p><p>在给定的控制线程中的任何时刻，只有一个帧（用于正在执行的方法）处于活动状态。这个帧被称为当前帧，其方法被称为当前方法。定义当前方法的类被称为当前类。对局部变量和操作数堆栈的操作通常是相对于当前帧进行的。</p><p>A frame ceases to be current if its method invokes another method or if its method completes. When a method is invoked, a new frame is created and becomes current when control transfers to the new method. On method return, the current frame passes back the result of its method invocation, if any, to the previous frame. The current frame is then discarded as the previous frame becomes the current one.</p><p>如果当前帧的方法调用了另一个方法或其方法完成，帧将不再是当前帧。当一个方法被调用时，会创建一个新的帧，并在控制转移到新方法时成为当前帧。在方法返回时，当前帧将其方法调用的结果（如果有）传递给前一个帧。当前帧随后被丢弃，而前一个帧成为当前帧。</p><p>Note that a frame created by a thread is local to that thread and cannot be referenced by any other thread.</p><p>请注意，由一个线程创建的帧是该线程的局部帧，不能被任何其他线程引用。</p><h3 id="2-6-1-Local-Variables（局部变量）"><a href="#2-6-1-Local-Variables（局部变量）" class="headerlink" title="2.6.1 Local Variables（局部变量）"></a>2.6.1 Local Variables（局部变量）</h3><p>Each frame (§2.6) contains an array of variables known as its local variables. The length of the local variable array of a frame is determined at compile-time and supplied in the binary representation of a class or interface along with the code for the method associated with the frame (§4.7.3).  </p><p>每个帧（§2.6）包含一个称为局部变量的数组。帧的局部变量数组的长度在编译时确定，并在类或接口的二进制表示中与与帧相关联的方法代码一起提供（§4.7.3）。  </p><p>A single local variable can hold a value of type boolean, byte, char, short, int, float, reference, or returnAddress. A pair of local variables can hold a value of type long or double.  </p><p>一个局部变量可以保存一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的值。一对局部变量可以保存一个<code>long</code>或<code>double</code>类型的值。  </p><p>Local variables are addressed by indexing. The index of the first local variable is zero. An integer is considered to be an index into the local variable array if and only if that integer is between zero and one less than the size of the local variable array.  </p><p>局部变量通过索引进行访问。第一个局部变量的索引为0。只有当一个整数在0到局部变量数组大小减一之间时，该整数才被视为局部变量数组的索引。  </p><p>A value of type long or type double occupies two consecutive local variables. Such a value may only be addressed using the lesser index. For example, a value of type double stored in the local variable array at index n actually occupies the local variables with indices n and n+1; however, the local variable at index n+1 cannot be loaded from. It can be stored into. However, doing so invalidates the contents of local variable n.  </p><p><code>long</code>或<code>double</code>类型的值占用两个连续的局部变量。这样的值只能通过较小的索引进行访问。例如，存储在局部变量数组索引n处的<code>double</code>类型的值实际上占用了索引n和n+1的局部变量；然而，不能从索引n+1的局部变量加载值。它可以被存储进去。但这样做会使局部变量n的内容无效。  </p><p>The Java Virtual Machine does not require n to be even. In intuitive terms, values of types long and double need not be 64-bit aligned in the local variables array. Implementors are free to decide the appropriate way to represent such values using the two local variables reserved for the value.  </p><p>Java虚拟机不要求n必须是偶数。直观地说，<code>long</code>和<code>double</code>类型的值在局部变量数组中不需要64位对齐。实现者可以自由决定使用为该值保留的两个局部变量来表示该值的适当方式。  </p><p>The Java Virtual Machine uses local variables to pass parameters on method invocation. On class method invocation, any parameters are passed in consecutive local variables starting from local variable 0. On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (this in the Java programming language). Any parameters are subsequently passed in consecutive local variables starting from local variable 1.  </p><p>Java虚拟机使用局部变量在方法调用时传递参数。在类方法调用时，任何参数都会从局部变量0开始依次传递。在实例方法调用时，局部变量0始终用于传递对调用实例方法的对象的引用（在Java编程语言中称为<code>this</code>）。任何参数随后从局部变量1开始依次传递。  </p><h3 id="2-6-2-Operand-Stacks（操作数栈）"><a href="#2-6-2-Operand-Stacks（操作数栈）" class="headerlink" title="2.6.2 Operand Stacks（操作数栈）"></a>2.6.2 Operand Stacks（操作数栈）</h3><p>Each frame (§2.6) contains a last-in-first-out (LIFO) stack known as its operand stack. The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame (§4.7.3).  </p><p>每个帧（§2.6）包含一个后进先出（LIFO）的栈，称为其操作数栈。帧的操作数栈的最大深度在编译时确定，并与与帧相关联的方法代码一起提供（§4.7.3）。  </p><p>Where it is clear by context, we will sometimes refer to the operand stack of the current frame as simply the operand stack.  </p><p>在上下文明确的情况下，我们有时会将当前帧的操作数堆栈简称为操作数栈。</p><p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack. Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack. The operand stack is also used to prepare parameters to be passed to methods and to receive method results.  </p><p>当包含操作数栈的帧被创建时，操作数栈是空的。Java虚拟机提供指令将常量或值从局部变量或字段加载到操作数栈上。其他Java虚拟机指令从操作数栈获取操作数，对其进行操作，然后将结果推回操作数栈。操作数栈还用于准备传递给方法的参数并接收方法的结果。  </p><p>For example, the iadd instruction (§iadd) adds two int values together. It requires that the int values to be added be the top two values of the operand stack, pushed there by previous instructions. Both of the int values are popped from the operand stack. They are added, and their sum is pushed back onto the operand stack. Subcomputations may be nested on the operand stack, resulting in values that can be used by the encompassing computation.  </p><p>例如，<code>iadd</code>指令（§iadd）将两个<code>int</code>值相加。它要求被相加的<code>int</code>值是操作数栈的顶部两个值，这些值是由之前的指令推入栈的。这两个<code>int</code>值从操作数栈中弹出。它们被相加，并且它们的和被推回操作数栈。子计算可以嵌套在操作数栈上，从而生成可由包含的计算使用的值。  </p><p>Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type long or double.  </p><p>操作数栈上的每个条目可以保存任何Java虚拟机类型的值，包括<code>long</code>或<code>double</code>类型的值。  </p><p>Values from the operand stack must be operated upon in ways appropriate to their types. It is not possible, for example, to push two int values and subsequently treat them as a long or to push two float values and subsequently add them with an iadd instruction.  </p><p>从操作数栈中取出的值必须按照适合其类型的方式进行操作。例如，不可能先推入两个<code>int</code>值，然后将它们当作<code>long</code>处理，或者先推入两个<code>float</code>值，然后用<code>iadd</code>指令将它们相加。  </p><p>A small number of Java Virtual Machine instructions (the dup instructions (§dup) and swap (§swap)) operate on runtime data areas as raw values without regard to their specific types; these instructions are defined in such a way that they cannot be used to modify or break up individual values. These restrictions on operand stack manipulation are enforced through class file verification (§4.10).  </p><p>少量Java虚拟机指令（如<code>dup</code>指令（§dup）和<code>swap</code>（§swap））对运行时数据区作为原始值进行操作，而不考虑它们的具体类型；这些指令的定义方式使得它们不能被用于修改或分解单个值。这些对操作数栈操作的限制通过类文件验证（§4.10）强制执行。  </p><p>At any point in time, an operand stack has an associated depth, where a value of type long or double contributes two units to the depth and a value of any other type contributes one unit.  </p><p>在任何时候，操作数栈都有一个相关的深度，其中<code>long</code>或<code>double</code>类型的值贡献两个单位深度，任何其他类型的值贡献一个单位深度。  </p><h3 id="2-6-3-Dynamic-Linking（动态链接）"><a href="#2-6-3-Dynamic-Linking（动态链接）" class="headerlink" title="2.6.3 Dynamic Linking（动态链接）"></a>2.6.3 Dynamic Linking（动态链接）</h3><p>Each frame (§2.6) contains a reference to the runtime constant pool (§2.5.5) for the type of the current method to support dynamic linking of the method code.  </p><p>每个帧（§2.6）包含一个对当前方法类型的运行时常量池（§2.5.5）的引用，以支持方法代码的动态链接。  </p><p>The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the runtime location of these variables.  </p><p>方法的类文件代码通过符号引用来引用要调用的方法和要访问的变量。动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关的存储结构中的适当偏移。  </p><p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.  </p><p>这种方法和变量的晚绑定使得方法所使用的其他类的更改不太可能破坏该代码。  </p><h3 id="2-6-4-Normal-Method-Invocation-Completion（方法调用正常完成）"><a href="#2-6-4-Normal-Method-Invocation-Completion（方法调用正常完成）" class="headerlink" title="2.6.4 Normal Method Invocation Completion（方法调用正常完成）"></a>2.6.4 Normal Method Invocation Completion（方法调用正常完成）</h3><p>A method invocation completes normally if that invocation does not cause an exception (§2.10) to be thrown, either directly from the Java Virtual Machine or as a result of executing an explicit throw statement.  </p><p>如果方法调用不会导致异常（§2.10）被抛出，无论是直接从Java虚拟机抛出还是由于执行显式的<code>throw</code>语句引发，则该方法调用正常完成。  </p><p>If the invocation of the current method completes normally, then a value may be returned to the invoking method. This occurs when the invoked method executes one of the return instructions (§2.11.8), the choice of which must be appropriate for the type of the value being returned (if any).  </p><p>如果当前方法的调用正常完成，那么可能会有一个值返回给调用方法。这发生在被调用的方法执行其中一个返回指令（§2.11.8）时，所选择的返回指令必须适合要返回的值的类型（如果有的话）。  </p><p>The current frame (§2.6) is used in this case to restore the state of the invoker, including its local variables and operand stack, with the program counter of the invoker appropriately incremented to skip past the method invocation instruction. Execution then continues normally in the invoking method’s frame with the returned value (if any) pushed onto the operand stack of that frame.  </p><p>在这种情况下，当前帧（§2.6）用于恢复调用者的状态，包括其局部变量和操作数堆栈，并适当增加调用者的程序计数器以跳过方法调用指令。然后，执行在调用方法的帧中正常继续，返回的值（如果有的话）会被推入该帧的操作数堆栈。  </p><h3 id="2-6-5-Abrupt-Method-Invocation-Completion（方法调用异常完成）"><a href="#2-6-5-Abrupt-Method-Invocation-Completion（方法调用异常完成）" class="headerlink" title="2.6.5 Abrupt Method Invocation Completion（方法调用异常完成）"></a>2.6.5 Abrupt Method Invocation Completion（方法调用异常完成）</h3><p>A method invocation completes abruptly if execution of a Java Virtual Machine instruction within the method causes the Java Virtual Machine to throw an exception (§2.10), and that exception is not handled within the method.  </p><p>如果方法中的Java虚拟机指令的执行导致Java虚拟机抛出异常（§2.10），并且该异常未在方法内处理，则该方法调用会异常完成。  </p><p>Execution of an athrow instruction (§athrow) also causes an exception to be explicitly thrown and, if the exception is not caught by the current method, results in abrupt method invocation completion. A method invocation that completes abruptly never returns a value to its invoker.  </p><p>执行<code>athrow</code>指令（§athrow）也会导致显式抛出异常，并且如果该异常未被当前方法捕获，将导致方法调用异常完成。异常完成的方法调用永远不会将值返回给其调用者。  </p><hr><h3 id="2-7-Representation-of-Objects（对象的表示）"><a href="#2-7-Representation-of-Objects（对象的表示）" class="headerlink" title="2.7 Representation of Objects（对象的表示）"></a>2.7 Representation of Objects（对象的表示）</h3><p>The Java Virtual Machine does not mandate any particular internal structure for objects.</p><p>Java虚拟机不强制规定对象的任何特定内部结构。</p><p>In some of Oracle’s implementations of the Java Virtual Machine, a reference to a class instance is a pointer to a handle that is itself a pair of pointers: one to a table containing the methods of the object and a pointer to the Class object that represents the type of the object, and the other to the memory allocated from the heap for the object data.</p><p>在Oracle的某些Java虚拟机实现中，对类实例的引用是一个指向句柄的指针，该句柄本身是一对指针：一个指向包含对象方法的表和一个指向表示对象类型的<code>Class</code>对象的指针，另一个指向为对象数据从堆中分配的内存。</p><hr><h3 id="2-8-Floating-Point-Arithmetic（浮点数计算）"><a href="#2-8-Floating-Point-Arithmetic（浮点数计算）" class="headerlink" title="2.8 Floating-Point Arithmetic（浮点数计算）"></a>2.8 Floating-Point Arithmetic（浮点数计算）</h3><p>The Java Virtual Machine incorporates a subset of the floating-point arithmetic specified in IEEE Standard for Binary Floating-Point Arithmetic (ANSI&#x2F;IEEE Std. 754-1985, New York).</p><p>Java虚拟机包含了IEEE二进制浮点运算标准（ANSI&#x2F;IEEE Std. 754-1985，纽约）中指定的浮点运算的一个子集。</p><h3 id="2-8-1-Java-Virtual-Machine-Floating-Point-Arithmetic-and-IEEE-754（Java虚拟机中的浮点计算和IEEE-754）"><a href="#2-8-1-Java-Virtual-Machine-Floating-Point-Arithmetic-and-IEEE-754（Java虚拟机中的浮点计算和IEEE-754）" class="headerlink" title="2.8.1 Java Virtual Machine Floating-Point Arithmetic and IEEE 754（Java虚拟机中的浮点计算和IEEE 754）"></a>2.8.1 Java Virtual Machine Floating-Point Arithmetic and IEEE 754（Java虚拟机中的浮点计算和IEEE 754）</h3><p>The key differences between the floating-point arithmetic supported by the Java Virtual Machine and the IEEE 754 standard are:</p><p>Java虚拟机支持的浮点运算与IEEE 754标准的主要区别在于：</p><ul><li><p>The floating-point operations of the Java Virtual Machine do not throw exceptions, trap, or otherwise signal the IEEE 754 exceptional conditions of invalid operation, division by zero, overflow, underflow, or inexact. The Java Virtual Machine has no signaling NaN value.</p><p>Java虚拟机的浮点运算不会抛出异常、陷阱或以其他方式指示IEEE 754规定的无效操作、除零、溢出、下溢或不精确的异常情况。Java虚拟机没有信号NaN值。</p></li><li><p>The Java Virtual Machine does not support IEEE 754 signaling floating-point comparisons.  </p><p>Java虚拟机不支持IEEE 754信号浮点比较。</p></li><li><p>The rounding operations of the Java Virtual Machine always use IEEE 754 round to nearest mode. Inexact results are rounded to the nearest representable value, with ties going to the value with a zero least-significant bit. This is the IEEE 754 default mode. But Java Virtual Machine instructions that convert values of floating-point types to values of integral types round toward zero. The Java Virtual Machine does not give any means to change the floating-point rounding mode.</p><p>Java虚拟机的舍入操作始终使用IEEE 754的舍入到最近模式。不精确的结果被舍入到最近的可表示值，如果两个最近的可表示值一样近，则选择最不重要位为零的值。这是IEEE 754的默认模式。但将浮点类型的值转换为整数类型的值的Java虚拟机指令会朝零舍入。Java虚拟机没有提供任何更改浮点舍入模式的方法。</p></li><li><p>The Java Virtual Machine does not support either the IEEE 754 single extended or double extended format, except insofar as the double and double-extended-exponent value sets may be said to support the single extended format. The float-extended-exponent and double-extended-exponent value sets, which may optionally be supported, do not correspond to the values of the IEEE 754 extended formats: the IEEE 754 extended formats require extended precision as well as extended exponent range.  </p><p>Java虚拟机不支持IEEE 754单扩展或双扩展格式，除非可以说双扩展和双扩展指数值集支持单扩展格式。浮点扩展指数和双扩展指数值集（可选支持）不对应IEEE 754扩展格式的值：IEEE 754扩展格式要求扩展精度以及扩展指数范围。</p></li></ul><h3 id="2-8-2-Floating-Point-Modes（浮点模式）"><a href="#2-8-2-Floating-Point-Modes（浮点模式）" class="headerlink" title="2.8.2 Floating-Point Modes（浮点模式）"></a>2.8.2 Floating-Point Modes（浮点模式）</h3><p>Every method has a floating-point mode, which is either FP-strict or not FP-strict. The floating-point mode of a method is determined by the setting of the ACC_STRICT flag of the access_flags item of the method_info structure (§4.6) defining the method. A method for which this flag is set is FP-strict; otherwise, the method is not FP-strict. </p><p>每个方法都有一个浮点模式，它要么是<code>FP-strict</code>，要么不是。方法的浮点模式由定义该方法的<code>method_info</code>结构的<code>access_flags</code>项的<code>ACC_STRICT</code>标志的设置决定（§4.6）。如果设置了此标志的方法是<code>FP-strict</code>的，否则该方法不是<code>FP-strict</code>的。</p><p>Note that this mapping of the ACC_STRICT flag implies that methods in classes compiled by a compiler in JDK release 1.1 or earlier are effectively not FP-strict.</p><p>请注意，这种<code>ACC_STRICT</code>标志的映射意味着由JDK 1.1或更早版本的编译器编译的类中的方法实际上不是<code>FP-strict</code>的。</p><p>We will refer to an operand stack as having a given floating-point mode when the method whose invocation created the frame containing the operand stack has that floating-point mode. Similarly, we will refer to a Java Virtual Machine instruction as having a given floating-point mode when the method containing that instruction has that floating-point mode.  </p><p>当调用创建包含操作数堆栈的帧的方法具有某种浮点模式时，我们将称操作数堆栈具有该浮点模式。类似地，当包含该指令的方法具有某种浮点模式时，我们将称Java虚拟机指令具有该浮点模式。</p><p>If a float-extended-exponent value set is supported (§2.3.2), values of type float on an operand stack that is not FP-strict may range over that value set except where prohibited by value set conversion (§2.8.3). If a double-extended-exponent value set is supported (§2.3.2), values of type double on an operand stack that is not FP-strict may range over that value set except where prohibited by value set conversion.</p><p>如果支持浮点扩展指数值集（§2.3.2），则在非<code>FP-strict</code>的操作数堆栈上的<code>float</code>类型值可以在该值集内变动，除非值集转换（§2.8.3）禁止这样做。如果支持双扩展指数值集（§2.3.2），则在非<code>FP-strict</code>的操作数堆栈上的<code>double</code>类型值可以在该值集内变动，除非值集转换禁止这样做。</p><p>In all other contexts, whether on the operand stack or elsewhere, and regardless of floating-point mode, floating-point values of type float and double may only range over the float value set and double value set, respectively. In particular, class and instance fields, array elements, local variables, and method parameters may only contain values drawn from the standard value sets.</p><p>在所有其他上下文中，无论是在操作数堆栈上还是在其他地方，并且无论浮点模式如何，<code>float</code>和<code>double</code>类型的浮点值只能在<code>float</code>值集和<code>double</code>值集内变动。特别是，类和实例字段、数组元素、局部变量和方法参数只能包含来自标准值集的值。</p><h3 id="2-8-3-Value-Set-Conversion（值集转换）"><a href="#2-8-3-Value-Set-Conversion（值集转换）" class="headerlink" title="2.8.3 Value Set Conversion（值集转换）"></a>2.8.3 Value Set Conversion（值集转换）</h3><p>An implementation of the Java Virtual Machine that supports an extended floating-point value set is permitted or required, under specified circumstances, to map a value of the associated floating-point type between the extended and the standard value sets. Such a value set conversion is not a type conversion, but a mapping between the value sets associated with the same type.</p><p>支持扩展浮点值集的Java虚拟机实现被允许或在特定情况下被要求在扩展值集和标准值集之间映射与浮点类型相关的值。这种值集转换不是类型转换，而是与同一类型相关的值集之间的映射。</p><p>Where value set conversion is indicated, an implementation is permitted to perform one of the following operations on a value:</p><p>在指示进行值集转换的地方，实现允许对一个值执行以下操作之一：</p><ul><li><p>If the value is of type float and is not an element of the float value set, it maps the value to the nearest element of the float value set.</p><p>如果值的类型是<code>float</code>，并且不是<code>float</code>值集的元素，它会将该值映射到<code>float</code>值集中最近的元素。</p></li><li><p>If the value is of type double and is not an element of the double value set, it maps the value to the nearest element of the double value set.</p><p>如果值的类型是<code>double</code>，并且不是<code>double</code>值集的元素，它会将该值映射到<code>double</code>值集中最近的元素。</p></li></ul><p>In addition, where value set conversion is indicated, certain operations are required:  </p><p>此外，在指示进行值集转换的地方，某些操作是必须的：  </p><ul><li><p>Suppose execution of a Java Virtual Machine instruction that is not FP-strict causes a value of type float to be pushed onto an operand stack that is FP-strict, passed as a parameter, or stored into a local variable, a field, or an element of an array. If the value is not an element of the float value set, it maps the value to the nearest element of the float value set.</p><p>假设执行一个非<code>FP-strict</code>的Java虚拟机指令导致一个<code>float</code>类型的值被推送到一个<code>FP-strict</code>的操作数堆栈中，作为参数传递，或者存储到局部变量、字段或数组的元素中。如果该值不是<code>float</code>值集的元素，它会将该值映射到<code>float</code>值集中最近的元素。</p></li><li><p>Suppose execution of a Java Virtual Machine instruction that is not FP-strict causes a value of type double to be pushed onto an operand stack that is FP-strict, passed as a parameter, or stored into a local variable, a field, or an element of an array. If the value is not an element of the double value set, it maps the value to the nearest element of the double value set.</p><p>假设执行一个非<code>FP-strict</code>的Java虚拟机指令导致一个<code>double</code>类型的值被推送到一个<code>FP-strict</code>的操作数堆栈中，作为参数传递，或者存储到局部变量、字段或数组的元素中。如果该值不是<code>double</code>值集的元素，它会将该值映射到<code>double</code>值集中最近的元素。</p></li></ul><p>Such required value set conversions may occur as a result of passing a parameter of a floating-point type during method invocation, including native method invocation; returning a value of a floating-point type from a method that is not FP-strict to a method that is FP-strict; or storing a value of a floating-point type into a local variable, a field, or an array in a method that is not FP-strict.</p><p>这些必需的值集转换可能是由于在方法调用期间传递浮点类型的参数（包括本机方法调用）、从非<code>FP-strict</code>的方法返回浮点类型的值到<code>FP-strict</code>的方法，或者将浮点类型的值存储到非<code>FP-strict</code>的方法中的局部变量、字段或数组中所导致的。</p><p>Not all values from an extended-exponent value set can be mapped exactly to a value in the corresponding standard value set. If a value being mapped is too large to be represented exactly (its exponent is greater than that permitted by the standard value set), it is converted to a (positive or negative) infinity of the corresponding type. If a value being mapped is too small to be represented exactly (its exponent is smaller than that permitted by the standard value set), it is rounded to the nearest of a representable denormalized value or zero of the same sign.</p><p>并非扩展指数值集中的所有值都可以准确地映射到对应的标准值集中的值。如果被映射的值过大而无法精确表示（其指数大于标准值集允许的范围），则它会被转换为对应类型的（正或负）无穷大。如果被映射的值过小而无法精确表示（其指数小于标准值集允许的范围），则它会被舍入为可表示的非标准化值或同符号的零。</p><p>Value set conversion preserves infinities and NaNs and cannot change the sign of the value being converted. Value set conversion has no effect on a value that is not of a floating-point type.</p><p>值集转换保留无穷大和NaN，并且不能改变被转换值的符号。值集转换对非浮点类型的值没有影响。</p><hr><h3 id="2-9-Special-Methods（特殊方法）"><a href="#2-9-Special-Methods（特殊方法）" class="headerlink" title="2.9 Special Methods（特殊方法）"></a>2.9 Special Methods（特殊方法）</h3><p>At the level of the Java Virtual Machine, every constructor written in the Java programming language (JLS §8.8) appears as an instance initialization method that has the special name &lt;init&gt;. This name is supplied by a compiler. Because the name &lt;init&gt; is not a valid identifier, it cannot be used directly in a program written in the Java programming language. Instance initialization methods may be invoked only within the Java Virtual Machine by the invokespecial instruction (§invokespecial), and they may be invoked only on uninitialized class instances. An instance initialization method takes on the access permissions (JLS §6.6) of the constructor from which it was derived.</p><p>在Java虚拟机级别，用Java编程语言编写的每个构造函数（JLS §8.8）都表现为一个实例初始化方法，该方法具有特殊名称<code>&lt;init&gt;</code>。这个名称由编译器提供。由于名称<code>&lt;init&gt;</code>不是有效的标识符，因此不能在用Java编写的程序中直接使用。实例初始化方法只能在Java虚拟机内通过<code>invokespecial</code>指令（§invokespecial）调用，并且它们只能在未初始化的类实例上调用。实例初始化方法继承了它所派生的构造函数的访问权限（JLS §6.6）。</p><p>A class or interface has at most one class or interface initialization method and is initialized (§5.5) by invoking that method. The initialization method of a class or interface has the special name &lt;clinit&gt;, takes no arguments, and is void (§4.3.3).</p><p>一个类或接口最多有一个类或接口初始化方法，并通过调用该方法初始化（§5.5）。类或接口的初始化方法具有特殊名称<code>&lt;clinit&gt;</code>，不接受任何参数，并且是<code>void</code>类型（§4.3.3）。</p><p>Other methods named &lt;clinit&gt; in a class file are of no consequence. They are not class or interface initialization methods. They cannot be invoked by any Java Virtual Machine instruction and are never invoked by the Java Virtual Machine itself.</p><p>类文件中其他名为<code>&lt;clinit&gt;</code>的方法没有任何意义。它们不是类或接口初始化方法。它们不能被任何Java虚拟机指令调用，也不会被Java虚拟机本身调用。</p><p>In a class file whose version number is 51.0 or above, the method must additionally have its ACC_STATIC flag (§4.6) set in order to be the class or interface initialization method.</p><p>在版本号为51.0或更高的类文件中，该方法还必须设置<code>ACC_STATIC</code>标志（§4.6）才能成为类或接口初始化方法。</p><p>This requirement was introduced in Java SE 7. In a class file whose version number is 50.0 or below, a method named &lt;clinit&gt; that is void and takes no arguments is considered the class or interface initialization method regardless of the setting of its ACC_STATIC flag.</p><p>此要求是在Java SE 7中引入的。在版本号为50.0或更低的类文件中，无论<code>ACC_STATIC</code>标志的设置如何，一个名为<code>&lt;clinit&gt;</code>且为<code>void</code>类型并且不接受任何参数的方法都被视为类或接口初始化方法。</p><p>The name &lt;clinit&gt; is supplied by a compiler. Because the name &lt;clinit&gt; is not a valid identifier, it cannot be used directly in a program written in the Java programming language. Class and interface initialization methods are invoked implicitly by the Java Virtual Machine; they are never invoked directly from any Java Virtual Machine instruction, but are invoked only indirectly as part of the class initialization process.</p><p>名称<code>&lt;clinit&gt;</code>由编译器提供。由于名称<code>&lt;clinit&gt;</code>不是有效的标识符，因此不能在用Java编写的程序中直接使用。类和接口初始化方法由Java虚拟机隐式调用；它们从不会直接从任何Java虚拟机指令中调用，而只是作为类初始化过程的一部分间接调用。</p><p>A method is signature polymorphic if all of the following are true:</p><ul><li>It is declared in the java.lang.invoke.MethodHandle class.</li><li>It has a single formal parameter of type Object[].</li><li>It has a return type of Object.</li><li>It has the ACC_VARARGS and ACC_NATIVE flags set.</li></ul><p>如果满足以下所有条件，则一个方法是签名多态的：</p><ul><li>它在<code>java.lang.invoke.MethodHandle</code>类中声明。</li><li>它有一个类型为<code>Object[]</code>的正式参数。</li><li>它的返回类型是<code>Object</code>。</li><li>它设置了<code>ACC_VARARGS</code>和<code>ACC_NATIVE</code>标志。</li></ul><p>In Java SE 8, the only signature polymorphic methods are the invoke and invokeExact methods of the class java.lang.invoke.MethodHandle.</p><p>在Java SE 8中，唯一的签名多态方法是<code>java.lang.invoke.MethodHandle</code>类的<code>invoke</code>和<code>invokeExact</code>方法。</p><p>The Java Virtual Machine gives special treatment to signature polymorphic methods in the invokevirtual instruction (§invokevirtual), in order to effect invocation of a method handle. A method handle is a strongly typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation (§5.4.3.5), with optional transformations of arguments or return values. These transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution. See the java.lang.invoke package in the Java SE platform API for more information.</p><p>Java虚拟机在<code>invokevirtual</code>指令（§invokevirtual）中对签名多态方法进行了特殊处理，以便有效地调用方法句柄。方法句柄是对底层方法、构造函数、字段或类似低级操作的强类型、直接可执行的引用（§5.4.3.5），并可以选择性地对参数或返回值进行转换。这些转换非常通用，包括转换、插入、删除和替换等模式。有关更多信息，请参阅Java SE平台API中的<code>java.lang.invoke</code>包。</p><hr><h3 id="2-10-Exceptions（异常）"><a href="#2-10-Exceptions（异常）" class="headerlink" title="2.10 Exceptions（异常）"></a>2.10 Exceptions（异常）</h3><p>An exception in the Java Virtual Machine is represented by an instance of the class Throwable or one of its subclasses. Throwing an exception results in an immediate nonlocal transfer of control from the point where the exception was thrown.</p><p>在Java虚拟机中，异常由<code>Throwable</code>类或其子类的实例表示。抛出异常会导致从抛出异常的点立即进行非局部控制转移。</p><p>Most exceptions occur synchronously as a result of an action by the thread in which they occur. An asynchronous exception, by contrast, can potentially occur at any point in the execution of a program. The Java Virtual Machine throws an exception for one of three reasons:  </p><p>大多数异常是由于它们发生的线程的操作而同步发生的。相比之下，异步异常可能会在程序执行的任何点发生。Java虚拟机因以下三种原因之一抛出异常：</p><ul><li>An athrow instruction (§athrow) was executed.</li><li>An abnormal execution condition was synchronously detected by the Java Virtual Machine.These exceptions are not thrown at an arbitrary point in the program, but only synchronously after execution of an instruction that either:<ul><li>Specifies the exception as a possible result, such as:<ul><li>When the instruction embodies an operation that violates the semantics of the Java programming language, for example indexing outside the bounds of an array.</li><li>When an error occurs in loading or linking part of the program.</li></ul></li><li>Causes some limit on a resource to be exceeded, for example when too much memory is used.</li></ul></li><li>An asynchronous exception occurred because:<ul><li>The stop method of class Thread or ThreadGroup was invoked, or</li><li>An internal error occurred in the Java Virtual Machine implementation.</li></ul></li></ul><ul><li>执行了<code>athrow</code>指令（§athrow）。</li><li>Java虚拟机同步检测到异常执行条件。这些异常不是在程序的任意点抛出的，而是仅在执行以下指令之后同步抛出的：<ul><li>指定异常作为可能的结果，例如：<ul><li>当指令体现了违反Java编程语言语义的操作时，例如索引超出数组的边界。</li><li>当加载或链接程序的某部分时发生错误。</li></ul></li><li>导致超出资源限制，例如使用了过多的内存。</li></ul></li><li>因以下原因发生异步异常：<ul><li>调用了<code>Thread</code>或<code>ThreadGroup</code>类的<code>stop</code>方法，或</li><li>Java虚拟机实现中发生内部错误。</li></ul></li></ul><p>The stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group. They are asynchronous because they may occur at any point in the execution of the other thread or threads. An internal error is considered asynchronous (§6.3).</p><p><code>stop</code>方法可以由一个线程调用，以影响另一个线程或指定线程组中的所有线程。它们是异步的，因为它们可能在其他线程或线程的执行过程中的任何点发生。内部错误被认为是异步的（§6.3）。</p><p>A Java Virtual Machine may permit a small but bounded amount of execution to occur before an asynchronous exception is thrown. This delay is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language.</p><p>Java虚拟机可能允许在抛出异步异常之前进行少量但有限的执行。这种延迟被允许，以便优化代码可以在实践中处理这些异常的点检测并抛出这些异常，同时遵守Java编程语言的语义。  </p><p>A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper “Polling Efficiently on Stock Hardware” by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture, Copenhagen, Denmark, pp. 179–187, is recommended as further reading.</p><p>一个简单的实现可能会在每个控制转移指令点轮询异步异常。由于程序具有有限的大小，这为检测异步异常的总延迟提供了限制。由于在控制转移之间不会发生异步异常，代码生成器在控制转移之间重新排序计算以提高性能方面具有一定的灵活性。推荐阅读Marc Feeley的论文“Polling Efficiently on Stock Hardware”，该论文发表在1993年函数编程与计算机架构会议（Copenhagen, Denmark）上，第179-187页。</p><p>Exceptions thrown by the Java Virtual Machine are precise: when the transfer of control takes place, all effects of the instructions executed before the point from which the exception is thrown must appear to have taken place. No instructions that occur after the point from which the exception is thrown may appear to have been evaluated. If optimized code has speculatively executed some of the instructions which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.</p><p>Java虚拟机抛出的异常是精确的：当发生控制转移时，必须显示在抛出异常点之前执行的指令的所有效果。在抛出异常点之后发生的任何指令都不能被认为已执行。如果优化代码已经推测性地执行了异常发生点之后的一些指令，则该代码必须准备好隐藏这些推测执行，以免暴露在程序的用户可见状态中。</p><p>Each method in the Java Virtual Machine may be associated with zero or more exception handlers. An exception handler specifies the range of offsets into the Java Virtual Machine code implementing the method for which the exception handler is active, describes the type of exception that the exception handler is able to handle, and specifies the location of the code that is to handle that exception. An exception matches an exception handler if the offset of the instruction that caused the exception is in the range of offsets of the exception handler and the exception type is the same class as or a subclass of the class of exception that the exception handler handles. When an exception is thrown, the Java Virtual Machine searches for a matching exception handler in the current method. If a matching exception handler is found, the system branches to the exception handling code specified by the matched handler.</p><p>Java虚拟机中的每个方法可以与零个或多个异常处理程序关联。异常处理程序指定在Java虚拟机代码中实现该方法的偏移范围，该范围内异常处理程序处于活动状态，描述异常处理程序能够处理的异常类型，并指定处理该异常的代码位置。如果导致异常的指令的偏移量在异常处理程序的偏移范围内，并且异常类型与异常处理程序处理的异常类型相同或为其子类，则该异常与异常处理程序匹配。当抛出异常时，Java虚拟机会在当前方法中搜索匹配的异常处理程序。如果找到匹配的异常处理程序，系统将分支到由匹配的处理程序指定的异常处理代码。</p><p>If no such exception handler is found in the current method, the current method invocation completes abruptly (§2.6.5). On abrupt completion, the operand stack and local variables of the current method invocation are discarded, and its frame is popped, reinstating the frame of the invoking method. The exception is then rethrown in the context of the invoker’s frame and so on, continuing up the method invocation chain. If no suitable exception handler is found before the top of the method invocation chain is reached, the execution of the thread in which the exception was thrown is terminated.</p><p>如果在当前方法中未找到此类异常处理程序，则当前方法调用会异常完成（§2.6.5）。在异常完成时，当前方法调用的操作数堆栈和局部变量会被丢弃，其帧会被弹出，恢复调用方法的帧。然后在调用者的帧上下文中重新抛出异常，依此类推，继续沿着方法调用链查找。如果在到达方法调用链的顶部之前未找到合适的异常处理程序，则抛出异常的线程的执行将终止。</p><p>The order in which the exception handlers of a method are searched for a match is important. Within a class file, the exception handlers for each method are stored in a table (§4.7.3). At run time, when an exception is thrown, the Java Virtual Machine searches the exception handlers of the current method in the order that they appear in the corresponding exception handler table in the class file, starting from the beginning of that table.</p><p>搜索方法的异常处理程序以匹配顺序是很重要的。在类文件中，每个方法的异常处理程序都存储在一个表中（§4.7.3）。在运行时，当抛出异常时，Java虚拟机会按照它们在类文件中的相应异常处理程序表中的出现顺序搜索当前方法的异常处理程序，从该表的开头开始。</p><p>Note that the Java Virtual Machine does not enforce nesting of or any ordering of the exception table entries of a method. The exception handling semantics of the Java programming language are implemented only through cooperation with the compiler (§3.12). When class files are generated by some other means, the defined search procedure ensures that all Java Virtual Machine implementations will behave consistently.</p><p>请注意，Java虚拟机不强制执行方法的异常表条目的嵌套或任何顺序。Java编程语言的异常处理语义仅通过与编译器的协作来实现（§3.12）。当通过其他方式生成类文件时，定义的搜索过程确保所有Java虚拟机实现将一致地表现。</p><hr><h3 id="2-11-Instruction-Set-Summary（指令集总结）"><a href="#2-11-Instruction-Set-Summary（指令集总结）" class="headerlink" title="2.11 Instruction Set Summary（指令集总结）"></a>2.11 Instruction Set Summary（指令集总结）</h3><p>A Java Virtual Machine instruction consists of a one-byte opcode specifying the operation to be performed, followed by zero or more operands supplying arguments or data that are used by the operation. Many instructions have no operands and consist only of an opcode.</p><p>Java虚拟机指令由一个指定要执行的操作的单字节操作码组成，后跟零个或多个提供操作所用参数或数据的操作数。许多指令没有操作数，仅由操作码组成。</p><p>Ignoring exceptions, the inner loop of a Java Virtual Machine interpreter is effectively:</p><p>忽略异常，Java虚拟机解释器的内循环实际上是：</p><ul><li><p>atomically calculate pc and fetch opcode at pc;</p><p>原子地计算pc值，并获取pc指向指令的操作码；</p></li><li><p>if (operands) fetch operands;</p><p>如果有操作数，则获取操作数；</p></li><li><p>execute the action for the opcode;</p><p>执行操作码对应的操作；</p></li><li><p>while (there is more to do);</p><p>当有更多操作时继续循环；</p></li></ul><p>The number and size of the operands are determined by the opcode. If an operand is more than one byte in size, then it is stored in big-endian order - high-order byte first. For example, an unsigned 16-bit index into the local variables is stored as two unsigned bytes, byte1 and byte2, such that its value is (byte1 &lt;&lt; 8) | byte2.</p><p>操作数的数量和大小由操作码决定。如果操作数的大小超过一个字节，则按大端顺序存储——高位字节在前。例如，局部变量中的一个无符号16位索引存储为两个无符号字节，<code>byte1</code>和<code>byte2</code>，其值为<code>(byte1 &lt;&lt; 8) | byte2</code>。</p><p>The bytecode instruction stream is only single-byte aligned. The two exceptions are the lookupswitch and tableswitch instructions (§lookupswitch, §tableswitch), which are padded to force internal alignment of some of their operands on 4-byte boundaries.</p><p>字节码指令流仅单字节对齐。两个例外是<code>lookupswitch</code>和<code>tableswitch</code>指令（§lookupswitch，§tableswitch），它们通过填充来强制其某些操作数在4字节边界上对齐。</p><p>The decision to limit the Java Virtual Machine opcode to a byte and to forgo data alignment within compiled code reflects a conscious bias in favor of compactness, possibly at the cost of some performance in naive implementations. A one-byte opcode also limits the size of the instruction set. Not assuming data alignment means that immediate data larger than a byte must be constructed from bytes at run time on many machines.</p><p>将Java虚拟机操作码限制为一个字节并放弃在编译代码中对数据进行对齐的决定反映了一种有意识的偏向，即偏向于紧凑性，可能以在简单实现中牺牲一些性能为代价。一个字节的操作码也限制了指令集的大小。不假设数据对齐意味着在许多机器上，大小超过一个字节的立即数必须在运行时由字节构建。</p><h3 id="2-11-1-Types-and-the-Java-Virtual-Machine（指令类型和JVM）"><a href="#2-11-1-Types-and-the-Java-Virtual-Machine（指令类型和JVM）" class="headerlink" title="2.11.1 Types and the Java Virtual Machine（指令类型和JVM）"></a>2.11.1 Types and the Java Virtual Machine（指令类型和JVM）</h3><p>Most of the instructions in the Java Virtual Machine instruction set encode type information about the operations they perform. For instance, the iload instruction (§iload) loads the contents of a local variable, which must be an int, onto the operand stack. The fload instruction (§fload) does the same with a float value. The two instructions may have identical implementations, but have distinct opcodes.</p><p>Java虚拟机指令集中大多数指令都会对它们执行的操作编码类型信息。例如，<code>iload</code>指令（§iload）将一个局部变量的内容加载到操作数堆栈上，该局部变量必须是<code>int</code>类型的。<code>fload</code>指令（§fload）对<code>float</code>值执行相同的操作。这两条指令可能具有相同的实现，但具有不同的操作码。</p><p>For the majority of typed instructions, the instruction type is represented explicitly in the opcode mnemonic by a letter: i for an int operation, l for long, s for short, b for byte, c for char, f for float, d for double, and a for reference. Some instructions for which the type is unambiguous do not have a type letter in their mnemonic. For instance, arraylength always operates on an object that is an array. Some instructions, such as goto, an unconditional control transfer, do not operate on typed operands.</p><p>对于大多数类型指令，指令类型在操作码助记符中由一个字母显式表示：<code>i</code>表示<code>int</code>操作，<code>l</code>表示<code>long</code>，<code>s</code>表示<code>short</code>，<code>b</code>表示<code>byte</code>，<code>c</code>表示<code>char</code>，<code>f</code>表示<code>float</code>，<code>d</code>表示<code>double</code>，<code>a</code>表示<code>reference</code>。对于类型明确的某些指令，其助记符中没有类型字母。例如，<code>arraylength</code>始终对一个对象（数组）操作。某些指令，如<code>goto</code>（无条件控制转移），不对类型化的操作数操作。</p><p>Given the Java Virtual Machine’s one-byte opcode size, encoding types into opcodes places pressure on the design of its instruction set. If each typed instruction supported all of the Java Virtual Machine’s run-time data types, there would be more instructions than could be represented in a byte. Instead, the instruction set of the Java Virtual Machine provides a reduced level of type support for certain operations. In other words, the instruction set is intentionally not orthogonal. Separate instructions can be used to convert between unsupported and supported data types as necessary.</p><p>考虑到Java虚拟机的单字节操作码大小，将类型编码到操作码中对其指令集的设计造成了压力。如果每种类型化的指令都支持Java虚拟机的所有运行时数据类型，那么指令数量将超过一个字节所能表示的数量。因此，Java虚拟机的指令集为某些操作提供了较少的类型支持。换句话说，指令集有意不是正交的。可以根据需要使用单独的指令在不支持和支持的数据类型之间进行转换。</p><p>Table 2.11.1-A summarizes the type support in the instruction set of the Java Virtual Machine. A specific instruction, with type information, is built by replacing the T in the instruction template in the opcode column by the letter in the type column. If the type column for some instruction template and type is blank, then no instruction exists supporting that type of operation. For instance, there is a load instruction for type int, iload, but there is no load instruction for type byte.</p><p>表2.11.1-A总结了Java虚拟机指令集中的类型支持。通过将操作码列中的指令模板中的<code>T</code>替换为类型列中的字母，可以构建特定的带有类型信息的指令。如果某个指令模板和类型的类型列为空，则不存在支持该类型操作的指令。例如，有一个用于<code>int</code>类型的加载指令<code>iload</code>，但没有用于<code>byte</code>类型的加载指令。</p><p>Note that most instructions in Table 2.11.1-A do not have forms for the integral types byte, char, and short. None have forms for the boolean type. A compiler encodes loads of literal values of types byte and short using Java Virtual Machine instructions that sign-extend those values to values of type int at compile-time or run-time. Loads of literal values of types boolean and char are encoded using instructions that zero-extend the literal to a value of type int at compile-time or run-time. Likewise, loads from arrays of values of type boolean, byte, short, and char are encoded using Java Virtual Machine instructions that sign-extend or zero-extend the values to values of type int. Thus, most operations on values of actual types boolean, byte, char, and short are correctly performed by instructions operating on values of computational type int.</p><p>请注意，表2.11.1-A中的大多数指令都没有针对整型类型<code>byte</code>、<code>char</code>和<code>short</code>的形式。没有任何指令具有<code>boolean</code>类型的形式。编译器使用Java虚拟机指令对<code>byte</code>和<code>short</code>类型的字面值加载进行编码，这些指令在编译时或运行时将这些值符号扩展为<code>int</code>类型的值。对<code>boolean</code>和<code>char</code>类型的字面值加载进行编码的指令在编译时或运行时将这些字面值零扩展为<code>int</code>类型的值。同样，从<code>boolean</code>、<code>byte</code>、<code>short</code>和<code>char</code>类型的值数组加载值的操作使用Java虚拟机指令进行编码，这些指令将值符号扩展或零扩展为<code>int</code>类型的值。因此，实际上大多数对<code>boolean</code>、<code>byte</code>、<code>char</code>和<code>short</code>类型值的操作都通过对计算类型为<code>int</code>的值进行操作的指令正确执行。</p><p><strong>Table 2.11.1-A. Type support in the Java Virtual Machine instruction set</strong></p><table><thead><tr><th>opcode</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th><th>char</th><th>reference</th></tr></thead><tbody><tr><td>Tipush</td><td>bipush</td><td>sipush</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Tconst</td><td></td><td></td><td>iconst</td><td>lconst</td><td>fconst</td><td>dconst</td><td></td><td>aconst</td></tr><tr><td>Tload</td><td></td><td></td><td>iload</td><td>lload</td><td>fload</td><td>dload</td><td></td><td>aload</td></tr><tr><td>Tstore</td><td></td><td></td><td>istore</td><td>lstore</td><td>fstore</td><td>dstore</td><td></td><td>astore</td></tr><tr><td>Tinc</td><td></td><td></td><td>iinc</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Taload</td><td>baload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>caload</td><td>aaload</td></tr><tr><td>Tastore</td><td>bastore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>castore</td><td>aastore</td></tr><tr><td>Tadd</td><td></td><td></td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td><td></td><td></td></tr><tr><td>Tsub</td><td></td><td></td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td><td></td><td></td></tr><tr><td>Tmul</td><td></td><td></td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td><td></td><td></td></tr><tr><td>Tdiv</td><td></td><td></td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td><td></td><td></td></tr><tr><td>Trem</td><td></td><td></td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td><td></td><td></td></tr><tr><td>Tneg</td><td></td><td></td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td><td></td><td></td></tr><tr><td>Tshl</td><td></td><td></td><td>ishl</td><td>lshl</td><td></td><td></td><td></td><td></td></tr><tr><td>Tshr</td><td></td><td></td><td>ishr</td><td>lshr</td><td></td><td></td><td></td><td></td></tr><tr><td>Tushr</td><td></td><td></td><td>iushr</td><td>lushr</td><td></td><td></td><td></td><td></td></tr><tr><td>Tand</td><td></td><td></td><td>iand</td><td>land</td><td></td><td></td><td></td><td></td></tr><tr><td>Tor</td><td></td><td></td><td>ior</td><td>lor</td><td></td><td></td><td></td><td></td></tr><tr><td>Txor</td><td></td><td></td><td>ixor</td><td>lxor</td><td></td><td></td><td></td><td></td></tr><tr><td>i2T</td><td>i2b</td><td>i2s</td><td>i2l</td><td>i2f</td><td>i2d</td><td></td><td></td><td></td></tr><tr><td>l2T</td><td></td><td></td><td>l2i</td><td>l2f</td><td>l2d</td><td></td><td></td><td></td></tr><tr><td>f2T</td><td></td><td></td><td>f2i</td><td>f2l</td><td>f2d</td><td></td><td></td><td></td></tr><tr><td>d2T</td><td></td><td></td><td>d2i</td><td>d2l</td><td>d2f</td><td></td><td></td><td></td></tr><tr><td>Tcmp</td><td></td><td></td><td>lcmp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Tcmpl</td><td></td><td></td><td></td><td></td><td>fcmpl</td><td>dcmpl</td><td></td><td></td></tr><tr><td>Tcmpg</td><td></td><td></td><td></td><td></td><td>fcmpg</td><td>dcmpg</td><td></td><td></td></tr><tr><td>if_TcmpOP</td><td></td><td></td><td>if_icmpOP</td><td></td><td></td><td></td><td></td><td>if_acmpOP</td></tr><tr><td>Treturn</td><td></td><td></td><td>ireturn</td><td>lreturn</td><td>freturn</td><td>dreturn</td><td></td><td>areturn</td></tr></tbody></table><p>The mapping between Java Virtual Machine actual types and Java Virtual Machine computational types is summarized by Table 2.11.1-B.</p><p>Java虚拟机实际类型和Java虚拟机计算类型之间的映射总结在表2.11.1-B中。</p><p>Certain Java Virtual Machine instructions such as pop and swap operate on the operand stack without regard to type; however, such instructions are constrained to use only on values of certain categories of computational types, also given in Table 2.11.1-B.</p><p>某些Java虚拟机指令（如<code>pop</code>和<code>swap</code>）在操作数堆栈上操作时不考虑类型；然而，这些指令仅限于在某些类别的计算类型值上使用，这些类别也在表2.11.1-B中给出。</p><p><strong>Table 2.11.1-B. Actual and Computational types in the Java Virtual Machine</strong></p><table><thead><tr><th>Actual type</th><th>Computational type</th><th>Category</th></tr></thead><tbody><tr><td>boolean</td><td>int</td><td>1</td></tr><tr><td>byte</td><td>int</td><td>1</td></tr><tr><td>char</td><td>int</td><td>1</td></tr><tr><td>short</td><td>int</td><td>1</td></tr><tr><td>int</td><td>int</td><td>1</td></tr><tr><td>float</td><td>float</td><td>1</td></tr><tr><td>reference</td><td>reference</td><td>1</td></tr><tr><td>returnAddress</td><td>returnAddress</td><td>1</td></tr><tr><td>long</td><td>long</td><td>2</td></tr><tr><td>double</td><td>double</td><td>2</td></tr></tbody></table><h3 id="2-11-2-Load-and-Store-Instructions（加载和存储指令）"><a href="#2-11-2-Load-and-Store-Instructions（加载和存储指令）" class="headerlink" title="2.11.2 Load and Store Instructions（加载和存储指令）"></a>2.11.2 Load and Store Instructions（加载和存储指令）</h3><p>The load and store instructions transfer values between the local variables (§2.6.1) and the operand stack (§2.6.2) of a Java Virtual Machine frame (§2.6):</p><p>加载和存储指令在Java虚拟机帧（§2.6）的局部变量（§2.6.1）和操作数堆栈（§2.6.2）之间传递值：</p><ul><li><p>Load a local variable onto the operand stack: iload, iload_&lt;n&gt;, lload, lload_&lt;n&gt;, fload, fload_&lt;n&gt;, dload, dload_&lt;n&gt;, aload, aload_&lt;n&gt;.</p><p>将局部变量加载到操作数堆栈：<code>iload</code>, <code>iload_&lt;n&gt;</code>，<code>lload</code>，<code>lload_&lt;n&gt;</code>，<code>fload</code>，<code>fload_&lt;n&gt;</code>，<code>dload</code>，<code>dload_&lt;n&gt;</code>，<code>aload</code>，<code>aload_&lt;n&gt;</code>。</p></li><li><p>Store a value from the operand stack into a local variable: istore, istore_&lt;n&gt;, lstore, lstore_&lt;n&gt;, fstore, fstore_&lt;n&gt;, dstore, dstore_&lt;n&gt;, astore, astore_&lt;n&gt;.</p><p>将值从操作数堆栈存储到局部变量：<code>istore</code>, <code>istore_&lt;n&gt;</code>，<code>lstore</code>，<code>lstore_&lt;n&gt;</code>，<code>fstore</code>，<code>fstore_&lt;n&gt;</code>，<code>dstore</code>，<code>dstore_&lt;n&gt;</code>，<code>astore</code>，<code>astore_&lt;n&gt;</code>。</p></li><li><p>Load a constant onto the operand stack: bipush, sipush, ldc, ldc_w, ldc2_w, aconst_null, iconst_m1, iconst_&lt;i&gt;, lconst_&lt;l&gt;, fconst_&lt;f&gt;, dconst_&lt;d&gt;.</p><p>将常量加载到操作数堆栈：<code>bipush</code>, <code>sipush</code>，<code>ldc</code>，<code>ldc_w</code>，<code>ldc2_w</code>，<code>aconst_null</code>，<code>iconst_m1</code>，<code>iconst_&lt;i&gt;</code>，<code>lconst_&lt;l&gt;</code>，<code>fconst_&lt;f&gt;</code>，<code>dconst_&lt;d&gt;</code>。</p></li><li><p>Gain access to more local variables using a wider index, or to a larger immediate operand: wide.</p><p>使用更宽的索引或更大的立即操作数访问更多局部变量：<code>wide</code>。</p></li></ul><p>Instructions that access fields of objects and elements of arrays (§2.11.5) also transfer data to and from the operand stack.</p><p>访问对象字段和数组元素的指令（§2.11.5）也在操作数堆栈中传输数据。</p><p>Instruction mnemonics shown above with trailing letters between angle brackets (for instance, iload_&lt;n&gt;) denote families of instructions (with members iload_0, iload_1, iload_2, and iload_3 in the case of iload_&lt;n&gt;). Such families of instructions are specializations of an additional generic instruction (iload) that takes one operand. For the specialized instructions, the operand is implicit and does not need to be stored or fetched. The semantics are otherwise the same (iload_0 means the same thing as iload with the operand 0). The letter between the angle brackets specifies the type of the implicit operand for that family of instructions: for &lt;n&gt;, a nonnegative integer; for &lt;i&gt;, an int; for &lt;l&gt;, a long; for &lt;f&gt;, a float; and for &lt;d&gt;, a double. Forms for type int are used in many cases to perform operations on values of type byte, char, and short (§2.11.1).</p><p>上面显示的带有尖括号之间尾随字母的指令助记符（例如<code>iload_&lt;n&gt;</code>）表示指令系列（例如<code>iload_&lt;n&gt;</code>的成员包括<code>iload_0</code>，<code>iload_1</code>，<code>iload_2</code>和<code>iload_3</code>）。这些指令系列是一个额外通用指令（<code>iload</code>）的特化形式，该指令需要一个操作数。对于特化的指令，操作数是隐式的，不需要存储或获取。语义相同（<code>iload_0</code>与操作数为0的<code>iload</code>具有相同的含义）。尖括号之间的字母指定了该指令系列的隐式操作数的类型：<code>&lt;n&gt;</code>表示非负整数，<code>&lt;i&gt;</code>表示<code>int</code>，<code>&lt;l&gt;</code>表示<code>long</code>，<code>&lt;f&gt;</code>表示<code>float</code>，<code>&lt;d&gt;</code>表示<code>double</code>。在许多情况下，<code>int</code>类型的形式用于对<code>byte</code>、<code>char</code>和<code>short</code>类型的值执行操作（§2.11.1）。</p><p>This notation for instruction families is used throughout this specification.</p><p>指令系列的这种表示法在整个规范中使用。</p><h3 id="2-11-3-Arithmetic-Instructions（算术指令）"><a href="#2-11-3-Arithmetic-Instructions（算术指令）" class="headerlink" title="2.11.3 Arithmetic Instructions（算术指令）"></a>2.11.3 Arithmetic Instructions（算术指令）</h3><p>The arithmetic instructions compute a result that is typically a function of two values on the operand stack, pushing the result back on the operand stack. There are two main kinds of arithmetic instructions: those operating on integer values and those operating on floating-point values.</p><p>算术指令计算的结果通常是操作数堆栈上两个值的函数，并将结果推回操作数堆栈。算术指令主要有两种：一种是对整数值进行操作的指令，另一种是对浮点数值进行操作的指令。</p><p>Within each of these kinds, the arithmetic instructions are specialized to Java Virtual Machine numeric types. There is no direct support for integer arithmetic on values of the byte, short, and char types (§2.11.1), or for values of the boolean type; those operations are handled by instructions operating on type int.</p><p>在这两种类型中，算术指令专门用于Java虚拟机的数值类型。对于<code>byte</code>、<code>short</code>和<code>char</code>类型的整数运算（§2.11.1）或<code>boolean</code>类型的值没有直接支持；这些操作由<code>int</code>类型操作的指令处理。</p><p>Integer and floating-point instructions also differ in their behavior on overflow and divide-by-zero.</p><p>整数和浮点数指令在溢出和除零操作上的行为也有所不同。</p><p>The arithmetic instructions are as follows:</p><p>算术指令如下：</p><ul><li><p>Add: iadd, ladd, fadd, dadd.</p><p>加法：<code>iadd</code>，<code>ladd</code>，<code>fadd</code>，<code>dadd</code>。</p></li><li><p>Subtract: isub, lsub, fsub, dsub.</p><p>减法：<code>isub</code>，<code>lsub</code>，<code>fsub</code>，<code>dsub</code>。</p></li><li><p>Multiply: imul, lmul, fmul, dmul.</p><p>乘法：<code>imul</code>，<code>lmul</code>，<code>fmul</code>，<code>dmul</code>。</p></li><li><p>Divide: idiv, ldiv, fdiv, ddiv.</p><p>除法：<code>idiv</code>，<code>ldiv</code>，<code>fdiv</code>，<code>ddiv</code>。</p></li><li><p>Remainder: irem, lrem, frem, drem.</p><p>取余：<code>irem</code>，<code>lrem</code>，<code>frem</code>，<code>drem</code>。</p></li><li><p>Negate: ineg, lneg, fneg, dneg.</p><p>取反：<code>ineg</code>，<code>lneg</code>，<code>fneg</code>，<code>dneg</code>。</p></li><li><p>Shift: ishl, ishr, iushr, lshl, lshr, lushr.</p><p>移位：<code>ishl</code>，<code>ishr</code>，<code>iushr</code>，<code>lshl</code>，<code>lshr</code>，<code>lushr</code>。</p></li><li><p>Bitwise OR: ior, lor.</p><p>按位或：<code>ior</code>，<code>lor</code>。</p></li><li><p>Bitwise AND: iand, land.</p><p>按位与：<code>iand</code>，<code>land</code>。</p></li><li><p>Bitwise exclusive OR: ixor, lxor.</p><p>按位异或：<code>ixor</code>，<code>lxor</code>。</p></li><li><p>Local variable increment: iinc.</p><p>局部变量增量：<code>iinc</code>。</p></li><li><p>Comparison: dcmpg, dcmpl, fcmpg, fcmpl, lcmp.</p><p>比较：<code>dcmpg</code>，<code>dcmpl</code>，<code>fcmpg</code>，<code>fcmpl</code>，<code>lcmp</code>。</p></li></ul><p>The semantics of the Java programming language operators on integer and floating-point values (JLS §4.2.2, JLS §4.2.4) are directly supported by the semantics of the Java Virtual Machine instruction set.</p><p>Java编程语言在整数和浮点数值上的操作符语义（JLS §4.2.2，JLS §4.2.4）由Java虚拟机指令集的语义直接支持。</p><p>The Java Virtual Machine does not indicate overflow during operations on integer data types. The only integer operations that can throw an exception are the integer divide instructions (idiv and ldiv) and the integer remainder instructions (irem and lrem), which throw an ArithmeticException if the divisor is zero.</p><p>Java虚拟机在整数数据类型的操作期间不指示溢出。唯一可能抛出异常的整数操作是整数除法指令（<code>idiv</code>和<code>ldiv</code>）以及整数取余指令（<code>irem</code>和<code>lrem</code>），如果除数为零，它们会抛出<code>ArithmeticException</code>。</p><p>Java Virtual Machine operations on floating-point numbers behave as specified in IEEE 754. In particular, the Java Virtual Machine requires full support of IEEE 754 denormalized floating-point numbers and gradual underflow, which make it easier to prove desirable properties of particular numerical algorithms.</p><p>Java虚拟机在浮点数上的操作行为如IEEE 754所规定的那样。特别是，Java虚拟机要求完全支持IEEE 754的非标准化浮点数和逐渐下溢，这使得证明特定数值算法的理想属性更加容易。</p><p>The Java Virtual Machine requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. Inexact results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one having a least significant bit of zero is chosen. This is the IEEE 754 standard’s default rounding mode, known as round to nearest mode.</p><p>Java虚拟机要求浮点数运算的行为就像每个浮点运算符将其浮点结果舍入到结果精度一样。不精确的结果必须舍入到最接近无限精确结果的可表示值；如果两个最接近的可表示值一样近，则选择最不重要位为零的值。这是IEEE 754标准的默认舍入模式，称为舍入到最近模式。</p><p>The Java Virtual Machine uses the IEEE 754 round towards zero mode when converting a floating-point value to an integer. This results in the number being truncated; any bits of the significand that represent the fractional part of the operand value are discarded. Round towards zero mode chooses as its result the type’s value closest to, but no greater in magnitude than, the infinitely precise result.</p><p>Java虚拟机在将浮点值转换为整数时使用IEEE 754的朝零舍入模式。这导致数字被截断；表示操作数值的小数部分的有效位被丢弃。朝零舍入模式选择其结果为最接近但不大于无限精确结果的类型值。</p><p>The Java Virtual Machine’s floating-point operators do not throw run-time exceptions (not to be confused with IEEE 754 floating-point exceptions).</p><p>Java虚拟机的浮点运算符不会抛出运行时异常（不要与IEEE 754的浮点异常混淆）。</p><p>An operation that overflows produces a signed infinity, an operation that underflows produces a denormalized value or a signed zero, and an operation that has no mathematically definite result produces NaN. All numeric operations with NaN as an operand produce NaN as a result.</p><p>溢出操作产生一个有符号无穷大，下溢操作产生一个非标准化值或有符号零，而没有数学上确定结果的操作会产生NaN。所有以NaN为操作数的数值操作都会产生NaN结果。</p><p>Comparisons on values of type long (lcmp) perform a signed comparison. Comparisons on values of floating-point types (dcmpg, dcmpl, fcmpg, fcmpl) are performed using IEEE 754 nonsignaling comparisons.</p><p>对<code>long</code>类型值的比较（<code>lcmp</code>）执行有符号比较。对浮点数类型值的比较（<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>）使用IEEE 754非信号比较执行。</p><h3 id="2-11-4-Type-Conversion-Instructions（类型转换指令）"><a href="#2-11-4-Type-Conversion-Instructions（类型转换指令）" class="headerlink" title="2.11.4 Type Conversion Instructions（类型转换指令）"></a>2.11.4 Type Conversion Instructions（类型转换指令）</h3><p>The type conversion instructions allow conversion between Java Virtual Machine numeric types. These may be used to implement explicit conversions in user code or to mitigate the lack of orthogonality in the instruction set of the Java Virtual Machine.</p><p>类型转换指令允许在Java虚拟机数值类型之间进行转换。这些指令可以用于在用户代码中实现显式转换，或者缓解Java虚拟机指令集中正交性不足的问题。</p><p>The Java Virtual Machine directly supports the following widening numeric conversions:  </p><p>Java虚拟机直接支持以下数值扩展转换：</p><ul><li><p>int to long, float, or double</p><p><code>int</code>到<code>long</code>、<code>float</code>或<code>double</code></p></li><li><p>long to float or double</p><p><code>long</code>到<code>float</code>或<code>double</code></p></li><li><p>float to double</p><p><code>float</code>到<code>double</code></p></li></ul><p>The widening numeric conversion instructions are i2l, i2f, i2d, l2f, l2d, and f2d. The mnemonics for these opcodes are straightforward given the naming conventions for typed instructions and the punning use of 2 to mean “to.” For instance, the i2d instruction converts an int value to a double.</p><p>数值扩展转换指令包括<code>i2l</code>、<code>i2f</code>、<code>i2d</code>、<code>l2f</code>、<code>l2d</code>和<code>f2d</code>。这些操作码的助记符是直接的，考虑到类型化指令的命名约定和使用<code>2</code>来表示“到”的双关语。例如，<code>i2d</code>指令将<code>int</code>值转换为<code>double</code>。</p><p>Most widening numeric conversions do not lose information about the overall magnitude of a numeric value. Indeed, conversions widening from int to long and int to double do not lose any information at all; the numeric value is preserved exactly. Conversions widening from float to double that are FP-strict (§2.8.2) also preserve the numeric value exactly; only such conversions that are not FP-strict may lose information about the overall magnitude of the converted value.</p><p>大多数数值扩展转换不会丢失关于数值整体幅度的信息。实际上，从<code>int</code>到<code>long</code>和<code>int</code>到<code>double</code>的扩展转换根本不会丢失任何信息；数值完全保留。从<code>float</code>到<code>double</code>的<code>FP-strict</code>转换（§2.8.2）也完全保留数值；只有非<code>FP-strict</code>的此类转换可能会丢失关于转换值整体幅度的信息。</p><p>Conversions from int to float, or from long to float, or from long to double, may lose precision, that is, may lose some of the least significant bits of the value; the resulting floating-point value is a correctly rounded version of the integer value, using IEEE 754 round to nearest mode.</p><p>从<code>int</code>到<code>float</code>，或从<code>long</code>到<code>float</code>，或从<code>long</code>到<code>double</code>的转换可能会丢失精度，即可能会丢失值的某些最低有效位；生成的浮点值是整数值的正确舍入版本，使用IEEE 754的舍入到最近模式。</p><p>Despite the fact that loss of precision may occur, widening numeric conversions never cause the Java Virtual Machine to throw a run-time exception (not to be confused with an IEEE 754 floating-point exception).</p><p>尽管可能会发生精度丧失，但数值扩展转换从不会导致Java虚拟机抛出运行时异常（不要与IEEE 754的浮点异常混淆）。</p><p>A widening numeric conversion of an int to a long simply sign-extends the two’s-complement representation of the int value to fill the wider format. A widening numeric conversion of a char to an integral type zero-extends the representation of the char value to fill the wider format.</p><p>将<code>int</code>扩展为<code>long</code>的数值扩展转换仅将<code>int</code>值的二进制补码表示符号扩展以填充更宽的格式。将<code>char</code>扩展为整型的数值扩展转换通过零扩展<code>char</code>值的表示来填充更宽的格式。</p><p>Note that widening numeric conversions do not exist from integral types byte, char, and short to type int. As noted in §2.11.1, values of type byte, char, and short are internally widened to type int, making these conversions implicit.</p><p>请注意，没有从整型类型<code>byte</code>、<code>char</code>和<code>short</code>到<code>int</code>类型的数值扩展转换。如§2.11.1中所述，<code>byte</code>、<code>char</code>和<code>short</code>类型的值在内部扩展为<code>int</code>类型，使得这些转换是隐式的。</p><p>The Java Virtual Machine also directly supports the following narrowing numeric conversions:</p><p>Java虚拟机还直接支持以下数值缩减转换：</p><ul><li><p>int to byte, short, or char</p><p><code>int</code>到<code>byte</code>、<code>short</code>或<code>char</code></p></li><li><p>long to int</p><p><code>long</code>到<code>int</code></p></li><li><p>float to int or long</p><p><code>float</code>到<code>int</code>或<code>long</code></p></li><li><p>double to int, long, or float</p><p><code>double</code>到<code>int</code>、<code>long</code>或<code>float</code></p></li></ul><p>The narrowing numeric conversion instructions are i2b, i2c, i2s, l2i, f2i, f2l, d2i, d2l, and d2f. A narrowing numeric conversion can result in a value of different sign, a different order of magnitude, or both; it may thereby lose precision.</p><p>数值缩减转换指令包括<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>和<code>d2f</code>。数值缩减转换可能导致符号、数量级或两者都不同的值；因此它可能会丢失精度。</p><p>A narrowing numeric conversion of an int or long to an integral type T simply discards all but the n lowest-order bits, where n is the number of bits used to represent type T. This may cause the resulting value not to have the same sign as the input value.</p><p>将<code>int</code>或<code>long</code>缩减为整型<code>T</code>的数值缩减转换仅丢弃所有除n个最低位之外的位，其中n是表示<code>T</code>类型所用的位数。这可能会导致生成的值与输入值的符号不同。</p><p>In a narrowing numeric conversion of a floating-point value to an integral type T, where T is either int or long, the floating-point value is converted as follows:</p><p>在将浮点值缩减为整型<code>T</code>的数值缩减转换中，其中<code>T</code>可以是<code>int</code>或<code>long</code>，浮点值的转换如下：</p><ul><li><p>If the floating-point value is NaN, the result of the conversion is an int or long 0.</p><p>如果浮点值为NaN，则转换的结果是<code>int</code>或<code>long</code>的0。</p></li><li><p>Otherwise, if the floating-point value is not an infinity, the floating-point value is rounded to an integer value V using IEEE 754 round towards zero mode. There are two cases:</p><p>否则，如果浮点值不是无穷大，则使用IEEE 754的朝零舍入模式将浮点值舍入为整数值V。有两种情况：</p><ul><li><p>If T is long and this integer value can be represented as a long, then the result is the long value V.</p><p>  如果<code>T</code>是<code>long</code>，并且该整数值可以表示为<code>long</code>，则结果是<code>long</code>值V。</p></li><li><p>If T is of type int and this integer value can be represented as an int, then the result is the int value V.</p><p>  如果<code>T</code>是<code>int</code>，并且该整数值可以表示为<code>int</code>，则结果是<code>int</code>值V。</p></li></ul></li><li><p>Otherwise:</p><p>否则：</p><ul><li><p>Either the value must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int or long.</p><p>  值必须太小（大幅度负值或负无穷大），结果是<code>int</code>或<code>long</code>类型的最小可表示值。</p></li><li><p>Or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int or long.</p><p>  值必须太大（大幅度正值或正无穷大），结果是<code>int</code>或<code>long</code>类型的最大可表示值。</p></li></ul></li></ul><p>A narrowing numeric conversion from double to float behaves in accordance with IEEE 754. The result is correctly rounded using IEEE 754 round to nearest mode. A value too small to be represented as a float is converted to a positive or negative zero of type float; a value too large to be represented as a float is converted to a positive or negative infinity. A double NaN is always converted to a float NaN.</p><p>将<code>double</code>缩减为<code>float</code>的数值缩减转换按照IEEE 754标准进行。结果使用IEEE 754的舍入到最近模式进行正确舍入。一个太小而不能表示为<code>float</code>的值将转换为<code>float</code>类型的正零或负零；一个太大而不能表示为<code>float</code>的值将转换为正无穷大或负无穷大。<code>double</code>的NaN始终转换为<code>float</code>的NaN。</p><p>Despite the fact that overflow, underflow, or loss of precision may occur, narrowing conversions among numeric types never cause the Java Virtual Machine to throw a run-time exception (not to be confused with an IEEE 754 floating-point exception).</p><p>尽管可能会发生溢出、下溢或精度丧失，但数值类型之间的缩减转换从不会导致Java虚拟机抛出运行时异常（不要与IEEE 754的浮点异常混淆）。</p><h3 id="2-11-5-Object-Creation-and-Manipulation（对象创建和操作指令）"><a href="#2-11-5-Object-Creation-and-Manipulation（对象创建和操作指令）" class="headerlink" title="2.11.5 Object Creation and Manipulation（对象创建和操作指令）"></a>2.11.5 Object Creation and Manipulation（对象创建和操作指令）</h3><p>Although both class instances and arrays are objects, the Java Virtual Machine creates and manipulates class instances and arrays using distinct sets of instructions:</p><p>虽然类实例和数组都是对象，但Java虚拟机使用不同的指令集来创建和操作类实例和数组：</p><ul><li><p>Create a new class instance: new.</p><p>创建一个新的类实例：<code>new</code>。</p></li><li><p>Create a new array: newarray, anewarray, multianewarray.</p><p>创建一个新的数组：<code>newarray</code>、<code>anewarray</code>、<code>multianewarray</code>。</p></li><li><p>Access fields of classes (static fields, known as class variables) and fields of class instances (non-static fields, known as instance variables): getstatic, putstatic, getfield, putfield.</p><p>访问类的字段（静态字段，称为类变量）和类实例的字段（非静态字段，称为实例变量）：<code>getstatic</code>、<code>putstatic</code>、<code>getfield</code>、<code>putfield</code>。</p></li><li><p>Load an array component onto the operand stack: baload, caload, saload, iaload, laload, faload, daload, aaload.</p><p>将数组组件加载到操作数堆栈：<code>baload</code>、<code>caload</code>、<code>saload</code>、<code>iaload</code>、<code>laload</code>、<code>faload</code>、<code>daload</code>、<code>aaload</code>。</p></li><li><p>Store a value from the operand stack as an array component: bastore, castore, sastore, iastore, lastore, fastore, dastore, aastore.</p><p>将值从操作数堆栈存储为数组组件：<code>bastore</code>、<code>castore</code>、<code>sastore</code>、<code>iastore</code>、<code>lastore</code>、<code>fastore</code>、<code>dastore</code>、<code>aastore</code>。</p></li><li><p>Get the length of array: arraylength.</p><p>获取数组的长度：<code>arraylength</code>。</p></li><li><p>Check properties of class instances or arrays: instanceof, checkcast.</p><p>检查类实例或数组的属性：<code>instanceof</code>、<code>checkcast</code>。</p></li></ul><h3 id="2-11-6-Operand-Stack-Management-Instructions（操作数栈管理指令）"><a href="#2-11-6-Operand-Stack-Management-Instructions（操作数栈管理指令）" class="headerlink" title="2.11.6 Operand Stack Management Instructions（操作数栈管理指令）"></a>2.11.6 Operand Stack Management Instructions（操作数栈管理指令）</h3><p>A number of instructions are provided for the direct manipulation of the operand stack: pop, pop2, dup, dup2, dup_x1, dup2_x1, dup_x2, dup2_x2, swap.</p><p>提供了一些指令用于直接操作操作数栈：<code>pop</code>、<code>pop2</code>、<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup2_x1</code>、<code>dup_x2</code>、<code>dup2_x2</code>、<code>swap</code>。</p><h3 id="2-11-7-Control-Transfer-Instructions（控制转移指令）"><a href="#2-11-7-Control-Transfer-Instructions（控制转移指令）" class="headerlink" title="2.11.7 Control Transfer Instructions（控制转移指令）"></a>2.11.7 Control Transfer Instructions（控制转移指令）</h3><p>The control transfer instructions conditionally or unconditionally cause the Java Virtual Machine to continue execution with an instruction other than the one following the control transfer instruction. They are:</p><p>控制转移指令有条件或无条件地使Java虚拟机继续执行控制转移指令后面的指令。它们是：</p><ul><li><p>Conditional branch: ifeq, ifne, iflt, ifle, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmplt, if_icmple, if_icmpgt, if_icmpge, if_acmpeq, if_acmpne.</p><p>条件分支：<code>ifeq</code>、<code>ifne</code>、<code>iflt</code>、<code>ifle</code>、<code>ifgt</code>、<code>ifge</code>、<code>ifnull</code>、<code>ifnonnull</code>、<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmple</code>、<code>if_icmpgt</code>、<code>if_icmpge</code>、<code>if_acmpeq</code>、<code>if_acmpne</code>。</p></li><li><p>Compound conditional branch: tableswitch, lookupswitch.</p><p>复合条件分支：<code>tableswitch</code>、<code>lookupswitch</code>。</p></li><li><p>Unconditional branch: goto, goto_w, jsr, jsr_w, ret.</p><p>无条件分支：<code>goto</code>、<code>goto_w</code>、<code>jsr</code>、<code>jsr_w</code>、<code>ret</code>。</p></li></ul><p>The Java Virtual Machine has distinct sets of instructions that conditionally branch on comparison with data of int and reference types. It also has distinct conditional branch instructions that test for the null reference and thus it is not required to specify a concrete value for null (§2.4).</p><p>Java虚拟机有不同的指令集用于根据<code>int</code>和引用类型数据进行条件分支。它还有专门的条件分支指令用于测试空引用，因此不需要为<code>null</code>指定具体值（§2.4）。</p><p>Conditional branches on comparisons between data of types boolean, byte, char, and short are performed using int comparison instructions (§2.11.1). A conditional branch on a comparison between data of types long, float, or double is initiated using an instruction that compares the data and produces an int result of the comparison (§2.11.3). A subsequent int comparison instruction tests this result and effects the conditional branch. Because of its emphasis on int comparisons, the Java Virtual Machine provides a rich complement of conditional branch instructions for type int.</p><p>对于<code>boolean</code>、<code>byte</code>、<code>char</code>和<code>short</code>类型数据之间比较的条件分支使用<code>int</code>比较指令执行（§2.11.1）。对于<code>long</code>、<code>float</code>或<code>double</code>类型数据之间比较的条件分支使用比较数据并生成<code>int</code>比较结果的指令启动（§2.11.3）。后续的<code>int</code>比较指令测试此结果并执行条件分支。由于其对<code>int</code>比较的强调，Java虚拟机为<code>int</code>类型提供了丰富的条件分支指令。</p><p>All int conditional control transfer instructions perform signed comparisons.</p><p>所有<code>int</code>条件控制转移指令执行有符号比较。</p><h3 id="2-11-8-Method-Invocation-and-Return-Instructions（方法调用和返回指令）"><a href="#2-11-8-Method-Invocation-and-Return-Instructions（方法调用和返回指令）" class="headerlink" title="2.11.8 Method Invocation and Return Instructions（方法调用和返回指令）"></a>2.11.8 Method Invocation and Return Instructions（方法调用和返回指令）</h3><p>The following five instructions invoke methods:</p><p>以下五个指令用于调用方法：</p><ul><li><p>invokevirtual invokes an instance method of an object, dispatching on the (virtual) type of the object. This is the normal method dispatch in the Java programming language.  </p><p><code>invokevirtual</code>调用对象的实例方法，基于对象的（虚拟）类型进行分派。这是Java编程语言中的正常方法分派。  </p></li><li><p>invokeinterface invokes an interface method, searching the methods implemented by the particular run-time object to find the appropriate method.</p><p><code>invokeinterface</code>调用接口方法，搜索特定运行时对象实现的方法以找到合适的方法。</p></li><li><p>invokespecial invokes an instance method requiring special handling, whether an instance initialization method (§2.9), a private method, or a superclass method.</p><p><code>invokespecial</code>调用需要特殊处理的实例方法，无论是实例初始化方法（§2.9）、私有方法还是超类方法。</p></li><li><p>invokestatic invokes a class (static) method in a named class.</p><p><code>invokestatic</code>调用命名类中的类（静态）方法。</p></li><li><p>invokedynamic invokes the method which is the target of the call site object bound to the invokedynamic instruction. The call site object was bound to a specific lexical occurrence of the invokedynamic instruction by the Java Virtual Machine as a result of running a bootstrap method before the first execution of the instruction. Therefore, each occurrence of an invokedynamic instruction has a unique linkage state, unlike the other instructions which invoke methods.</p><p><code>invokedynamic</code>调用绑定到<code>invokedynamic</code>指令的调用站点对象的目标方法。调用站点对象是在指令首次执行之前，由Java虚拟机在运行引导方法时绑定到<code>invokedynamic</code>指令的特定词法出现。因此，每次出现<code>invokedynamic</code>指令时，都会具有唯一的链接状态，这与其他调用方法的指令不同。</p></li></ul><p>The method return instructions, which are distinguished by return type, are ireturn (used to return values of type boolean, byte, char, short, or int), lreturn, freturn, dreturn, and areturn. In addition, the return instruction is used to return from methods declared to be void, instance initialization methods, and class or interface initialization methods.</p><p>方法返回指令按返回类型区分为<code>ireturn</code>（用于返回<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>或<code>int</code>类型的值）、<code>lreturn</code>、<code>freturn</code>、<code>dreturn</code>和<code>areturn</code>。此外，<code>return</code>指令用于从声明为<code>void</code>的方法、实例初始化方法以及类或接口初始化方法中返回。</p><h3 id="2-11-9-Throwing-Exceptions（异常抛出指令）"><a href="#2-11-9-Throwing-Exceptions（异常抛出指令）" class="headerlink" title="2.11.9 Throwing Exceptions（异常抛出指令）"></a>2.11.9 Throwing Exceptions（异常抛出指令）</h3><p>An exception is thrown programmatically using the athrow instruction. Exceptions can also be thrown by various Java Virtual Machine instructions if they detect an abnormal condition.  </p><p>使用<code>athrow</code>指令以编程方式抛出异常。如果Java虚拟机的各种指令检测到异常情况，也会抛出异常。</p><h3 id="2-11-10-Synchronization（同步指令）"><a href="#2-11-10-Synchronization（同步指令）" class="headerlink" title="2.11.10 Synchronization（同步指令）"></a>2.11.10 Synchronization（同步指令）</h3><p>The Java Virtual Machine supports synchronization of both methods and sequences of instructions within a method by a single synchronization construct: the monitor.</p><p>Java虚拟机通过单一的同步结构——监视器（monitor），支持方法和方法内指令序列的同步。</p><p>Method-level synchronization is performed implicitly, as part of method invocation and return (§2.11.8). A synchronized method is distinguished in the run-time constant pool’s method_info structure (§4.6) by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.  </p><p>方法级别的同步隐式执行，作为方法调用和返回的一部分（§2.11.8）。同步方法在运行时常量池的<code>method_info</code>结构（§4.6）中由<code>ACC_SYNCHRONIZED</code>标志区分，方法调用指令检查该标志。当调用设置了<code>ACC_SYNCHRONIZED</code>的 方法时，执行线程进入一个监视器，调用方法本身，并在方法调用正常或突然完成时退出监视器。在执行线程拥有监视器期间，其他线程无法进入。如果在调用同步方法期间抛出异常并且同步方法未处理该异常，则在异常从同步方法重新抛出之前，自动退出该方法的监视器。</p><p>Synchronization of sequences of instructions is typically used to encode the synchronized block of the Java programming language. The Java Virtual Machine supplies the monitorenter and monitorexit instructions to support such language constructs. Proper implementation of synchronized blocks requires cooperation from a compiler targeting the Java Virtual Machine (§3.14).</p><p>指令序列的同步通常用于编码Java编程语言的同步块。Java虚拟机提供了<code>monitorenter</code>和<code>monitorexit</code>指令来支持这种语言结构。同步块的正确实现需要编译器与针对Java虚拟机的协作（§3.14）。</p><p>Structured locking is the situation when, during a method invocation, every exit on a given monitor matches a preceding entry on that monitor. Since there is no assurance that all code submitted to the Java Virtual Machine will perform structured locking, implementations of the Java Virtual Machine are permitted but not required to enforce both of the following two rules guaranteeing structured locking. Let T be a thread and M be a monitor. Then:</p><p>结构化锁定是指在方法调用期间，给定监视器上的每个退出都与之前在该监视器上的进入相匹配。由于无法保证提交给Java虚拟机的所有代码都会执行结构化锁定，因此Java虚拟机的实现可以但不必强制执行以下两条规则来保证结构化锁定。假设T为一个线程，M为一个监视器。那么：</p><ol><li><p>The number of monitor entries performed by T on M during a method invocation must equal the number of monitor exits performed by T on M during the method invocation whether the method invocation completes normally or abruptly.</p><p>在方法调用期间，线程T在监视器M上执行的进入次数必须等于线程T在监视器M上执行的退出次数，无论方法调用是正常完成还是突然完成。</p></li><li><p>At no point during a method invocation may the number of monitor exits performed by T on M since the method invocation exceed the number of monitor entries performed by T on M since the method invocation.</p><p>在方法调用期间的任何时候，线程T在监视器M上执行的退出次数都不得超过方法调用以来线程T在监视器M上执行的进入次数。</p></li></ol><p>Note that the monitor entry and exit automatically performed by the Java Virtual Machine when invoking a synchronized method are considered to occur during the calling method’s invocation.</p><p>请注意，Java虚拟机在调用同步方法时自动执行的监视器进入和退出被认为发生在调用方法的调用期间。</p><hr><h2 id="2-12-Class-Libraries（类库）"><a href="#2-12-Class-Libraries（类库）" class="headerlink" title="2.12 Class Libraries（类库）"></a>2.12 Class Libraries（类库）</h2><p>The Java Virtual Machine must provide sufficient support for the implementation of the class libraries of the Java SE platform. Some of the classes in these libraries cannot be implemented without the cooperation of the Java Virtual Machine.</p><p>Java虚拟机必须提供足够的支持来实现Java SE平台的类库。这些类库中的某些类在没有Java虚拟机的协作下无法实现。</p><p>Classes that might require special support from the Java Virtual Machine include those that support:</p><p>可能需要Java虚拟机特别支持的类包括以下支持的类：</p><ul><li><p>Reflection, such as the classes in the package java.lang.reflect and the class Class.</p><p>反射，例如<code>java.lang.reflect</code>包中的类和<code>Class</code>类。</p></li><li><p>Loading and creation of a class or interface. The most obvious example is the class ClassLoader.</p><p>类或接口的加载和创建。最明显的例子是<code>ClassLoader</code>类。</p></li><li><p>Linking and initialization of a class or interface. The example classes cited above fall into this category as well.</p><p>类或接口的链接和初始化。上面提到的示例类也属于此类别。</p></li><li><p>Security, such as the classes in the package java.security and other classes such as SecurityManager.</p><p>安全性，例如<code>java.security</code>包中的类和其他类如<code>SecurityManager</code>。</p></li><li><p>Multithreading, such as the class Thread.</p><p>多线程，例如<code>Thread</code>类。</p></li><li><p>Weak references, such as the classes in the package java.lang.ref.</p><p>弱引用，例如<code>java.lang.ref</code>包中的类。</p></li></ul><p>The list above is meant to be illustrative rather than comprehensive. An exhaustive list of these classes or of the functionality they provide is beyond the scope of this specification. See the specifications of the Java SE platform class libraries for details.</p><p>上面的列表是示例性的，而不是全面的。对这些类或它们提供的功能的详尽列表超出了本规范的范围。有关详细信息，请参见Java SE平台类库的规范。</p><hr><h2 id="2-13-Public-Design-Private-Implementation（公共设计和私有实现）"><a href="#2-13-Public-Design-Private-Implementation（公共设计和私有实现）" class="headerlink" title="2.13 Public Design, Private Implementation（公共设计和私有实现）"></a>2.13 Public Design, Private Implementation（公共设计和私有实现）</h2><p>Thus far this specification has sketched the public view of the Java Virtual Machine: the class file format and the instruction set. These components are vital to the hardware-, operating system-, and implementation-independence of the Java Virtual Machine. The implementor may prefer to think of them as a means to securely communicate fragments of programs between hosts each implementing the Java SE platform, rather than as a blueprint to be followed exactly.</p><p>到目前为止，本规范已勾勒出Java虚拟机的公共视图：类文件格式和指令集。这些组件对于Java虚拟机的硬件、操作系统和实现的独立性至关重要。实现者可能更愿意将它们视为在各自实现Java SE平台的主机之间安全传递程序片段的一种手段，而不是必须精确遵循的蓝图。</p><p>It is important to understand where the line between the public design and the private implementation lies. A Java Virtual Machine implementation must be able to read class files and must exactly implement the semantics of the Java Virtual Machine code therein. One way of doing this is to take this document as a specification and to implement that specification literally. But it is also perfectly feasible and desirable for the implementor to modify or optimize the implementation within the constraints of this specification. So long as the class file format can be read and the semantics of its code are maintained, the implementor may implement these semantics in any way. What is “under the hood” is the implementor’s business, as long as the correct external interface is carefully maintained.</p><p>理解公共设计与私有实现之间的界限至关重要。Java虚拟机的实现必须能够读取类文件，并且必须准确地实现其中的Java虚拟机代码的语义。一种实现方法是将本文档作为规范，并严格按照该规范实现。但是，在本规范的约束范围内，修改或优化实现也是完全可行和可取的。只要可以读取类文件格式并且保持其代码的语义，实施者可以以任何方式实现这些语义。只要正确维护外部接口，内部如何实现由实现者决定。</p><p>There are some exceptions: debuggers, profilers, and just-in-time code generators can each require access to elements of the Java Virtual Machine that are normally considered to be “under the hood.” Where appropriate, Oracle works with other Java Virtual Machine implementors and with tool vendors to develop common interfaces to the Java Virtual Machine for use by such tools, and to promote those interfaces across the industry.</p><p>有一些例外：调试器、分析器和即时代码生成器可能需要访问Java虚拟机的某些通常被认为是“内部实现”的元素。在适当的情况下，Oracle与其他Java虚拟机实现者和工具供应商合作，开发用于这些工具的Java虚拟机的通用接口，并在整个行业中推广这些接口。</p><p>The implementor can use this flexibility to tailor Java Virtual Machine implementations for high performance, low memory use, or portability. What makes sense in a given implementation depends on the goals of that implementation. The range of implementation options includes the following:</p><p>实现者可以利用这种灵活性来为高性能、低内存使用或可移植性定制Java虚拟机的实现。特定实现中有意义的内容取决于该实现的目标。实现选项的范围包括以下内容：</p><ul><li><p>Translating Java Virtual Machine code at load-time or during execution into the instruction set of another virtual machine.</p><p>在加载时或执行期间将Java虚拟机代码转换为另一种虚拟机的指令集。</p></li><li><p>Translating Java Virtual Machine code at load-time or during execution into the native instruction set of the host CPU (sometimes referred to as just-in-time, or JIT, code generation).</p><p>在加载时或执行期间将Java虚拟机代码转换为主机CPU的本机指令集（有时称为即时（JIT）代码生成）。</p></li></ul><p>The existence of a precisely defined virtual machine and object file format need not significantly restrict the creativity of the implementor. The Java Virtual Machine is designed to support many different implementations, providing new and interesting solutions while retaining compatibility between implementations.</p><p>精确定义的虚拟机和对象文件格式的存在并不需要显著限制实现者的创造力。Java虚拟机旨在支持多种不同的实现，提供新的和有趣的解决方案，同时保持实现之间的兼容性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 官方文档翻译 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-虚拟机性能监控、故障处理工具总结</title>
      <link href="/2022/08/20/jvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/20/jvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>工具</th><th>功能描述</th><th>常用选项&#x2F;命令</th></tr></thead><tbody><tr><td><code>jps</code></td><td>列出所有正在运行的 <code>JVM</code> 进程及其启动类名或 <code>JAR</code> 文件名。</td><td><code>-v</code> 显示传递给 <code>JVM</code> 的参数<br><code>-m</code> 显示传递给主类的参数</td></tr><tr><td><code>jstat</code></td><td>监控 <code>JVM</code> 性能统计信息，如垃圾回收、类加载等。</td><td><code>-gc</code> 查看垃圾回收统计信息<br><code>-class</code> 查看类加载信息</td></tr><tr><td><code>jmap</code></td><td>生成堆转储文件，查看堆内存的使用情况。</td><td><code>-dump</code> 生成堆转储<br><code>-heap</code> 查看堆内存摘要<br><code>-histo</code> 显示堆直方图</td></tr><tr><td><code>jstack</code></td><td>打印线程的堆栈跟踪信息，用于诊断线程问题。</td><td><code>-F</code> 强制输出线程堆栈跟踪<br><code>-l</code> 输出附加的锁信息</td></tr><tr><td><code>jinfo</code></td><td>查看和调整正在运行的 <code>JVM</code> 实例的配置信息。</td><td><code>-flags</code> 查看所有 <code>JVM</code> 标志<br><code>-sysprops</code> 查看系统属性</td></tr><tr><td><code>jcmd</code></td><td>综合性工具，用于执行各种 <code>JVM</code> 诊断命令。</td><td><code>VM.uptime</code> 查看 <code>JVM</code> 的运行时间<br><code>GC.run</code> 触发垃圾回收</td></tr><tr><td><code>jhat</code></td><td>用于分析 <code>jmap</code> 生成的堆转储文件的工具，提供一个 <code>Web</code> 界面。</td><td><code>jhat &lt;heap-dump-file&gt;</code> 启动分析堆转储文件</td></tr><tr><td><code>jdb</code></td><td><code>Java</code> 调试器，用于调试 <code>Java</code> 程序。</td><td><code>stop at</code> 在指定类的行设置断点<br><code>print</code> 打印变量值</td></tr><tr><td><code>jrunscript</code></td><td>运行脚本和执行命令行 <code>JavaScript</code> 程序。</td><td><code>-e</code> 执行命令<br><code>-f</code> 执行脚本文件</td></tr><tr><td><code>javap</code></td><td>反编译 <code>Java</code> 类文件，显示类的字节码和结构。</td><td><code>-c</code> 反汇编代码<br><code>-v</code> 显示详细的字节码信息</td></tr><tr><td><code>jconsole</code></td><td>基于 <code>GUI</code> 的工具，用于监控和管理 <code>JVM</code> 实例。</td><td>启动后选择目标 <code>JVM</code> 实例并查看各项性能指标</td></tr><tr><td><code>jvisualvm</code></td><td>综合性的 <code>GUI</code> 工具，用于分析、监控、故障排除和配置 <code>JVM</code> 应用。</td><td>启动后选择目标 <code>JVM</code> 实例并分析内存、<code>CPU</code> 使用情况等</td></tr><tr><td><code>jstatd</code></td><td>远程监控工具，用于提供 <code>jstat</code> 远程访问的支持。</td><td>启动守护进程以允许远程 <code>JVM</code> 监控</td></tr><tr><td><code>hs_err_pid</code></td><td><code>JVM</code> 崩溃时自动生成的错误日志文件。</td><td>分析文件中的堆栈跟踪和 <code>JVM</code> 错误信息</td></tr><tr><td><code>jhsdb</code></td><td>诊断和分析工具，用于分析 <code>JVM</code> 进程的堆、线程等信息。</td><td><code>jhsdb jmap</code> 查看堆信息或生成堆转储<br><code>jhsdb jstack</code> 查看线程堆栈</td></tr></tbody></table><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p><code>jps</code>  是一个用于列出当前所有运行中的 Java 虚拟机进程的命令行工具。它可以显示每个 <code>JVM</code> 实例的进程 <code>ID</code> (<code>PID</code>) 及其启动类或 <code>JAR</code> 文件名称，适用于快速获取 <code>JVM</code> 进程的 <code>PID</code>，以便与其他 <code>JVM</code> 工具（如  <code>jstat</code>,  <code>jstack</code>  等）结合使用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="hljs bash">jps [options] [<span class="hljs-built_in">hostid</span>]</code></pre><ul><li><code>[options]</code>:  <code>jps</code>  的选项，可以指定显示的内容。</li><li><code>[hostid]</code>: 可选参数，指定远程主机的标识符。如果未指定，则默认为本地主机。</li></ul><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-q</code>  : 只输出 Java 进程的 PID，不显示类名、JAR 文件名等信息。</li><li><code>-m</code>  : 显示传递给主类的参数或传递给 JAR 文件的参数。</li><li><code>-l</code>  : 输出主类的全限定名或 JAR 文件的完整路径。</li><li><code>-v</code>  : 输出传递给 JVM 的参数。</li></ul><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><code>jstat</code>  是一个用于监控 <code>JVM</code> 性能统计的命令行工具，它可以提供堆内存使用情况、垃圾收集信息、类加载统计等信息。以下是  <code>jstat</code>  的基本用法和常用选项说明：</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p><ul><li><code>&lt;option&gt;</code>: 选择想要查看的统计信息类型，具体的选项可以通过  <code>jstat -options</code>  查看。</li><li><code>&lt;vmid&gt;</code>: <code>JVM</code> 实例的标识符，通常是 <code>JVM</code> 进程的 <code>PID</code>，也可以是  <code>&lt;lvmid&gt;@&lt;hostname&gt;[:&lt;port&gt;]</code>  的形式。</li><li><code>&lt;interval&gt;</code>: 采样间隔时间，可以指定单位为毫秒 (<code>ms</code>) 或秒 (<code>s</code>)，如果不指定单位，默认单位是毫秒。</li><li><code>&lt;count&gt;</code>: 采样次数，指定后程序在采样指定次数后自动终止。</li></ul><h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-gc</code>: 显示与垃圾回收相关的统计信息，包括年轻代、老年代、永久代的内存使用情况以及 <code>GC</code> 次数和时间。</li><li><code>-gccapacity</code>: 显示各代内存区域的使用和分配情况。</li><li><code>-gcutil</code>: 显示每一代内存区域的利用率以及 <code>GC</code> 的次数和时间。</li><li><code>-class</code>: 显示类加载的统计信息，包括已加载类、已卸载类的数量等。</li><li><code>-compiler</code>: 显示 <code>JIT</code> 编译器的统计信息。</li><li><code>-printcompilation</code>: 显示已经编译的最近方法的相关信息。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><p>查看 <code>PID</code> 为 <code>12345</code> 的 <code>JVM</code> 的垃圾回收情况，每 <code>1</code> 秒采样一次，共采样 <code>10</code>次：</p><p> <code>jstat -gc 12345 1000 10</code></p></li><li><p>查看 <code>JVM</code> 进程的类加载情况：</p><p> <code>jstat -class 12345</code></p></li><li><p>查看 <code>PID</code> 为 <code>12345</code> 的 <code>JVM</code> 的堆内存使用情况，采样间隔为 <code>2</code> 秒，直到手动终止：</p><p> <code>jstat -gcutil 12345 2000</code></p></li></ol><p>通过  <code>jstat</code>，可以对 <code>Java</code> 应用的运行状况进行实时监控和诊断，特别是在调优 <code>JVM</code> 参数时，这个工具非常有用。</p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p><code>jinfo</code>  是一个用于查看和修改运行中 <code>Java</code> 虚拟机（<code>JVM</code>）进程配置的命令行工具。它可以用于查询 <code>JVM</code> 的启动参数、系统属性以及动态调整 <code>JVM</code> 的某些配置。</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>jinfo &lt;option&gt; &lt;pid&gt;</code></p><ul><li><code>&lt;option&gt;</code>: 要执行的操作选项，用于指定查询或设置的内容。</li><li><code>&lt;pid&gt;</code>: 目标 <code>JVM</code> 进程的 <code>PID</code>，用于指定要操作的 <code>JVM</code> 进程。</li></ul><h3 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-flag &lt;name&gt;</code>: 输出指定 <code>JVM</code> 标志（<code>flag</code>）的值。</li><li><code>-flag [+|-]&lt;name&gt;</code>: 启用或禁用指定的 <code>JVM</code> 标志。</li><li><code>-flag &lt;name&gt;=&lt;value&gt;</code>: 将指定的 <code>JVM</code> 标志设置为给定的值。</li><li><code>-flags</code>: 输出当前 <code>JVM</code> 进程的所有 <code>JVM</code> 标志及其值。</li><li><code>-sysprops</code>: 输出当前 <code>JVM</code> 进程的所有系统属性（<code>System Properties</code>）。</li><li><code>&lt;no option&gt;</code>: 如果不指定任何选项，则输出 <code>JVM</code> 的所有标志和系统属性。</li><li><code>-? | -h | --help | -help</code>: 输出帮助信息。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>查看 JVM 标志的值</strong>:</p><p> <code>jinfo -flag MaxHeapSize 12345</code></p><p> 这将输出 PID 为  <code>12345</code>  的 <code>JVM</code> 进程中  <code>MaxHeapSize</code>  标志的值。</p></li><li><p><strong>启用或禁用 JVM 标志</strong>:</p><p> <code>jinfo -flag +PrintGC 12345</code></p><p> 这将启用 <code>PID</code> 为  <code>12345</code>  的 <code>JVM</code> 进程的  <code>PrintGC</code>  标志。</p></li><li><p><strong>设置 JVM 标志的值</strong>:</p><p> <code>jinfo -flag MaxHeapSize=1073741824 12345</code></p><p> 这将把 <code>PID</code> 为  <code>12345</code>  的 <code>JVM</code> 进程的  <code>MaxHeapSize</code>  标志设置为 <code>1</code> GB（<code>1073741824</code> 字节）。</p></li><li><p><strong>查看所有 JVM 标志</strong>:</p><p> <code>jinfo -flags 12345</code></p><p> 这将输出 <code>PID</code> 为  <code>12345</code>  的 <code>JVM</code> 进程的所有 <code>JVM</code> 标志及其当前值。</p></li><li><p><strong>查看所有系统属性</strong>:</p><p> <code>jinfo -sysprops 12345</code></p><p> 这将输出 <code>PID</code> 为  <code>12345</code>  的 <code>JVM</code> 进程的所有系统属性。</p></li><li><p><strong>查看 JVM 标志和系统属性</strong>:</p><p> <code>jinfo 12345</code></p><p> 如果不带任何选项，<code>jinfo</code>  会输出指定 <code>JVM</code> 进程的所有 <code>JVM</code> 标志和系统属性。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>jinfo</code>  是一个非常有用的工具，特别是在需要诊断运行中的 <code>JVM</code> 进程问题时，可以让你动态地查看和调整 <code>JVM</code> 配置，而无需重启应用程序。</p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><code>jmap</code>  是一个用于生成堆转储（<code>heap dump</code>）以及获取 <code>Java</code> 堆内存使用情况的命令行工具。它可以帮助分析 <code>JVM</code> 中对象的分配情况，了解内存使用的分布，并识别内存泄漏问题。</p><p>（<code>JDK 9</code> 及更高版本中用于替代  <code>jmap</code>  某些功能的新工具，可以使用  <code>jhsdb</code>  工具）</p><h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>jmap [option] &lt;pid&gt;</code></p><ul><li><code>&lt;option&gt;</code>: 执行的操作选项，用于指定要获取的内存信息或生成的转储类型。</li><li><code>&lt;pid&gt;</code>: 目标 <code>JVM</code> 进程的 <code>PID</code>（进程 <code>ID</code>），用于指定要操作的 <code>JVM</code> 进程。</li></ul><h3 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-dump:[live,]format=b,file=&lt;filename&gt;</code>: 生成堆转储文件，<code>live</code>  表示只转储存活的对象（可选），<code>format=b</code>  表示二进制格式，<code>file=&lt;filename&gt;</code>  指定转储文件的路径和名称。</li><li><code>-heap</code>: 显示堆的概要信息，包括使用的堆存储管理器和堆配置。</li><li><code>-histo[:live]</code>: 显示堆中对象的直方图，包括类的实例数和占用空间。如果使用  <code>live</code>  选项，则只显示存活的对象。</li><li><code>-finalizerinfo</code>: 显示正在等待终结的对象（即  <code>finalize()</code>  尚未执行的对象）。</li><li><code>-clstats</code>: 显示类加载器的统计信息。</li><li><code>-F</code>: 强制操作，当 <code>JVM</code> 不响应时（例如挂起状态），可以使用这个选项强制生成堆转储或获取内存信息。</li><li><code>-J&lt;flag&gt;</code>: 将  <code>&lt;flag&gt;</code>  直接传递给 <code>JVM</code>（与其他工具相同的选项）。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>生成堆转储文件</strong>:</p><p> <code>jmap -dump:format=b,file=heapdump.hprof 12345</code></p><p> 这将在当前目录下生成名为  <code>heapdump.hprof</code>  的堆转储文件，适用于分析内存泄漏或内存使用情况。</p></li><li><p><strong>只转储存活对象</strong>:</p><p> <code>jmap -dump:live,format=b,file=heapdump_live.hprof 12345</code></p><p> 这将生成一个仅包含存活对象的堆转储文件。</p></li><li><p><strong>查看堆的概要信息</strong>:</p><p> <code>jmap -heap 12345</code></p><p> 这将显示 <code>JVM</code> 堆的概要信息，包括堆的配置和使用情况。</p></li><li><p><strong>显示堆中对象的直方图</strong>:</p><p> <code>jmap -histo 12345</code></p><p> 这将显示所有对象的直方图，包括每个类的实例数量和总占用空间。</p></li><li><p><strong>显示仅存活对象的直方图</strong>:</p><p> <code>jmap -histo:live 12345</code></p><p> 这将显示堆中仅存活对象的直方图。</p></li><li><p><strong>显示正在等待终结的对象</strong>:</p><p> <code>jmap -finalizerinfo 12345</code></p><p> 这将列出 <code>JVM</code> 中正在等待执行  <code>finalize()</code>  方法的对象。</p></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>jmap</code>  是 <code>JVM</code> 诊断和内存分析的重要工具，尤其在分析内存泄漏、内存分配模式和优化内存使用时非常有用。它可以帮助生成堆转储，查看内存使用情况，并获取 <code>JVM</code> 的详细内存统计信息，从而深入了解 <code>Java</code> 应用的内存表现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-对象的内存布局</title>
      <link href="/2022/08/12/jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2022/08/12/jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>阅读《深入理解java虚拟机》第三版，结合<code>openjdk-17u</code> 中的<code>hotspo</code>t源码简单记录一下。</p><h3 id="1-对象的内存布局"><a href="#1-对象的内存布局" class="headerlink" title="1. 对象的内存布局"></a>1. 对象的内存布局</h3><p>在JVM中，每个Java对象在内存中的布局通常分为三个部分：</p><h4 id="1-1-对象头-Object-Header"><a href="#1-1-对象头-Object-Header" class="headerlink" title="1.1 对象头 (Object Header)"></a>1.1 对象头 (Object Header)</h4><p> <strong>Mark Word</strong></p><p> 它是对象头中的一部分，用于存储对象的运行时信息，包括对象的哈希码（<code>hashcode</code>）、<code>GC</code> 状态（是否被标记为垃圾回收）、锁标志位（用于同步锁的状态）、偏向锁的线程 <code>ID</code>、偏向时间戳等。在不同的情况下，<code>Mark Word</code> 的内容会有所不同。以下是来自<code>openjdk-17u</code>的<code>hotspot</code>源码中关于 <code>Mark Word</code> 部分的注释</p><p><code>src/hotspot/share/oops/markWord.cpp: </code></p><pre><code class="hljs c++"><span class="hljs-comment">// The markWord describes the header of an object.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">// Bit-format of an object header (most significant first, big endian layout below):  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//  32 bits:  </span><span class="hljs-comment">//  --------  </span><span class="hljs-comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)  </span><span class="hljs-comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//  64 bits:  </span><span class="hljs-comment">//  --------  </span><span class="hljs-comment">//  unused:25 hash:31 --&gt;| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)  </span><span class="hljs-comment">//  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//  - hash contains the identity hash value: largest value is  </span><span class="hljs-comment">//    31 bits, see os::random().  Also, 64-bit vm&#x27;s require  </span><span class="hljs-comment">//    a hash value no bigger than 32 bits because they will not  </span><span class="hljs-comment">//    properly generate a mask larger than that: see library_call.cpp  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//  - the biased lock pattern is used to bias a lock toward a given  </span><span class="hljs-comment">//    thread. When this pattern is set in the low three bits, the lock  </span><span class="hljs-comment">//    is either biased toward a given thread or &quot;anonymously&quot; biased,  </span><span class="hljs-comment">//    indicating that it is possible for it to be biased. When the  </span><span class="hljs-comment">//    lock is biased toward a given thread, locking and unlocking can  </span><span class="hljs-comment">//    be performed by that thread without using atomic operations.  </span><span class="hljs-comment">//    When a lock&#x27;s bias is revoked, it reverts back to the normal  </span><span class="hljs-comment">//    locking scheme described below.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//    Note that we are overloading the meaning of the &quot;unlocked&quot; state  </span><span class="hljs-comment">//    of the header. Because we steal a bit from the age we can  </span><span class="hljs-comment">//    guarantee that the bias pattern will never be seen for a truly  </span><span class="hljs-comment">//    unlocked object.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//    Note also that the biased state contains the age bits normally  </span><span class="hljs-comment">//    contained in the object header. Large increases in scavenge  </span><span class="hljs-comment">//    times were seen when these bits were absent and an arbitrary age  </span><span class="hljs-comment">//    assigned to all biased objects, because they tended to consume a  </span><span class="hljs-comment">//    significant fraction of the eden semispaces and were not  </span><span class="hljs-comment">//    promoted promptly, causing an increase in the amount of copying  </span><span class="hljs-comment">//    performed. The runtime system aligns all JavaThread* pointers to  </span><span class="hljs-comment">//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))  </span><span class="hljs-comment">//    to make room for the age bits &amp; the epoch bits (used in support of  </span><span class="hljs-comment">//    biased locking).  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread  </span><span class="hljs-comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//    [ptr             | 00]  locked             ptr points to real header on stack  </span><span class="hljs-comment">//    [header      | 0 | 01]  unlocked           regular object header  </span><span class="hljs-comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)  </span><span class="hljs-comment">//    [ptr             | 11]  marked             used to mark an object  </span><span class="hljs-comment">//    [0 ............ 0| 00]  inflating          inflation in progress  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//    We assume that stack/thread pointers have the lowest two bits cleared.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//  - INFLATING() is a distinguished markword value of all zeros that is  </span><span class="hljs-comment">//    used when inflating an existing stack-lock into an ObjectMonitor.  </span><span class="hljs-comment">//    See below for is_being_inflated() and INFLATING().</span></code></pre><p> <strong>Class Pointer</strong>（类型指针）</p><p> 指向对象所属类的 <code>Class</code> 对象。<code>JVM</code> 通过这个指针确定对象的类型信息。</p><p> <strong>数组长度（仅对数组对象有效）</strong></p><p> 如果是数组对象，头部还会存储数组的长度。</p><h4 id="1-2-实例数据-Instance-Data"><a href="#1-2-实例数据-Instance-Data" class="headerlink" title="1.2 实例数据 (Instance Data)"></a>1.2 实例数据 (Instance Data)</h4><p>这是对象实际存储成员变量（<code>field</code>）的部分。这个区域包含了所有的实例字段，按声明顺序排列。<code>JVM</code> 可能会对这些字段进行对齐优化。</p><ul><li><p><strong>基本类型字段</strong>：如<code>int</code>、<code>float</code>、<code>boolean</code>等，这些字段按类型和声明顺序存储。</p></li><li><p><strong>引用类型字段</strong>：如对象引用，这些字段存储的是指向实际对象的引用（通常是指针）。</p></li></ul><h4 id="1-3-对齐填充-Padding"><a href="#1-3-对齐填充-Padding" class="headerlink" title="1.3 对齐填充 (Padding)"></a>1.3 对齐填充 (Padding)</h4><p><code>JVM</code> 为了保证对象大小是 <code>8</code> 字节的倍数，可能会在对象的末尾添加一些填充字节（<code>padding</code>）。这是为了满足硬件的内存对齐要求，提升访问效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-类加载流程</title>
      <link href="/2022/08/07/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/08/07/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>当使用 <code>java -jar HelloApp.jar</code> 启动一个 Java 应用程序时，JVM 的类加载过程是由多个步骤组成的，并且不同的类加载器在不同阶段扮演着不同的角色。下面是详细的过程：</p><h3 id="1-启动JVM"><a href="#1-启动JVM" class="headerlink" title="1. 启动JVM"></a>1. 启动JVM</h3><p> 当运行 <code>java -jar HelloApp.jar</code> 时，JVM 启动并初始化。这时，JVM 会先加载一些必要的系统类，这些类是由 <strong>Bootstrap ClassLoader（引导类加载器）</strong> 负责加载的。</p><h3 id="2-引导类加载器加载核心类库"><a href="#2-引导类加载器加载核心类库" class="headerlink" title="2. 引导类加载器加载核心类库"></a>2. 引导类加载器加载核心类库</h3><p><strong>Bootstrap ClassLoader</strong> 是 <code>JVM</code> 自带的一个特殊的类加载器，它使用本地代码实现，负责加载 <code>JVM</code> 自身需要的核心类库，如 <code>java.lang.*</code>、<code>java.util.*</code> 等，这些类通常位于 <code>rt.jar</code> 或者在模块化 <code>JDK</code> 中的基础模块。</p><p>具体来说，<code>Bootstrap ClassLoader</code> 会加载类似 <code>java.lang.Object</code>、<code>java.lang.String</code>、<code>java.lang.ClassLoader</code> 等类。这些是 <code>JVM</code> 启动和运行 <code>Java</code> 应用程序所必需的类。</p><h3 id="3-扩展类加载器加载扩展类库"><a href="#3-扩展类加载器加载扩展类库" class="headerlink" title="3. 扩展类加载器加载扩展类库"></a>3. 扩展类加载器加载扩展类库</h3><p><code>JVM</code> 然后使用 <strong>Extension ClassLoader（扩展类加载器）</strong>，它加载位于 <code>jre/lib/ext</code> 目录下的扩展类库（在模块化 <code>JDK</code> 中，这个加载器主要加载某些模块）。这些类库通常是标准扩展，但并不是所有应用程序都需要。</p><h3 id="4-应用类加载器加载应用程序类"><a href="#4-应用类加载器加载应用程序类" class="headerlink" title="4. 应用类加载器加载应用程序类"></a>4. 应用类加载器加载应用程序类</h3><p>接下来，<strong>Application ClassLoader（应用类加载器）</strong> 加载应用程序的类。对于 <code>java -jar Hello.jar</code>，应用类加载器会加载 JAR 文件中的主类和其他所有相关类。此时，<code>Application ClassLoader</code> 会从 <code>JAR</code> 文件的 <code>classpath</code> 中找到 <code>HelloApp.class</code> 并将其加载到内存中。</p><h3 id="5-加载并解析主类"><a href="#5-加载并解析主类" class="headerlink" title="5. 加载并解析主类"></a>5. 加载并解析主类</h3><p>应用类加载器加载主类（即包含 <code>public static void main(String[] args)</code> 方法的类），并解析它的字节码。</p><p>在解析过程中，如果主类依赖于其他类，这些依赖类将按照<strong>双亲委派模型</strong>被相应的类加载器加载。</p><h3 id="6-执行主类的-main-方法"><a href="#6-执行主类的-main-方法" class="headerlink" title="6. 执行主类的 main 方法"></a>6. 执行主类的 <code>main</code> 方法</h3><p>当主类被加载并初始化后，<code>JVM</code> 调用主类的 <code>main</code> 方法，程序正式开始执行。</p><h3 id="7-类加载的双亲委派模型"><a href="#7-类加载的双亲委派模型" class="headerlink" title="7. 类加载的双亲委派模型"></a>7. 类加载的双亲委派模型</h3><p>在整个类加载过程中，<code>JVM</code> 使用双亲委派模型来加载类。即当一个类加载器尝试加载一个类时，它首先会把请求委派给父类加载器（如 <code>Application ClassLoader</code> 会委派给 <code>Extension ClassLoader</code>，<code>Extension ClassLoader</code> 又委派给 <code>Bootstrap ClassLoader</code>）。如果父类加载器无法加载该类，那么子加载器才会尝试自己加载。</p><p>这种模型保证了核心类库不会被错误的加载（例如，防止用户定义的 <code>java.lang.String</code> 类覆盖系统类库中的同名类）。</p><h3 id="8-动态类加载"><a href="#8-动态类加载" class="headerlink" title="8. 动态类加载"></a>8. 动态类加载</h3><p>如果在 <code>main</code> 方法执行期间，某些类是第一次被引用，<code>JVM</code> 会动态加载这些类。这个加载过程依旧遵循双亲委派模型，由对应的类加载器加载这些新类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当使用 <code>java -jar Hello.jar</code> 启动一个 Java 程序时，<code>JVM</code> 依次使用 <code>Bootstrap ClassLoader</code>、<code>Extension ClassLoader</code> 和 <code>Application ClassLoader</code> 来加载所需的类库。<code>Bootstrap ClassLoader</code> 负责加载核心类库（包括 <code>java.lang.ClassLoader</code>），随后，应用类加载器负责加载 <code>JAR</code> 文件中的应用程序类。程序开始执行时，<code>JVM</code> 已经准备好了所有必要的类，并开始调用 <code>main</code> 方法来启动应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-解析流程</title>
      <link href="/2022/08/03/jvm-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/08/03/jvm-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>参考 <code>java</code> 虚拟机规范：<code>5. Loading, Linking, and Initializing</code></p><p><code>java</code> 编译器将 <code>.java</code> 源文件编译成 <code>.class</code> 文件时，并不会直接将类中的字段或方法等直接编译成内存中的地址，而是使用符号引用来暂时代替，并且符号引用是用类的全限定类型、方法名和字段名等形式存在，比如下面的代码片段中：</p><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span>;System.out.println(str);</code></pre><p>其中的 <code>String</code> 类和 <code>println</code> 方法会被编译成：<code>java/lang/String</code> 和 <code>java/io/PrintStream.println</code>；而类加载过程中的解析阶段会将这些符号引用替换为实际的内存地址</p><p>解析主要分为四种类型：类或接口解析、字段解析、方法解析和接口方法解析。</p><h3 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1. 类或接口的解析"></a>1. 类或接口的解析</h3><p> <strong>符号引用</strong>：在字节码中，类和接口是通过符号引用来表示的（例如，通过类的全限定名，如<code>java/lang/String</code>）。</p><p> <strong>解析步骤</strong>：类加载器会使用符号引用去寻找相应的类或接口定义，并将其解析为具体的类对象。</p><p><strong>过程</strong>：<br>    1. 首先，<code>JVM</code> 会通过当前类的类加载器找到对应的符号引用（通常是类的全限定名）。<br>    2. <code>JVM</code> 会调用类加载器的<code>loadClass</code>方法来加载该类。<br>    3. 如果成功找到并加载该类或接口，则解析成功。<br>    4. 如果加载失败，则抛出<code>ClassNotFoundException</code>或<code>NoClassDefFoundError</code>异常。</p><h3 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2. 字段解析"></a>2. 字段解析</h3><p><strong>符号引用</strong>：在字节码中，类的字段也是通过符号引用来表示的（例如，<code>cn/wwinter/MyClass.myField</code>）。</p><p><strong>解析步骤</strong>：当解析字段时，首先需要解析它所在的类或接口。</p><p><strong>过程</strong>：<br>    1. 首先，<code>JVM</code> 解析字段所在的类或接口。如果类或接口的解析失败，则抛出异常。<br>    2. 如果类解析成功，<code>JVM</code> 会查找该字段是否在类或接口中定义。<br>    3. 如果字段在该类或其父类中找到，解析成功。<br>    4. 如果字段未找到，则抛出 <code>NoSuchFieldError</code> 异常。</p><h3 id="3-方法解析"><a href="#3-方法解析" class="headerlink" title="3. 方法解析"></a>3. 方法解析</h3><p><strong>符号引用</strong>：在字节码中，方法调用是通过符号引用来表示的（例如，<code>cn/wwinter/MyClass.myMethod()</code>）。</p><p><strong>解析步骤</strong>：解析方法的过程与解析字段类似，但要考虑方法的重载与继承。</p><p><strong>过程</strong>：<br>    1. 首先，解析方法所在的类或接口。<br>    2. 然后，查找该方法在类或接口中是否存在，并确保方法签名匹配。<br>    3. 如果找到匹配的方法，则解析成功。<br>    4. 如果方法未找到或签名不匹配，则抛出<code>NoSuchMethodError</code>异常。</p><h3 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4. 接口方法解析"></a>4. 接口方法解析</h3><p><strong>符号引用</strong>：接口方法的调用也是通过符号引用表示的，通常是指通过<code>invokeinterface</code>字节码指令来调用接口中的方法。</p><p><strong>解析步骤</strong>：与普通方法解析类似，但是接口方法解析更复杂一些，因为需要考虑多个实现类。</p><p><strong>过程</strong>：<br>    1. 首先解析接口。<br>    2. 然后，查找接口中声明的方法。如果接口解析成功并找到方法，则解析成功。<br>    3. 如果方法未找到，则抛出<code>AbstractMethodError</code>异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oom异常实例</title>
      <link href="/2022/08/01/oom%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8B/"/>
      <url>/2022/08/01/oom%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/oom-Pasted%20image%2020240909195755.png"></p><h3 id="1-堆溢出"><a href="#1-堆溢出" class="headerlink" title="1. 堆溢出"></a>1. 堆溢出</h3><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.wwinter;    <span class="hljs-keyword">import</span> java.util.ArrayList;  <span class="hljs-keyword">import</span> java.util.List;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;      <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span> &#123;      &#125;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          List&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();          <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;              list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMObject</span>());          &#125;      &#125;  &#125;</code></pre><p>执行：<code>java -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError HeapOOM.java</code>： </p><ul><li><code>-Xms20m</code>：设置 <code>JVM</code> 初始堆内存大小为 <code>20MB</code>。</li><li><code>-Xmx20m</code>：设置 <code>JVM</code> 最大堆内存大小为 <code>20MB</code>。</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当堆内存溢出时，<code>JVM</code> 会生成一个堆转储文件（<code>.hprof</code> 文件），用于后续的内存分析。</li></ul><pre><code class="hljs bash">zhangdongdong:wwinter/ (master✗) $ java -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError HeapOOM.java                                                                   [19:51:00]java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid18144.hprof ...Heap dump file created [34168105 bytes <span class="hljs-keyword">in</span> 0.052 secs]Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space        at java.base/java.util.Arrays.copyOf(Arrays.java:3512)        at java.base/java.util.Arrays.copyOf(Arrays.java:3481)        at java.base/java.util.ArrayList.grow(ArrayList.java:237)        at java.base/java.util.ArrayList.grow(ArrayList.java:244)        at java.base/java.util.ArrayList.add(ArrayList.java:454)        at java.base/java.util.ArrayList.add(ArrayList.java:467)        at cn.wwinter.HeapOOM.main(HeapOOM.java:13)</code></pre><p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/oom-Pasted%20image%2020240909195755.png"></p><p>从堆转储文件来看，有以下几个关键点：</p><h5 id="1-cn-wwinter-HeapOOM-OOMObject-类的实例数量"><a href="#1-cn-wwinter-HeapOOM-OOMObject-类的实例数量" class="headerlink" title="1. cn.wwinter.HeapOOM$OOMObject 类的实例数量"></a>1. <code>cn.wwinter.HeapOOM$OOMObject</code> 类的实例数量</h5><ul><li>该类的实例数量达到了 <strong>810,326</strong> 个，占用了 <strong>12.97 MB</strong> 的内存。</li></ul><h5 id="2-java-lang-Object-和-byte-的内存占用"><a href="#2-java-lang-Object-和-byte-的内存占用" class="headerlink" title="2. java.lang.Object[] 和 byte[] 的内存占用"></a>2. <code>java.lang.Object[]</code> 和 <code>byte[]</code> 的内存占用</h5><ul><li><code>java.lang.Object[]</code> 占用了 <strong>17.07 MB</strong>。</li><li><code>byte[]</code> 占用了 <strong>728.21 KB</strong>。</li></ul><h5 id="3-内存泄漏或大内存消耗的根本原因"><a href="#3-内存泄漏或大内存消耗的根本原因" class="headerlink" title="3. 内存泄漏或大内存消耗的根本原因"></a>3. 内存泄漏或大内存消耗的根本原因</h5><ul><li>从分析结果来看，最大的内存消耗者是 <code>cn.wwinter.HeapOOM$OOMObject</code>，这表明代码中的 <code>list.add(new OOMObject());</code> 是导致堆内存溢出的主要原因。</li></ul><h3 id="2-栈溢出"><a href="#2-栈溢出" class="headerlink" title="2.  栈溢出"></a>2.  栈溢出</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.wwinter;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;          stackLength++;          stackLeak();      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">sof</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();          <span class="hljs-keyword">try</span> &#123;              sof.stackLeak();          &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;              System.out.println(<span class="hljs-string">&quot;stack length: &quot;</span> + sof.stackLength);              <span class="hljs-keyword">throw</span> e;          &#125;      &#125;  &#125;</code></pre><pre><code class="hljs bash">stack length: 36574Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowErrorat cn.wwinter.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:8)at cn.wwinter.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:8)at cn.wwinter.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:8)</code></pre><h3 id="3-方法区溢出（通常与元空间有关）"><a href="#3-方法区溢出（通常与元空间有关）" class="headerlink" title="3.  方法区溢出（通常与元空间有关）"></a>3.  方法区溢出（通常与元空间有关）</h3><p>在 <code>Java 8</code> 及以后的版本中，方法区已经被移到元空间（<code>Metaspace</code>），而在 <code>Java 7</code> 及以前，方法区包含在永久代（<code>PermGen</code>）中。以下代码通过动态生成大量类，导致方法区溢出：</p><h4 id="示例代码：方法区溢出（元空间溢出）"><a href="#示例代码：方法区溢出（元空间溢出）" class="headerlink" title="示例代码：方法区溢出（元空间溢出）"></a>示例代码：方法区溢出（元空间溢出）</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;  <span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaspaceOOM</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;              <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();              enhancer.setSuperclass(MetaspaceOOM.class);              enhancer.setUseCache(<span class="hljs-literal">false</span>);              enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));              enhancer.create();          &#125;      &#125;  &#125;</code></pre><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li><p>这个代码使用  <code>CGLIB</code>  动态生成了大量的类，并不断地将这些类加载到 <code>JVM</code> 中，导致元空间（<code>Metaspace</code>）溢出。</p></li><li><p>运行时可以使用以下 <code>JVM</code> 参数来限制元空间的大小：</p><p>  <code>java -XX:MaxMetaspaceSize=10m MetaspaceOOM</code></p><p>  当生成的类过多，导致元空间耗尽时，会抛出 <code>java.lang.OutOfMemoryError: Metaspace</code> 异常。</p></li></ul><h3 id="4-运行时常量池溢出"><a href="#4-运行时常量池溢出" class="headerlink" title="4. 运行时常量池溢出"></a>4. 运行时常量池溢出</h3><p>在 <code>Java 7</code> 及以前，运行时常量池（<code>Runtime Constant Pool</code>）是在方法区（永久代）中的，而在 <code>Java 8</code> 及以后，它在堆中。下面的代码通过不断地向常量池中添加字符串来导致溢出。</p><h4 id="示例代码：运行时常量池溢出"><a href="#示例代码：运行时常量池溢出" class="headerlink" title="示例代码：运行时常量池溢出"></a>示例代码：运行时常量池溢出</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;  <span class="hljs-keyword">import</span> java.util.List;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeConstantPoolOOM</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();          <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;              list.add(String.valueOf(i++).intern());          &#125;      &#125;  &#125;</code></pre><h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><ul><li><p>这个代码不断生成新的字符串，并调用 <code>intern()</code> 方法将其放入运行时常量池中。</p></li><li><p>如果使用 <code>Java 7</code>，可以通过以下 <code>JVM</code> 参数来限制永久代大小，从而触发 <code>java.lang.OutOfMemoryError: PermGen space</code> 异常：</p><p>  <code>java -XX:PermSize=10m -XX:MaxPermSize=10m RuntimeConstantPoolOOM</code></p></li><li><p>在 <code>Java 8</code> 及以后，这个代码将会导致堆内存溢出，因为运行时常量池在堆内存中：<br>  <code>java -Xmx10m RuntimeConstantPoolOOM</code></p><p>  当堆内存耗尽时，会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code> 异常。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化总结</title>
      <link href="/2022/06/12/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/12/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/redis-5fb76d3ec9fd434fe46a579d9c1c8a83.jpeg"></p><p><code>Redis</code> 是一个高性能的内存数据库，但为了防止数据丢失，Redis 提供了持久化机制，将数据存储到磁盘中。在 <code>Redis</code> 中，有两种主要的持久化方式：<code>RDB</code>（Redis Database）快照和 <code>AOF</code>（Append-Only File）日志。接下来介绍这两种持久化方式。</p><h2 id="一、RDB-持久化"><a href="#一、RDB-持久化" class="headerlink" title="一、RDB 持久化"></a>一、RDB 持久化</h2><h3 id="1-1-什么是-RDB-持久化"><a href="#1-1-什么是-RDB-持久化" class="headerlink" title="1.1 什么是 RDB 持久化"></a>1.1 什么是 RDB 持久化</h3><p><code>RDB</code>（Redis Database）持久化是指 <code>Redis</code> 以二进制文件的形式将内存中的数据快照保存到磁盘中。生成的文件通常称为 <code>RDB</code> 文件（默认名为 <code>dump.rdb</code>）。当 <code>Redis</code> 服务器重启时，可以通过加载这个 RDB 文件来恢复数据。</p><h3 id="1-2-RDB-的工作原理"><a href="#1-2-RDB-的工作原理" class="headerlink" title="1.2 RDB 的工作原理"></a>1.2 RDB 的工作原理</h3><p><code>RDB</code> 的工作原理是在指定的时间间隔内保存内存中的数据到 <code>RDB</code> 文件中，也叫做“快照”。<code>RDB</code> 快照可以通过两种方式触发：</p><ul><li><p><strong>自动快照</strong>：通过配置 <code>save</code> 选项，<code>Redis</code> 可以在指定的条件下自动生成 <code>RDB</code> 快照，例如在一定时间内执行了多少次写操作。</p></li><li><p><strong>手动快照</strong>：可以通过命令 <code>SAVE</code> 或 <code>BGSAVE</code> 手动生成 <code>RDB</code> 快照。<code>SAVE</code> 会阻塞 <code>Redis</code> 服务器，直到快照完成，而 <code>BGSAVE</code> 则是通过创建子进程在后台完成快照操作，主进程可以继续处理客户端请求。</p></li></ul><h3 id="1-3-RDB-的优缺点"><a href="#1-3-RDB-的优缺点" class="headerlink" title="1.3 RDB 的优缺点"></a>1.3 RDB 的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>磁盘空间使用少</strong>：<code>RDB</code> 文件是高度压缩的二进制文件，占用的磁盘空间较小。</li><li><strong>恢复速度快</strong>：因为 <code>RDB</code> 文件是紧凑的二进制格式，加载速度较快，适合快速恢复大规模数据。</li><li><strong>适合备份</strong>：<code>RDB</code> 文件包含了某个时间点的完整数据快照，适合定期备份和归档。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>数据丢失风险</strong>：<code>RDB</code> 持久化是定期的，因此在上次快照和服务器崩溃之间的写操作会丢失。</li><li><strong>生成快照时性能影响较大</strong>：在生成快照时需要将内存数据写入磁盘，对于大数据集，可能会对 <code>Redis</code> 性能造成一定影响。</li></ul><h3 id="1-4-RDB-的配置示例"><a href="#1-4-RDB-的配置示例" class="headerlink" title="1.4 RDB 的配置示例"></a>1.4 RDB 的配置示例</h3><pre><code class="hljs bash"><span class="hljs-comment"># 每 900 秒（15 分钟）内至少有 1 次写操作时，生成 RDB 快照</span>save 900 1<span class="hljs-comment"># 每 300 秒（5 分钟）内至少有 10 次写操作时，生成 RDB 快照</span>save 300 10<span class="hljs-comment"># 每 60 秒内至少有 10000 次写操作时，生成 RDB 快照</span>save 60 10000</code></pre><h2 id="二、AOF-持久化"><a href="#二、AOF-持久化" class="headerlink" title="二、AOF 持久化"></a>二、AOF 持久化</h2><h3 id="2-1-什么是-AOF-持久化"><a href="#2-1-什么是-AOF-持久化" class="headerlink" title="2.1 什么是 AOF 持久化"></a>2.1 什么是 AOF 持久化</h3><p><code>AOF</code>（Append-Only File）持久化是 <code>Redis</code> 通过记录每次写操作的日志来实现数据持久化的机制。<code>AOF</code> 文件以追加的方式将每次写操作记录下来，当 <code>Redis</code> 重启时，通过重新执行这些操作日志来恢复数据。</p><h3 id="2-2-AOF-的工作原理"><a href="#2-2-AOF-的工作原理" class="headerlink" title="2.2 AOF 的工作原理"></a>2.2 AOF 的工作原理</h3><p><code>AOF</code> 通过记录每个写操作的命令，将其追加到 <code>AOF</code> 文件中。当服务器重启时，<code>Redis</code> 会从 <code>AOF</code> 文件中逐条读取命令并重新执行，以此恢复数据。</p><p><code>AOF</code> 的记录策略由 <code>appendfsync</code> 选项控制：</p><ul><li><strong>always</strong>：每次写操作都立即同步到 <code>AOF</code> 文件中，最安全但性能最差。</li><li><strong>everysec</strong>：每秒同步一次，性能和安全性折中方案（默认）。</li><li><strong>no</strong>：完全依赖操作系统，性能最好，但在服务器崩溃时可能会丢失多秒的数据。</li></ul><h3 id="2-3-AOF-的优缺点"><a href="#2-3-AOF-的优缺点" class="headerlink" title="2.3 AOF 的优缺点"></a>2.3 AOF 的优缺点</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>数据丢失风险小</strong>：<code>AOF</code> 记录每次写操作，数据持久化频率高，丢失的数据量很少。</li><li><strong>AOF 文件可读性强</strong>：<code>AOF</code> 文件是以 <code>Redis</code> 命令的形式记录的，可以直接查看和理解日志内容。</li><li><strong>支持重写</strong>：<code>Redis</code> 支持 <code>AOF</code> 文件的重写机制，以减少文件大小，并移除冗余命令。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>AOF 文件较大</strong>：<code>AOF</code> 文件比 <code>RDB</code> 文件大很多，因为它记录了每次写操作，而不是整个数据集的快照。</li><li><strong>恢复速度较慢</strong>：因为需要逐条执行写操作，恢复速度比 <code>RDB</code> 慢。</li><li><strong>潜在的性能开销</strong>：频繁的磁盘写操作可能会对性能产生影响，尤其是在 <code>appendfsync</code> 设置为 <code>always</code> 时。</li></ul><h3 id="2-4-AOF-的配置示例"><a href="#2-4-AOF-的配置示例" class="headerlink" title="2.4 AOF 的配置示例"></a>2.4 AOF 的配置示例</h3><pre><code class="hljs bash"><span class="hljs-comment"># AOF 记录写操作的策略，默认每秒同步一次</span>appendonly <span class="hljs-built_in">yes</span>appendfsync everysec<span class="hljs-comment"># AOF 文件重写配置</span>auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb</code></pre><h2 id="三、混合持久化"><a href="#三、混合持久化" class="headerlink" title="三、混合持久化"></a>三、混合持久化</h2><p>从 <code>Redis</code> 4.0 开始，支持一种称为“混合持久化”的模式，结合了 <code>RDB</code> 和 <code>AOF</code> 的优点。在这种模式下，<code>Redis</code> 会在后台生成 <code>RDB</code> 快照并将其附加到 <code>AOF</code> 文件中，同时将最近的写操作追加到 <code>AOF</code> 文件中。这样可以在恢复时使用 <code>RDB</code> 的快速加载，同时保留 <code>AOF</code> 的高数据完整性。</p><h3 id="混合持久化的配置示例"><a href="#混合持久化的配置示例" class="headerlink" title="混合持久化的配置示例"></a>混合持久化的配置示例</h3><pre><code class="hljs bash"><span class="hljs-comment"># 开启混合持久化</span>aof-use-rdb-preamble <span class="hljs-built_in">yes</span></code></pre><h2 id="四、选择合适的持久化策略"><a href="#四、选择合适的持久化策略" class="headerlink" title="四、选择合适的持久化策略"></a>四、选择合适的持久化策略</h2><ul><li><strong>RDB 模式适合</strong>：数据量大且对恢复速度要求高的场景，或者需要定期备份的情况。</li><li><strong>AOF 模式适合</strong>：对数据安全性要求较高的场景，需要尽可能减少数据丢失的风险。</li><li><strong>混合持久化模式适合</strong>：既需要快速恢复，又希望最大程度减少数据丢失的场景。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis集群实验</title>
      <link href="/2022/06/11/redis%E9%9B%86%E7%BE%A4%E5%AE%9E%E9%AA%8C/"/>
      <url>/2022/06/11/redis%E9%9B%86%E7%BE%A4%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>在前一篇博客中，介绍了如何在 <code>Ubuntu</code> 上使用 <code>Docker</code> 搭建 <code>Redis 6.0.0</code> 集群。搭建完成后，接下来我们可以进行一些实验，来对 <code>Redis</code> 集群的工作原理和新特性进行一个初步认识。本文将介绍如何通过一些常见的实验来测试和验证 <code>Redis</code> 集群的功能，包括数据分片、故障转移、主从同步等等</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>在进行以下实验之前，确保已经按照前文的方法成功搭建了一个包含6个节点的<code>Redis 6.0.0</code> 集群。</p><h2 id="实验一：数据分片"><a href="#实验一：数据分片" class="headerlink" title="实验一：数据分片"></a>实验一：数据分片</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>验证 <code>Redis</code> 集群如何在不同节点间分片存储数据。</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol><li>使用 <code>redis-cli</code> 连接到集群中的某一个节点：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-1 redis-cli -c -p 6371</code></pre><ol start="2"><li>插入一些键值对，观察它们在不同节点间的分布：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-1 redis-cli -c -p 6371     127.0.0.1:6371&gt; SET key1 <span class="hljs-string">&quot;value1&quot;</span>-&gt; Redirected to slot [9189] located at 127.0.0.1:6372OK127.0.0.1:6372&gt; SET key2 <span class="hljs-string">&quot;value2&quot;</span>-&gt; Redirected to slot [4998] located at 127.0.0.1:6371OK127.0.0.1:6371&gt; SET key3 <span class="hljs-string">&quot;value3&quot;</span>OK127.0.0.1:6371&gt; SET key4 <span class="hljs-string">&quot;value4&quot;</span>-&gt; Redirected to slot [13120] located at 127.0.0.1:6373OK127.0.0.1:6373&gt; SET key5 <span class="hljs-string">&quot;value5&quot;</span>-&gt; Redirected to slot [9057] located at 127.0.0.1:6372OK127.0.0.1:6372&gt; CLUSTER KEYSLOT key1(<span class="hljs-built_in">integer</span>) 9189127.0.0.1:6372&gt; CLUSTER KEYSLOT key2(<span class="hljs-built_in">integer</span>) 4998127.0.0.1:6372&gt; CLUSTER KEYSLOT key3(<span class="hljs-built_in">integer</span>) 935127.0.0.1:6372&gt; CLUSTER KEYSLOT key4(<span class="hljs-built_in">integer</span>) 13120127.0.0.1:6372&gt; CLUSTER KEYSLOT key5(<span class="hljs-built_in">integer</span>) 9057127.0.0.1:6372&gt;</code></pre><ul><li>设置键值对 <code>key1</code>:</li></ul><p><code>Redis</code> 计算出 <code>key1</code> 应该存储在哈希槽 <code>9189</code>。当前连接的是 <code>127.0.0.1:6371</code>，但哈希槽 <code>9189</code> 归属于节点 <code>127.0.0.1:6372</code>，因此 <code>Redis</code> 自动将请求重定向到 <code>127.0.0.1:6372</code> 节点，并在该节点上存储 <code>key1</code>。</p><ul><li>设置键值对 <code>key2</code>:</li></ul><p><code>Redis</code> 计算出 <code>key2</code> 应该存储在哈希槽 <code>4998</code>，这个哈希槽归属于当前连接的节点 <code>127.0.0.1:6371</code>，因此数据直接存储在 <code>127.0.0.1:6371</code>，没有进行重定向。</p><ul><li>设置键值对 <code>key3</code>:</li></ul><p>被分配到的哈希槽同样位于节点 <code>127.0.0.1:6371</code>，因此数据直接存储在该节点，无需重定向。</p><ul><li>设置键值对 <code>key4</code>:</li></ul><p><code>Redis</code> 计算出 <code>key4</code> 应该存储在哈希槽 <code>13120</code>，该哈希槽归属于节点 <code>127.0.0.1:6373</code>，因此数据被重定向到 <code>127.0.0.1:6373</code> 并存储在那里。</p><ul><li>设置键值对 <code>key5</code>:</li></ul><p><code>key5</code> 被分配到的哈希槽 <code>9057</code> 位于节点 <code>127.0.0.1:6372</code>，因此请求被重定向到该节点并存储数据。</p><ul><li>检查哈希槽分配:</li></ul><p>使用 <code>CLUSTER KEYSLOT</code> 命令可以查询每个键对应的哈希槽编号。通过哈希槽编号，<code>Redis</code> 决定每个键值对应该存储在哪个节点上。这展示了 <code>Redis</code> 集群如何通过哈希槽将数据均匀分布在不同的节点上。</p><p><strong>总结：</strong></p><p><code>Redis</code> 集群通过哈希槽（共16384个）将数据分配到不同的节点上。每个键被哈希后对应一个哈希槽编号，<code>Redis</code> 根据哈希槽编号确定数据的存储节点。这种分片机制保证了集群的横向扩展能力，即使数据量增加，集群也能够有效地分散负载，确保高效运行。</p><h2 id="实验二：故障转移"><a href="#实验二：故障转移" class="headerlink" title="实验二：故障转移"></a>实验二：故障转移</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>验证 <code>Redis</code> 集群的自动故障转移能力，当一个主节点失效时，从节点是否能够自动接管。</p><h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol><li>找到一个主节点，并停止该节点的容器：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker stop redis-1                              redis-1</code></pre><ol start="2"><li>等待几秒钟后，查看集群状态，验证新的主节点是否已自动选出：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-2 redis-cli -p 6372 CLUSTER NODES d0f53aca9ceefb82026d395e825a39554bc4280f 127.0.0.1:6376@16376 slave 0e2a32d078ecc37ae1126e658953fc790fe04fff 0 1724588629137 6 connectedf0a458466e522417340d66773def7b8ca596a96e 127.0.0.1:6375@16375 slave 23ace6314d5bfc6630ea02c2d86083140bdd48a7 0 1724588628110 5 connected23ace6314d5bfc6630ea02c2d86083140bdd48a7 127.0.0.1:6372@16372 myself,master - 0 1724588628000 2 connected 5461-109220e2a32d078ecc37ae1126e658953fc790fe04fff 127.0.0.1:6373@16373 master - 0 1724588628625 3 connected 10923-163832aa62f953d746c7ee36c8c79282dcf79a75375d9 127.0.0.1:6374@16374 master - 0 1724588628110 7 connected 0-5460eb921b7aad0b10aed38006870d849bc7572cb1fa 127.0.0.1:6371@16371 master,fail - 1724588614566 1724588612000 1 disconnected</code></pre><p><strong>详细分析：</strong></p><p><strong>节点 127.0.0.1:6371 状态</strong></p><ul><li><p>节点ID：<code>eb921b7aad0b10aed38006870d849bc7572cb1fa</code></p></li><li><p>状态：<code>master,fail - 1724588614566 1724588612000 1 disconnected</code></p></li><li><p>分析: 该节点原为主节点，但现在显示为 <code>fail</code> 状态，这意味着集群检测到它已失效并断开连接。这是因为在之前的步骤中停止了 <code>redis-1</code> 容器。由于这个节点负责哈希槽 <code>0-5460</code>，这些槽的数据需要通过集群的故障转移机制进行接管。</p></li></ul><p><strong>节点 127.0.0.1:6372 状态</strong></p><ul><li><p>节点ID：<code>23ace6314d5bfc6630ea02c2d86083140bdd48a7</code></p></li><li><p>状态：<code>myself,master - 0 1724588628000 2 connected 5461-10922</code></p></li><li><p>分析: 该节点显示为 <code>myself</code>,<code>master</code>，表示这是当前连接的节点，并且它是主节点，负责哈希槽 <code>5461-10922</code>。这个节点在集群中的状态为 <code>connected</code>，说明它正常工作。</p></li></ul><p><strong>节点 127.0.0.1:6373 状态</strong></p><ul><li><p>节点ID：<code>0e2a32d078ecc37ae1126e658953fc790fe04fff</code></p></li><li><p>状态：<code>master - 0 1724588628625 3 connected 10923-16383</code></p></li><li><p>分析: 该节点是集群中的另一个主节点，负责哈希槽 <code>10923-16383</code>，状态为 <code>connected</code>，表明正常工作。</p></li></ul><p><strong>节点 127.0.0.1:6374 状态</strong></p><ul><li><p>节点ID：<code>2aa62f953d746c7ee36c8c79282dcf79a75375d9</code></p></li><li><p>状态：<code>master - 0 1724588628110 7 connected 0-5460</code></p></li><li><p>分析: 该节点现在接管了哈希槽 <code>0-5460</code>，这部分槽原本属于已失败的 <code>127.0.0.1:6371</code>。这说明集群中的故障转移机制已运行，将原 <code>6371</code> 的主节点职责转移到 <code>6374</code> 以保证集群的正常运行。</p></li></ul><p><strong>从节点状态</strong></p><p><code>127.0.0.1:6375</code> 和 <code>127.0.0.1:6376</code> 均为从节点，它们各自复制主节点的数据，并在集群中保持 <code>connected</code> 状态。</p><p><strong>哈希槽 0-5460 由原来的 127.0.0.1:6371 转移到了 127.0.0.1:6374，这就是故障转移机制的体现。</strong></p><h2 id="实验三：主从同步"><a href="#实验三：主从同步" class="headerlink" title="实验三：主从同步"></a>实验三：主从同步</h2><h3 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h3><p>验证 <code>Redis</code> 集群中主从节点的数据同步机制。</p><h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>刚才我们停止了 <code>redis-1</code> 容器，现在重新运行</p><pre><code class="hljs Bash">zhangdongdong:~/ $ docker start redis-1                             redis-1</code></pre><ol><li>找到一个主节点和其对应的从节点。可以通过 <code>CLUSTER NODES</code> 命令查看主从关系：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-1 redis-cli -p 6371 CLUSTER NODES  f0a458466e522417340d66773def7b8ca596a96e 127.0.0.1:6375@16375 slave 23ace6314d5bfc6630ea02c2d86083140bdd48a7 0 1724589362522 5 connected23ace6314d5bfc6630ea02c2d86083140bdd48a7 127.0.0.1:6372@16372 master - 0 1724589362523 2 connected 5461-109222aa62f953d746c7ee36c8c79282dcf79a75375d9 127.0.0.1:6374@16374 master - 0 1724589363040 7 connected 0-5460d0f53aca9ceefb82026d395e825a39554bc4280f 127.0.0.1:6376@16376 slave 0e2a32d078ecc37ae1126e658953fc790fe04fff 0 1724589363552 6 connectedeb921b7aad0b10aed38006870d849bc7572cb1fa 127.0.0.1:6371@16371 myself,slave 2aa62f953d746c7ee36c8c79282dcf79a75375d9 0 1724589362000 1 connected0e2a32d078ecc37ae1126e658953fc790fe04fff 127.0.0.1:6373@16373 master - 0 1724589361495 3 connected 10923-16383</code></pre><p>总结以上主从关系:</p><p><code>master</code> 主节点：<code>6372</code> <code>6373</code> <code>6374</code> </p><p><code>slave</code> 从节点：<code>6371</code> <code>6375</code> <code>6376</code></p><ol start="2"><li>在主节点上 <code>6372</code> 写入数据：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-2 redis-cli -p 6372 SET mykey <span class="hljs-string">&quot;myvalue&quot;</span>                                                    (error) MOVED 14687 127.0.0.1:6373zhangdongdong:~/ $</code></pre><p>发现返回错误：<code>(error) MOVED 14687 127.0.0.1:6373</code>，说明当前 <code>key</code> <code>被映射到6373</code> 节点，所以我们可以换到 <code>6373</code> 进行写入</p><pre><code class="hljs Bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-3 redis-cli -p 6373 SET mykey <span class="hljs-string">&quot;myvalue&quot;</span>                                                    OKzhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-3 redis-cli -p 6373 GET mykey                                                              <span class="hljs-string">&quot;myvalue&quot;</span>zhangdongdong:~/ $</code></pre><p>成功</p><ol start="3"><li>在对应的从节点上检查数据是否已经同步：</li></ol><pre><code class="hljs bash">zhangdongdong:~/ $ docker <span class="hljs-built_in">exec</span> -it redis-6 redis-cli -p 6376        127.0.0.1:6376&gt; KEYS *1) <span class="hljs-string">&quot;mykey&quot;</span>2) <span class="hljs-string">&quot;key4&quot;</span>127.0.0.1:6376&gt;</code></pre><p>可以看见从节点 <code>redis-6</code> 已经有了在主节点 <code>redis-2</code> 添加的 <code>key4</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker快速搭建redids集群实验环境</title>
      <link href="/2022/05/26/%E4%BD%BF%E7%94%A8docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAredids%E9%9B%86%E7%BE%A4%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/05/26/%E4%BD%BF%E7%94%A8docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAredids%E9%9B%86%E7%BE%A4%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/docker-12bb9bcf3a20e5eb0255e561a8bacba6.jpeg"></p><p><code>Redis</code> 是一个开源的内存数据结构存储系统，广泛应用于缓存、会话管理、排行榜、计数器等场景。为了深入了解和实验 <code>Redis</code> 的集群模式，使用 <code>Docker</code> 来搭建 <code>Redis</code> 集群是一个非常方便的方法。本文将介绍如何在 <code>Ubuntu</code> 上使用 <code>Docker</code> 快速搭建一个 <code>Redis</code> 集群。</p><h2 id="步骤一：拉取Redis镜像"><a href="#步骤一：拉取Redis镜像" class="headerlink" title="步骤一：拉取Redis镜像"></a>步骤一：拉取Redis镜像</h2><p>首先拉取最新的 <code>Redis</code> 镜像：</p><pre><code class="hljs bash">docker pull redis:latest</code></pre><p>这将下载官方的 <code>Redis</code> 镜像，后续的容器都将基于这个镜像创建。</p><h2 id="步骤二：创建Redis节点容器"><a href="#步骤二：创建Redis节点容器" class="headerlink" title="步骤二：创建Redis节点容器"></a>步骤二：创建Redis节点容器</h2><p>为了搭建一个 <code>Redis</code> 集群，我们需要至少6个 <code>Redis</code> 节点（3个主节点和3个从节点）。使用以下命令创建这些容器：</p><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">seq</span> 1 6`; <span class="hljs-keyword">do</span>   docker run -d --name redis-<span class="hljs-variable">$i</span> --net host redis redis-server --appendonly <span class="hljs-built_in">yes</span> --cluster-enabled <span class="hljs-built_in">yes</span> --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-announce-ip 127.0.0.1 --port 637<span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span></code></pre><p>以上命令将启动6个 <code>Redis</code> 实例，并将它们分别绑定到 <code>6371</code> 到 <code>6376</code> 端口。</p><ul><li><code>--net host</code> 选项使容器使用宿主机的网络，这是为了简化集群配置时的网络问题。</li><li><code>--cluster-enabled yes</code> 启用了 <code>Redis</code> 集群模式。</li><li><code>--cluster-announce-ip</code> 配置了集群中每个节点的 <code>IP</code> 地址，在这里我们简单地使用了本地回环地址 <code>127.0.0.1</code>。</li></ul><h2 id="步骤三：配置Redis集群"><a href="#步骤三：配置Redis集群" class="headerlink" title="步骤三：配置Redis集群"></a>步骤三：配置Redis集群</h2><p>启动完所有 <code>Redis</code> 节点后，可以通过以下命令来配置并启动 <code>Redis</code> 集群：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-1 redis-cli --cluster create 127.0.0.1:6371 127.0.0.1:6372 127.0.0.1:6373 127.0.0.1:6374 127.0.0.1:6375 127.0.0.1:6376 --cluster-replicas 1</code></pre><ul><li><code>--cluster-replicas 1</code> 指定每个主节点有一个从节点。</li><li>该命令将自动选择节点作为主节点或从节点，并形成完整的 <code>Redis</code> 集群。</li></ul><p>在执行此命令后，会看到 <code>Redis</code> 要求确认配置，输入 <code>yes</code> 并按回车即可完成集群的创建。</p><h2 id="步骤四：验证集群状态"><a href="#步骤四：验证集群状态" class="headerlink" title="步骤四：验证集群状态"></a>步骤四：验证集群状态</h2><p>创建完集群后，可以通过以下命令验证集群的状态：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-1 redis-cli -p 6371 cluster nodes</code></pre><p>该命令会显示每个节点的角色（主或从）、连接信息等。如果所有节点的状态均为 <code>connected</code>，则说明集群已经成功搭建。</p><h2 id="步骤五：实验与测试"><a href="#步骤五：实验与测试" class="headerlink" title="步骤五：实验与测试"></a>步骤五：实验与测试</h2><p>现在可以在这个集群上进行各种Redis集群模式下的实验，例如：</p><ul><li>数据分片</li><li>故障转移</li><li>主从同步</li><li>节点扩展</li></ul><p>可以通过 <code>Redis</code> 的 <code>CLI</code> 工具来操作集群中的数据，观察其在不同节点间的分布与容错机制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker加速方法总结</title>
      <link href="/2022/04/26/docker%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/26/docker%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/docker-12bb9bcf3a20e5eb0255e561a8bacba6.jpeg"></p><p>有的时候我们在使用 <code>docker</code> 下载镜像时遇到速度很慢的情况。主要原因是 <code>Docker Hub</code> 的服务器位于国外，网络传输速度较慢。本文将总结一下网络上有的常见几种解决方案，帮助你加速 <code>Docker</code> 镜像的下载速度。</p><h2 id="1-使用国内镜像源"><a href="#1-使用国内镜像源" class="headerlink" title="1. 使用国内镜像源"></a>1. 使用国内镜像源</h2><p>国内很多公司提供了 <code>Docker</code> 镜像加速服务，可以通过配置 <code>Docker</code> 的 <code>daemon.json</code> 文件来使用这些加速器。</p><h3 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h3><ol><li>打开或创建 <code>/etc/docker/daemon.json</code> 文件</li></ol><pre><code class="hljs Bash">root@wwinter-00:~# <span class="hljs-built_in">cd</span> /etc/docker/root@wwinter-00:/etc/docker# <span class="hljs-built_in">ls</span>root@wwinter-00:/etc/docker#</code></pre><p>这里看到我的服务器中没有这个 <code>daemon.json</code> 文件，没关系，可使用 <code>vim</code> 来创建并添加以下内容</p><pre><code class="hljs Bash">root@wwinter-00:/etc/docker# vi daemon.jsonroot@wwinter-00:/etc/docker# root@wwinter-00:/etc/docker# <span class="hljs-built_in">cat</span> daemon.json &#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span>  ]&#125;</code></pre><ol start="2"><li>保存文件并重启 <code>Docker</code> 服务：</li></ol><pre><code class="hljs bash">root@wwinter-00:/etc/docker# systemctl daemon-reloadroot@wwinter-00:/etc/docker# systemctl restart docker</code></pre><h2 id="2-使用代理"><a href="#2-使用代理" class="headerlink" title="2. 使用代理"></a>2. 使用代理</h2><p>如果你有 <code>vpn</code> 服务可以网络环境支持代理，可以配置 <code>HTTP</code> 或 <code>HTTPS</code> 代理来加速 <code>Docker Pull</code> 的速度。</p><h3 id="配置步骤：-1"><a href="#配置步骤：-1" class="headerlink" title="配置步骤："></a>配置步骤：</h3><ol><li>在 <code>Docker</code> 的配置文件 <code>/etc/systemd/system/docker.service.d/http-proxy.conf</code> 中添加代理配置：</li></ol><pre><code class="hljs plaintext">    [Service]    Environment=&quot;HTTP_PROXY=http://your-proxy.com:port&quot;    Environment=&quot;HTTPS_PROXY=https://your-proxy.com:port&quot;</code></pre><ol start="2"><li>保存并重启 Docker 服务：</li></ol><pre><code class="hljs bash">    systemctl daemon-reload    systemctl restart docker</code></pre><h2 id="3-检查网络连接"><a href="#3-检查网络连接" class="headerlink" title="3. 检查网络连接"></a>3. 检查网络连接</h2><p>有时 <code>Docker Pull</code> 慢是由于本地网络问题，比如 <code>DNS</code> 配置问题、路由问题等。可以通过以下方法排查：</p><ul><li>检查本地网络的稳定性。</li><li>使用 <code>ping</code> 或 <code>traceroute</code> 命令测试与 <code>Docker Hub</code> 的连接状况。</li></ul><p>通过以上方法，可以有效加速 <code>Docker</code> 镜像的下载速度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在控制台打印树的结构</title>
      <link href="/2022/01/26/%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/26/%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zincv.oss-cn-hangzhou.aliyuncs.com/images/tree-3dd1430368563ef0e4be474e822478d0.jpeg"></p><p><a href="https://github.com/wwinter117/wwinter-ds-tree.git">https://github.com/wwinter117/wwinter-ds-tree.git</a></p><h1 id="wwinter-ds-tree"><a href="#wwinter-ds-tree" class="headerlink" title="wwinter-ds-tree"></a>wwinter-ds-tree</h1><p>可视化树结构，可以在控制台打印出树的形状，辅助树数据结构学习</p><p><strong>【案例】：不同形状的二叉搜索树</strong></p><p><a href="https://github.com/wwinter117/wwinter-ds-tree/blob/main/src/main/resources/pic/img.png"><img src="https://github.com/wwinter117/wwinter-ds-tree/raw/main/src/main/resources/pic/img.png" alt="img.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
